/**
 * Copyright (C) 2011 Inqwell Ltd
 *
 * You may distribute under the terms of the Artistic License, as specified in
 * the README file.
 *
 * A CSV fomat parser
 * Author: Tom Sanders
 *
 * $Archive: $
 * $Revision: 1.3 $
 * $Date: 2011-04-07 21:58:41 $
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  //DEBUG_PARSER = true;
  //COMMON_TOKEN_ACTION = true;
  STATIC = false;
}

PARSER_BEGIN(Csv)

package com.inqwell.any.io;

import com.inqwell.any.*;
import com.inqwell.any.client.RenderInfo;
import com.inqwell.any.client.AnyRenderInfo;
import java.io.Reader;
import java.io.InputStream;

public class Csv extends AbstractAny
{
  static private Array dummyHeaders__ = AbstractComposite.array();

  // The number of lines read so far - see also ignoreBlank_
  private int       lineCount_ = 0;

  // If true then we skip lines with no cells in them. Note
  // this is not the same as a line like ,,,, which has
  // four empty cells in it.
  private boolean   ignoreBlank_ = false;

  // The number of cells found on the most recent line
  private int       cellCount_;

  // Temporary cell storage
  private AnyString workingStr_ = new AnyString();

  // The number of fields autogenerated
  private int       autoGenerated_ = 0;

  // The root under which renderinfos will be executed
  private Map       root_;

  // Whether root_ was user-supplied or created on the fly
  private boolean   userRoot_;

  // Temporary build location
  private Map       workingRoot_;
  
  // Builder
  private BuildNodeMap b_;      

  // Whether the first line of the csv file should be considered
  // as headers and not data.  If true a separate array is created
  // to hold the header strings and these strings are set as the
  // labels if the prototypes are RenderInfo objects.
  private boolean   firstLineHeaders_ = false;
  private boolean   headersDone_      = false;
  private Array     headers_          = dummyHeaders__;

  private final static Any row__ = new AnyString("row");  // see also literal below!

  public Array readCSVLine(Array protos)
  {
    for (int i = 0; i < protos.entries(); i++)
    {
      Any a = protos.get(i);
      if (a instanceof Value)
      {
        Value v = (Value)a;
        v.setNull();
      }
    }

    Array ret = null;
    try
    {
      do
      {
        ret = CsvLine(protos);
      } while (ret == headers_ && headers_.entries() == 0);  // always ignore initial blank lines when doing headers
    }
    catch (ParseException x)
    {
      throw new RuntimeContainedException(x);
    }
    catch (Exception x)
    {
      throw new RuntimeContainedException(x);
    }
    catch (TokenMgrError x)
    {
      throw new RuntimeContainedException(x);
    }

    return ret;
  }

  int getLineCount()
  {
    return lineCount_;
  }

  int getCellCount()
  {
    return cellCount_;
  }

  void setFirstLineHeaders(boolean firstLineHeaders)
  {
    firstLineHeaders_ = firstLineHeaders;
  }

  boolean isFirstLineHeaders()
  {
    return firstLineHeaders_;
  }

  void initCSV()
  {
    cellCount_     = 0;
    lineCount_     = 0;
    autoGenerated_ = 0;

    if (workingRoot_ != null)
      workingRoot_.empty();

    headersDone_ = false;
    headers_     = dummyHeaders__;
  }

  void setRoot(Map root)
  {
    root_        = root;
    if (root != null)
    {
      userRoot_    = true;
      workingRoot_ = (Map)root.buildNew(null);
      initOrder(root);
    }
    else
    {
      workingRoot_ = null;
    }
  }

  Map getRoot()
  {
    return root_;
  }

  void setIgnoreBlank(boolean ignoreBlank)
  {
    ignoreBlank_ = ignoreBlank;
  }

  boolean getIgnoreBlank()
  {
    return ignoreBlank_;
  }

  Array getHeaders()
  {
    if (headers_ == dummyHeaders__)
      return null;

    return headers_;
  }

  // Called if parent CSVStream is in autotable mode, as the
  // initial renderinfo is provided as a seed.
  void initAutoGenerated()
  {
    autoGenerated_ = 1;
  }

  private void initOrder(Map root)
  {
    if (root instanceof Orderable)
    {
      // When the root is orderable force the insertion of
      // children to take place in strict order.
      Orderable o = (Orderable)root;
      OrderComparator c = null;
      o.sort(c);
    }
  }

  // Create the cell output. The generator for the specified field
  // is used to create the cell. There are a number of possibilities
  // depending on how the parser has been configured:
  //   1) generator is a value.  Copy the cell into it, clone
  //      and return.
  //   2) generator is a renderinfo object.  Create the data it
  //      represents. In this case we need a root node under
  //      which the node will be created:
  //          a)  If the parser has been supplied a root then
  //              it is used and the result left therein. This
  //              results in a table-friendly structure. The
  //              immediate child created by the renderinfo is
  //              returned.
  //          b)  If no root has been supplied then an InstanceHierarchyMap
  //              is used and the immediate child created is
  //              returned.
  // If the autogrow mode is in effect then, should there be insufficient
  // generators for the specified field number a new one will be created:
  //   generator is value: AnyString
  //   generator is renderinfo: renderinfo($this.row.A, type=string label="A")
  //     where A is A,B,C,...AA,AB,AC... as necessary.
  private Any generateCellRecord(Array generators, int field, String cell)
  {
    workingStr_.setValue(cell);

    if (firstLineHeaders_ && !headersDone_)
    {
      if (headers_ == dummyHeaders__)
        headers_ = AbstractComposite.array();

      headers_.add(workingStr_.cloneAny());
      return headers_;
    }

    if (field >= generators.entries())
      makeGenerator(generators, field);

    Any gen = generators.get(field);
    Any ret = null;
    if (gen instanceof Value)
    {
      gen.copyFrom(workingStr_);
      ret = gen.cloneAny();
    }
    else
    {
      RenderInfo r = (RenderInfo)gen;

      if (workingRoot_ == null)
      {
        workingRoot_ = AbstractComposite.managedMap();
        //initOrder(workingRoot_);
      }
      
      try
      {
        ret = r.resolveDataNode(workingRoot_, true);
        if (ret == null)
        {
          ret = makeCellData(r);

          NodeSpecification p = r.getRenderPath();
          if (b_ == null)
            b_ = new BuildNodeMap();
          b_.build(p, ret, workingRoot_);
        }
        ret.copyFrom(workingStr_);
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }

      //ret = workingRoot_.get(row__);
    }
    return ret;
  }

  private void makeGenerator(Array generators, int field)
  {
    // Build a new prototype for the cell.  Called when we don't have enough prototypes
    // for the current line being processed.

    if (generators.entries() == 0)
    {
      generators.add(new AnyString());
      autoGenerated_++;
    }
    else
    {
      if (generators.get(0) instanceof Value)
      {
        generators.add(new AnyString());
        autoGenerated_++;
      }
      else
      {
        // Assume renderinfo
        StringBuffer col = new StringBuffer(2);
        int indx    = autoGenerated_ % 676; // 26^2
        char first  = (char)(indx / 26);
        char second = (char)(indx % 26);
        if (first != 0)
          col.append((char)(first+'@')); // @ is one before A
        col.append((char)(second+'A'));

        String colStr = col.toString();
        String path = "row." + colStr;
        LocateNode l = new LocateNode(path);
        RenderInfo r = new AnyRenderInfo(l);
        r.setLabel(colStr);
        if (firstLineHeaders_ && field < headers_.entries())
        {
          r.setLabel(headers_.get(field).toString());
          // Do the seed one just in case
          if (field == 1)
          {
            RenderInfo r0 = (RenderInfo)generators.get(0);
            r0.setLabel(headers_.get(0).toString());
          }
        }

        //r.setData(new AnyString());
        generators.add(r);
        autoGenerated_++;
      }
    }
  }
  
  private Any makeCellData(RenderInfo r)
  {
    Descriptor d = r.getDescriptor();
    if (d == Descriptor.degenerateDescriptor__)
      return new AnyString();
    
    return d.getProto().get(r.getField()).cloneAny();
  }

  // If the current record has less cells than are currently expected
  // then clear the remaining ones
  private void clearTrailingCells(Array fields, int field)
  {
    int entries = fields.entries();
    if (entries == field)
      return;  // all fields filled up

    if (fields.get(0) instanceof Value)
    {
      for (int i = field; i < entries; i++)
      {
        Value v = (Value)fields.get(i);
        v.setNull();
      }
    }
    else
    {
      try
      {
        for (int i = field; i < entries; i++)
        {
          RenderInfo r = (RenderInfo)fields.get(i);
          Any cell = r.resolveDataNode(workingRoot_, true);
          if (cell instanceof Value)
          {
            Value v = (Value)cell;
            v.setNull();
          }
        }
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
    }
  }


  // Yield the cell contents from the parsed token
  static String processCSVCell(String cell)
  {
    if (cell.startsWith("\"\"") && cell.length() > 4) // dbl quoted string must contain something
      return cell.substring(2, cell.length()-2);
    else if (cell.startsWith("\""))
      return cell.substring(1, cell.length()-1);
    else
      return cell;
  }
}

PARSER_END(Csv)

TOKEN : /* */
{
  < CSV_CELL:
      ( "\"" (~["\""])* "\"")  // quoted cell, may contain commas
      |
      (~[",", "\r", "\n"])+              // unquoted string, cannot contain a comma
      |
      ( "\"\"" (~["\r", "\n"] "\"")+ "\"\"" ) // double quoted, can contain comma and will contain dbl quote
  >
}

TOKEN :
{
  < CSV_DELIM: "," >
}

TOKEN :
{
  < CSV_NEWLINE: "\n" | "\r\n" >
}

// Parse a line of CSV data.  Return an empty array if the line
// contained no cells or an array of cell data otherwise.
// Given fields are prototypical Anys for the cell values. If
// fields is insufficient in number for the line of data then
// strings will be used.
// Return null if eof was encountered before any fields were
// parsed.
Array CsvLine(Array fields) :
{
  int       field      = 0;
  //AnyString cellString = new AnyString();
  String    cellValue  = null;
  Array     line       = AbstractComposite.array();
  boolean   eof        = false;
}
{
  ( LOOKAHEAD(2)
    [ <CSV_CELL>
      {
        cellValue = processCSVCell(token.image);
        //cellString.setValue(cellValue);

        Any cell = generateCellRecord(fields, field, cellValue);
        //System.out.println("Adding cell 1 " + cell);

        // Check we are not processing the headers
        if (cell != headers_)
          line.add(cell);
      }
    ]
    <CSV_DELIM>
    {
      if ((headersDone_ || !firstLineHeaders_) && cellValue == null)
      {
        // Consecutive delimiters means an empty cell was found. Generate it
        Any cell = generateCellRecord(fields, field, cellValue);

        // This won't be the case because of the above test, so its just to look good.
        if (cell != headers_)
          line.add(cell);
      }

      cellValue = null;

      // TODO: test what happens when header cells are blank...

      field++;

      // In case there are blank fields we may need to make a generator
      // here to keep in step.  Even so, only make them when reading real
      // fields and not when reading headers.
      if ((headersDone_ || !firstLineHeaders_) && field >= fields.entries())
        makeGenerator(fields, field);

    }
  )*
  [ <CSV_CELL>
    {
      cellValue = processCSVCell(token.image);
      //cellString.setValue(cellValue);

      Any cell = generateCellRecord(fields, field, cellValue);
      //System.out.println("Adding cell 2 " + cell);

      // Check we are not processing the headers
      if (cell != headers_)
        line.add(cell);

      field++;
    }
  ]
  ( <CSV_NEWLINE> | <EOF> { eof = true; } )
  {
    // If the field count is zero then it was a blank line
    Array ret = (field == 0 && eof) ? null : line;
    if (firstLineHeaders_ && !headersDone_)
    {
      // TODO: blank header cell at eol
      ret = headers_;
      if (headers_.entries() != 0)
        headersDone_ = true;

      if (eof)
        ret = null;
    }
    else
    {
      if (ret != null && (field != 0 || !ignoreBlank_))
        lineCount_++;

      // Check for blank cell at eol
      if (field != 0 && cellValue == null)
      {
        Any cell = generateCellRecord(fields, field, cellValue);
        //System.out.println("Adding cell 3 " + cell);
        line.add(cell);
        field++;
      }

      clearTrailingCells(fields, field);
    }

    cellCount_ = field;
    cellValue  = null;

    if (ret != headers_ && workingRoot_ != null && ret != null && field != 0)
    {
      Any a = workingRoot_.remove(row__);
      if (root_ != null)
      {
        Map m = (Map)root_.buildNew(null);
        AnyString key = new AnyString("" + lineCount_);
        root_.add(key, m);
        m.add(row__, a);
        root_.setNodeSet(row__);
      }
    }

    return ret;
  }
}

