/**
 * Copyright (C) 2011 Inqwell Ltd
 *
 * You may distribute under the terms of the Artistic License, as specified in
 * the README file.
 *
 * Inq language grammar.
 * Author: Tom Sanders
 *
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  //DEBUG_PARSER = true;
  COMMON_TOKEN_ACTION = true;
  STATIC = false;
}

PARSER_BEGIN(Inq)

package com.inqwell.any.parser;

import com.inqwell.any.*;
import com.inqwell.any.Enum;
import com.inqwell.any.Process;
import com.inqwell.any.LayoutDoc;
import com.inqwell.any.channel.IsEmpty;
import com.inqwell.any.channel.SetCompression;
import com.inqwell.any.client.ClientTransaction;
import com.inqwell.any.client.UpdateEventProcessor;
import com.inqwell.any.client.ListenerAdapterFactory;
import com.inqwell.any.client.AnyAttributeSet;
import com.inqwell.any.client.AnyIcon;
import com.inqwell.any.client.AnyColor;
import com.inqwell.any.client.AnyFont;
import com.inqwell.any.client.SetFocus;
import com.inqwell.any.client.Show;
import com.inqwell.any.client.Hide;
import com.inqwell.any.client.ToFront;
import com.inqwell.any.client.Layout;
import com.inqwell.any.client.Login;
import com.inqwell.any.client.LoadClient;
import com.inqwell.any.client.LoadServer;
import com.inqwell.any.client.Parse;
import com.inqwell.any.client.Render;
import com.inqwell.any.client.RenderF;
import com.inqwell.any.client.GetDesktopState;
import com.inqwell.any.client.SetDesktopState;
import com.inqwell.any.client.SysOpen;
import com.inqwell.any.client.SysPrint;
import com.inqwell.any.client.RenderInfo;
import com.inqwell.any.client.AnyRenderInfo;
import com.inqwell.any.client.MakeRenderInfo;
import com.inqwell.any.client.DynamicMakeRenderInfo;
import com.inqwell.any.client.GuiInstantiator;
import com.inqwell.any.client.ArrowInstantiator;
import com.inqwell.any.client.BoxInstantiator;
import com.inqwell.any.client.MDIInstantiator;
import com.inqwell.any.client.DialogInstantiator;
import com.inqwell.any.client.AnyView;
import com.inqwell.any.client.AnyComponent;
import com.inqwell.any.client.AnySimpleComponent;
import com.inqwell.any.client.AnyButton;
import com.inqwell.any.client.AnyBox;
import com.inqwell.any.client.AnyGrid;
import com.inqwell.any.client.AnyLabel;
import com.inqwell.any.client.AnyWindow;
import com.inqwell.any.client.AnyDialog;
import com.inqwell.any.client.AnyInternalFrame;
import com.inqwell.any.client.MakeComponent;
import com.inqwell.any.client.GuiAttacher;
import com.inqwell.any.client.GuiRemover;
import com.inqwell.any.client.GuiPopup;
import com.inqwell.any.client.PropertyBinder;
import com.inqwell.any.client.AnyTabbedPane;
import com.inqwell.any.client.AnyCard;
import com.inqwell.any.client.AnyDocument;
import com.inqwell.any.client.swing.JPanel;
import com.inqwell.any.client.swing.StyledDocument;
import com.inqwell.any.client.swing.StyledEditorKit;
import com.inqwell.any.client.swing.JSplitPane;
import com.inqwell.any.client.AnyTable;
import com.inqwell.any.client.swing.TableModel;
import com.inqwell.any.client.swing.SwingInvoker;
import com.inqwell.any.client.dock.DockInstantiator;
import com.inqwell.any.client.dock.AnyCAction;
import com.inqwell.any.jms.SessionI;
import com.inqwell.any.jms.MqCreateConnection;
import com.inqwell.any.jms.MqCreateSession;
import com.inqwell.any.jms.MqCreateQueue;
import com.inqwell.any.jms.MqCreateTopic;
import com.inqwell.any.jms.MqCreateBytesMessage;
import com.inqwell.any.jms.MqCreateStreamMessage;
import com.inqwell.any.jms.MqCreateMapMessage;
import com.inqwell.any.jms.MqCreateMessage;
import com.inqwell.any.jms.MqCreateAnyMessage;
import com.inqwell.any.jms.MqCreateConsumer;
import com.inqwell.any.jms.MqCreateProducer;
import com.inqwell.any.jms.MqCreateDurableSubscriber;
import com.inqwell.any.jms.MqUnsubscribe;
import com.inqwell.any.jms.MqCreateTemporaryTopic;
import com.inqwell.any.jms.MqCreateTemporaryQueue;
import com.inqwell.any.jms.MqCreateTextMessage;
import com.inqwell.any.jms.MqStart;
import com.inqwell.any.jms.MqStop;
import com.inqwell.any.jms.MqSend;
import com.inqwell.any.jms.MqReceive;
import com.inqwell.any.jms.MqAcknowledge;
import com.inqwell.any.jms.MqClearMsg;
import com.inqwell.any.jms.MqReset;
import com.inqwell.any.jms.MqClose;
import com.inqwell.any.jms.MqSetMessageListener;
import com.inqwell.any.jms.MqCreateQueueBrowser;
import com.inqwell.any.jms.MqSetCommit;
import com.inqwell.any.jms.MessageStream;
import com.inqwell.any.print.Print;
import com.inqwell.any.print.AnyPrintAttribute;
import com.inqwell.any.print.AnyEnumSyntax;
import com.inqwell.any.print.PrintConstants;
import com.inqwell.any.net.InqStreamHandlerFactory;
import com.inqwell.any.util.CommandArgs;
import com.inqwell.any.io.PhysicalIO;
import com.inqwell.any.io.NullIO;
import com.inqwell.any.io.AbstractStream;
import com.inqwell.any.io.NativeStream;
import com.inqwell.any.io.XMLStream;
import com.inqwell.any.io.XMLXStream;
import com.inqwell.any.io.PrintStream;
import com.inqwell.any.io.FixedFieldStream;
import com.inqwell.any.io.ByteStream;
import com.inqwell.any.io.CSVStream;
import com.inqwell.any.io.PropertiesStream;
//import com.inqwell.any.io.EchoReader;
import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstraints;
import info.clearthought.layout.TableLayoutConstants;
import bibliothek.gui.dock.common.action.CAction;
import bibliothek.gui.dock.common.action.CRadioGroup;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.io.DataInputStream; // include
import java.io.FileInputStream; // include
import java.io.IOException; // include
import java.io.StringReader;
import java.io.File; // include
import java.lang.reflect.Field;
import java.awt.Container;
import java.awt.Component;
import java.awt.Insets;
import java.awt.CardLayout;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Calendar;
import java.util.Locale;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.net.URL;
import java.net.MalformedURLException;
import java.text.Format;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.AbstractButton;
import javax.swing.JSeparator;
import javax.swing.JTabbedPane;
import com.inqwell.any.client.swing.JMenu;
import javax.swing.JPopupMenu;
import javax.swing.JToolBar;
import javax.swing.JLabel;
//import com.inqwell.any.client.swing.JScrollPane;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import javax.swing.text.AbstractDocument;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.MutableAttributeSet;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.StyleConstants;

import com.inqwell.any.server.Create;
import com.inqwell.any.server.IsCreating;
import com.inqwell.any.server.IsManaged;
import com.inqwell.any.server.Creating;
import com.inqwell.any.server.Modifying;
import com.inqwell.any.server.IsModifying;
import com.inqwell.any.server.Deleting;
import com.inqwell.any.server.Delete;
import com.inqwell.any.server.Interrupt;
import com.inqwell.any.server.Kill;
import com.inqwell.any.server.SpawnProcess;
import com.inqwell.any.server.PrimaryTransaction;
import com.inqwell.any.server.BOTDescriptor;
import com.inqwell.any.server.CachingKey;
import com.inqwell.any.server.SimpleKey;
import com.inqwell.any.server.Lock;
import com.inqwell.any.server.Unlock;
import com.inqwell.any.io.sql.SqlManager;
import com.inqwell.any.io.sql.SimpleSqlIO;
import com.inqwell.any.io.csv.CsvIO;

import jline.*;

public class Inq extends AbstractAny
{
  // The package we are compiling for catalog items
  private String _package = "";

  // A list of imports mapping the import symbol to the package name
  private HashMap imports_;

  // The current service or function we are compiling
  private String _entity = "";

  // Zero at the outer level of script; 1 inside a function or immediate
  // execution block.
  private short  blockLevel_;

  // Specially treated arguments in send(...);
  static private ConstString context__  = new ConstString("sContext");
  static private ConstString acontext__ = new ConstString("@context");
  static private ConstString channel__  = new ConstString("sChannel");

  // Parser return indicators.  nonExec__ is returned
  // for things that don't execute like declarations
  // of functions and typedefs.
  static private ByteI   eof__     = new ConstByte();
  static private ByteI   nonExec__ = new ConstByte();

  // Default values for read()
  static private Any       defaultTarget__ = new LocateNode("$stack");

  // The url of the script we are currently executing, so
  // we can express other things with relative paths.
  String documentURL_    = "file:///";
  Any    documentAnyURL_;

  private Transaction userTxn_;

  // If we are running as an interactive parser (typically testing
  // scripts) then set this to true (done in our main() )
  // This means we can do things like create descriptors (which are
  // required when they are used for rendering hints) and have
  // specific control in this special case.
  private boolean     isInteractive_ = false;

  // When doing GUI or document layouts, this is initialised with the line number
  // of the layout statement in the file.  Then we can use it to offset the parser's
  // line number to give nice stack traces.
  private int         lineOffset_;

  private static Set    pathEvents__;
  private static Set    nodeEvents__;
  private static Set    execEvents__;
  private static Set    complexEvents__;
  private static Any    this__  = new ConstString(NodeSpecification.this__);
  private static Any    stack__ = new ConstString(NodeSpecification.stack__);

  private static HashMap captionPos__;
  private static HashMap captionJust__;
  private static HashSet geomSpec__;
  private static HashMap modifierKeys__;

  private static String lineTerminator__;
  private static int    lineTerminatorLen__;

  private static ShortI P_READ   = new ConstShort(Map.P_READ);
  private static ShortI P_WRITE  = new ConstShort(Map.P_WRITE);
  private static ShortI P_ADD    = new ConstShort(Map.P_ADD);
  private static ShortI P_REMOVE = new ConstShort(Map.P_REMOVE);

  static
  {
    lineTerminator__ = SystemProperties.instance().getSystemProperties().get(new ConstString("line_separator")).toString();
    lineTerminatorLen__ = lineTerminator__.length();

    pathEvents__ = AbstractComposite.set(5);
    pathEvents__.add(EventConstants.BOT_UPDATE);
    pathEvents__.add(EventConstants.BOT_DELETE);
    pathEvents__.add(EventConstants.NODE_ADDED);
    pathEvents__.add(EventConstants.NODE_REPLACED);
    pathEvents__.add(EventConstants.NODE_REMOVED);

    nodeEvents__ = AbstractComposite.set(8);
    nodeEvents__.add(EventConstants.BOT_CREATE);
    nodeEvents__.add(EventConstants.BOT_EXPIRE);
    nodeEvents__.add(EventConstants.BOT_UPDATE);
    nodeEvents__.add(EventConstants.BOT_DELETE);
    nodeEvents__.add(EventConstants.BOT_CATALOGED);
    nodeEvents__.add(EventConstants.NODE_ADDED);
    nodeEvents__.add(EventConstants.NODE_REPLACED);
    nodeEvents__.add(EventConstants.NODE_REMOVED);

    execEvents__ = AbstractComposite.set(2);
    execEvents__.add(EventConstants.EXEC_START);
    execEvents__.add(EventConstants.EXEC_COMPLETE);

    complexEvents__ = AbstractComposite.set();
    complexEvents__.add(EventConstants.BOT_CREATE);
    complexEvents__.add(EventConstants.BOT_EXPIRE);
    complexEvents__.add(EventConstants.BOT_UPDATE);
    complexEvents__.add(EventConstants.BOT_DELETE);
    complexEvents__.add(EventConstants.NODE_ADDED);
    complexEvents__.add(EventConstants.NODE_REPLACED);
    complexEvents__.add(EventConstants.NODE_REMOVED);
    complexEvents__.add(EventConstants.BOT_CATALOGED);
    complexEvents__.add(EventConstants.EXEC_START);
    complexEvents__.add(EventConstants.EXEC_COMPLETE);
    complexEvents__.add(EventConstants.M_CLICKED);
    complexEvents__.add(EventConstants.M_ENTERED);
    complexEvents__.add(EventConstants.M_EXITED);
    complexEvents__.add(EventConstants.M_PRESSED);
    complexEvents__.add(EventConstants.M_RELEASED);
    complexEvents__.add(EventConstants.M_POPUP);
    complexEvents__.add(EventConstants.M_MOVED);
    complexEvents__.add(EventConstants.M_DRAGGED);
    complexEvents__.add(EventConstants.K_TYPED);
    complexEvents__.add(EventConstants.K_PRESSED);
    complexEvents__.add(EventConstants.K_RELEASED);

    captionPos__ = new HashMap();
    captionPos__.put("at", new ConstInt(MakeComponent.aboveTop__));
    captionPos__.put("t",  new ConstInt(MakeComponent.top__));
    captionPos__.put("bt", new ConstInt(MakeComponent.belowTop__));
    captionPos__.put("ab", new ConstInt(MakeComponent.aboveBottom__));
    captionPos__.put("b",  new ConstInt(MakeComponent.bottom__));
    captionPos__.put("bb", new ConstInt(MakeComponent.belowBottom__));
    captionPos__.put("l", new ConstInt(MakeComponent.left__));
    captionPos__.put("r", new ConstInt(MakeComponent.right__));

    captionJust__ = new HashMap();
    captionJust__.put("l", new ConstInt(MakeComponent.left__));
    captionJust__.put("c", new ConstInt(MakeComponent.centre__));
    captionJust__.put("r", new ConstInt(MakeComponent.right__));

    geomSpec__ = new HashSet();
    geomSpec__.add("d");
    geomSpec__.add("i");
    geomSpec__.add("f");
    geomSpec__.add("v");

    modifierKeys__ = new HashMap();
    modifierKeys__.put(EventConstants.MOD_ALT.toString(), EventConstants.MOD_ALT);
    modifierKeys__.put(EventConstants.MOD_CTRL.toString(), EventConstants.MOD_CTRL);
    modifierKeys__.put(EventConstants.MOD_SHIFT.toString(), EventConstants.MOD_SHIFT);
    modifierKeys__.put(EventConstants.MOD_ALTGRAPH.toString(), EventConstants.MOD_ALTGRAPH);
    modifierKeys__.put(EventConstants.MOD_META.toString(), EventConstants.MOD_META);
  }

  public void setPackage(String inqPackage)
  {
    _package = inqPackage;
  }

  public String getPackage()
  {
    return _package;
  }

  public void setImports(HashMap imports)
  {
    imports_ = imports;
  }

  public HashMap getImports()
  {
    return imports_;
  }

  private String mapImport(String pkg)
  {
    if (imports_ != null)
    {
      String realPkg = (String)imports_.get(pkg);
      if (realPkg != null)
        pkg = realPkg;
    }
    return pkg;
  }

  static void initInteractive()
  {
    if (Globals.interpreter__ == null)
    {
      // Install the custom URL protocols  
      InqStreamHandlerFactory.install();
  
      // Just to get a lock manager in schizo mode. As alluded to above,
      // the lock manager should stand on its own and not accessed
      // via the Server instance (i.e. we may not be a Server).
      com.inqwell.any.server.Server.instance();
  
      // Set up the Globals
      Globals.interactive__               = true;
      Globals.channelOutputReplacements__ = com.inqwell.any.client.Replacements.clientToServer__;
      Globals.channelInputReplacements__  = com.inqwell.any.client.Replacements.clientFromServer__;
      Globals.streamOutputReplacements__  = com.inqwell.any.client.Replacements.clientToNativeStream__;
      Globals.streamInputReplacements__   = com.inqwell.any.client.Replacements.clientFromNativeStream__;
      Globals.streamOutputReplacements__  = com.inqwell.any.client.Replacements.clientToNativeStream__;
      
      // XML Replacements
      Globals.xmlStreamOutputReplacements__ = com.inqwell.any.client.Replacements.clientToXMLStream__;
      Globals.xmlStreamInputReplacements__  = com.inqwell.any.client.Replacements.clientFromXMLStream__;
  
      Globals.interpreter__               = new InqInterpreter();
      
      // TODO. Make LockManager universal - it doesn't need to rely on being a server
      //Globals.lockManager__               = new LockManager();
    }
  }
  
  static void initCommandArgs(CommandArgs cArgs)
  {
    Map argsMap = cArgs.toMap();
    argsMap.add(new ConstString("interactive"), AnyBoolean.TRUE);
    Catalog.instance().getCatalog().replaceItem(CommandArgs.commandLine__, argsMap);
  }
  
  static Process initProcess()
  {
    if (Globals.process__ == null)
    {
      // Make $root for the interactive environment
      BasicProcess.RootMap root = new BasicProcess.RootMap();
      
      // Note - PrimaryTransaction was tried out to get the locking-related
      // code it has. TODO: This code needs to be pulled up so it is also
      // available to ClientTransaction    
      Transaction          t    = new ClientTransaction();
      //Transaction          t    = new PrimaryTransaction();
  
      ExceptionHandler eh; //             = new ExceptionToService(new ConstString("system.client.services.handleException"),
                           //                                    UserProcess.loginContext__);
      EventDispatcher  connectedEd    = new EventDispatcher();
      EventDispatcher  disconnectedEd = new EventDispatcher();
      connectedEd.addEventListener(InvokeService.makeInvokeService
                                         (EventConstants.INVOKE_SVC,
                                          t,
                                          root));
  
      // Bit messy but for interactive testing
      disconnectedEd.addEventListener(InvokeService.makeInvokeService
                                         (EventConstants.INVOKE_SVC,
                                          t,
                                          root));
  
      UpdateEventProcessor.setupNodeEventDispatcher(connectedEd,
                                                    t,
                                                    root);
  
      eh = new ExceptionToStream(System.err);
      URL initInq = null;
      try
      {
        initInq = new URL("classpath:///com/inqwell/any/tools/Inqs.inq");
      }
      catch(MalformedURLException mue)
      {
        mue.printStackTrace();
        System.exit(0);
      }
  
      UserProcess p = null;
      try
      {
        p = new UserProcess(eh,
                            t,
                            root,
                            connectedEd,
                            disconnectedEd,
                            initInq);
        root.setProcess(p);
  
        //Globals.setProcessForThread(Thread.currentThread(), p);
      }
      catch(AnyException ae)
      {
        // TODO: allow to throw (and catch in main)
        ae.printStackTrace();
        System.exit(0);
      }
  
      // This is a test. Not possible to add or remove "package" from
      // $process. The fact that $process.package is originally installed
      // as a ConstString prevents it from being changed by value.
      p.add(UserProcess.package__, AnyAlwaysEquals.instance());
      Map privs = AbstractComposite.simpleMap();
      privs.add(AbstractMap.P_ADD, Process.A_MAXIMUM_PRIVILEGE);
      privs.add(AbstractMap.P_REMOVE, Process.A_MAXIMUM_PRIVILEGE);
      p.setPrivilegeLevels(privs, UserProcess.package__, false);
  
      p.setContext(root);
      p.setContextPath(ServerConstants.NSROOT);
      Globals.awtSync__     = true;
      Globals.process__     = p; // new UserProcess(Thread.currentThread(), root);
    }
    return Globals.process__;
  }
  
  static Inq initParser(CommandArgs cArgs, String args[])
  {
    String cwd = System.getProperties().getProperty("user.dir");
    String fs  = System.getProperties().getProperty("file.separator");

    AnyURL    url = new AnyURL();
    InputStream is;
    URL inUrl = null;
    if (cArgs.arg("-in", url) || cArgs.arg("-shebang", url))
    {
      inUrl = url.getURL(new AnyURL("file:///" + cwd + fs));
      try
      {
        is = inUrl.openStream();
      }
      catch(IOException e)
      {
        throw new RuntimeContainedException(e);
      }
    }
    else
    {
      // When no file was specified (we are reading the tty we assume)
      // set up jline library
      initJline();
      is = System.in;
    }

    Reader ir = new InputStreamReader(is);
    //if (cArgs.arg("-echo"))
    //  ir = new EchoReader(ir);
    // Can't do this because of buffering by the token mgr!
    
    Inq parser = new Inq(ir);
    String documentURL = (inUrl != null) ? inUrl.toString()
                                         : "file:///" + cwd + fs + "system.in";
    parser.setDocumentURL(documentURL);
    parser.isInteractive_ = true;
    parser.blockLevel_ = 0;

    Transaction t = Globals.process__.getTransaction();
    Map argsMap = (Map)Catalog.instance().getCatalog().get(CommandArgs.commandLine__);
    
    Call.setupCommandLineArgs(documentURL, args, argsMap, cArgs, t);
    if (inUrl != null)
      argsMap.replaceItem(CommandArgs.absin__, new AnyString(inUrl.toString()));
      
    // Save the input reader - only used if we want to reinitialise
    // when reading from stdin
    if (is == System.in)
      argsMap.add(CommandArgs.inputReader__, new AnyObject(ir));

    //parser.enable_tracing();

    parser.userTxn_ = t;

    AnyURL callStart = null;
    if (inUrl == null)
      callStart = new AnyURL(documentURL);
    else
    {
      callStart = new AnyURL(inUrl);
      t.setExecURL(callStart);
    }

    t.getCallStack().empty();
    t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
    
    return parser;
  }
  
  static Any parseLoop(Inq parser, CommandArgs cArgs)
  {
    Transaction t       = Globals.process__.getTransaction();
    boolean     show    = cArgs.arg("-show");
    Map         root    = Globals.process__.getRoot();
    Map         argsMap = (Map)Catalog.instance().getCatalog().get(CommandArgs.commandLine__);
    
    Any ret = null;
    
    while(true)
    {
      AnyRuntimeException e = null;
      try
      {
        while (true)
        {
          //System.out.flush();
          parser.lineOffset_ = 0;
  
          Any a = parser.inq();
          if (a == eof__)
            return ret;
  
          if (a == nonExec__)
            continue;
  
          ret = EvalExpr.evalFunc(t,
                                    root,
                                    a.cloneAny());
          t.commit();
          if (show)
            System.out.println(ret);
        }
      }
      catch (ParseException x)
      {
        e = new RuntimeContainedException(x, parser.documentURL_);
        e.fillInCallStack(t);
        t.getCallStack().empty();
      }
      catch (AnyException x)
      {
        e = new RuntimeContainedException(x, parser.documentURL_);
        e.fillInCallStack(t);
        t.getCallStack().empty();
      }
      catch (AnyRuntimeException x)
      {
        e = x;
        e.fillInCallStack(t);
        t.getCallStack().empty();
      }
      catch (Exception x)
      {
        e = new RuntimeContainedException(x, parser.documentURL_);
        e.fillInCallStack(t);
        t.getCallStack().empty();
      }
      catch (StackOverflowError x)
      {
        e = new RuntimeContainedException(x, parser.documentURL_);
        e.topOfStack(t);
      }
      catch (TokenMgrError x)
      {
        e = new RuntimeContainedException(x, parser.documentURL_);
        e.fillInCallStack(t);
        t.getCallStack().empty();
      }
      if (e != null)
      {
        // When running with stdin print
        // out the exception details and carry on.
        // Otherwise throw
        if (argsMap.contains(CommandArgs.inputReader__))
        {
          InputStreamReader ir = (InputStreamReader)((AnyObject)argsMap.get(CommandArgs.inputReader__)).getValue();
          t.getCallStack().empty();
          System.err.println(e.getMessage());
          e.printStackTrace();
          parser.ReInit(ir);
        }
        else
        {
          throw e;
        }
      }
    }
  }

  public static void main(String args[])
  {
    initInteractive();
    CommandArgs cArgs = new CommandArgs(args);
    initCommandArgs(cArgs);
    Process p = initProcess();

    boolean version = cArgs.arg("-version");
    if (version)
    {
      Version v = new Version();
      try
      {
        System.out.println(v.exec(null));
      }
      catch(AnyException e)
      {
        e.printStackTrace();
      }
      finally
      {
        System.exit(0);
      }
    }
    
    Map argsMap = (Map)Catalog.instance().getCatalog().get(CommandArgs.commandLine__);
    if (!cArgs.arg("-q") && !argsMap.contains(CommandArgs.shebang__))
    {
      System.out.println("Inq Parser");
      System.out.println("Copyright (c) Inqwell Ltd 2002-2012");
      System.out.println("JavaCC Copyright (c) 2006, Sun Microsystems, Inc.");
      System.out.println("Docking Frames Copyright (c) Benjamin Sigg and others 2011");
      System.out.println("JDateChooser Copyright (c) Kai Toedter 1999 - 2009; Inqwell 2011");
      System.out.println("JLine Copyright (c) 2002-2006, Marc Prud'hommeaux <mwp1@cornell.edu>.");
    }
    
    Inq parser = initParser(cArgs, args);
    
    Globals.setProcessForThread(Thread.currentThread(), p);
    
    // Just in case script does graphics and events come up the awt thread
    synchronized(Globals.process__)
    {
      Globals.inqActive__ = true;
      SwingInvoker.initSwing();
      parseLoop(parser, cArgs);
      Globals.inqActive__ = false;
    }
    parser.userTxn_ = null;
    Globals.removeProcessForThread(Thread.currentThread(), p);
    ((UserProcess)p).startThread(true); // make it a daemon from the cmd line

    if (!cArgs.arg("-q") && !argsMap.contains(CommandArgs.shebang__))
      System.out.println("Inq done");
  }
  
  // For parser testing
  public static void OLDmain(String args[]) throws IOException
  {
    InqStreamHandlerFactory.install();

    Transaction          t    = new ClientTransaction();
    //Transaction          t    = new PrimaryTransaction();
    BasicProcess.RootMap root = new BasicProcess.RootMap();

    // Just to get a lock manager in schizo mode
    com.inqwell.any.server.Server.instance();

    ExceptionHandler eh; //             = new ExceptionToService(new ConstString("system.client.services.handleException"),
                         //                                    UserProcess.loginContext__);
    EventDispatcher  connectedEd    = new EventDispatcher();
    EventDispatcher  disconnectedEd = new EventDispatcher();
    connectedEd.addEventListener(InvokeService.makeInvokeService
                                       (EventConstants.INVOKE_SVC,
                                        t,
                                        root));

    // Bit messy but for interactive testing
    disconnectedEd.addEventListener(InvokeService.makeInvokeService
                                       (EventConstants.INVOKE_SVC,
                                        t,
                                        root));

    UpdateEventProcessor.setupNodeEventDispatcher(connectedEd,
                                                  t,
                                                  root);

    eh = new ExceptionToStream(System.err);
    URL initInq = null;
    try
    {
      initInq = new URL("cp:///com/inqwell/any/tools/Inqs.inq");
    }
    catch(MalformedURLException mue)
    {
      mue.printStackTrace();
      System.exit(0);
    }

    Globals.interactive__               = true;
    Globals.channelOutputReplacements__ = com.inqwell.any.client.Replacements.clientToServer__;
    Globals.channelInputReplacements__  = com.inqwell.any.client.Replacements.clientFromServer__;
    Globals.streamOutputReplacements__  = com.inqwell.any.client.Replacements.clientToNativeStream__;
    Globals.streamInputReplacements__   = com.inqwell.any.client.Replacements.clientFromNativeStream__;
    Globals.streamOutputReplacements__  = com.inqwell.any.client.Replacements.clientToNativeStream__;
    // XML Replacements
    Globals.xmlStreamOutputReplacements__ = com.inqwell.any.client.Replacements.clientToXMLStream__;
    Globals.xmlStreamInputReplacements__  = com.inqwell.any.client.Replacements.clientFromXMLStream__;

    Globals.interpreter__               = new InqInterpreter();
    //Globals.lockManager__               = new LockManager();


    UserProcess p = null;
    try
    {
      p = new UserProcess(eh,
                          t,
                          root,
                          connectedEd,
                          disconnectedEd,
                          initInq);
      root.setProcess(p);

      Globals.setProcessForThread(Thread.currentThread(), p);
    }
    catch(AnyException ae)
    {
      ae.printStackTrace();
      System.exit(0);
    }


    Globals.process__     = p; // new UserProcess(Thread.currentThread(), root);
    //Globals.process__.setTransaction(t);
    Globals.awtSync__     = true;
    //Globals.interpreter__ = new InqInterpreter();
    //Globals.lockManager__ = new LockManager();
    Globals.process__.setContext(root);
    Globals.process__.setContextPath(ServerConstants.NSROOT);

    CommandArgs cArgs   = new CommandArgs(args);
////
    Map         argsMap = cArgs.toMap();
    argsMap.add(new ConstString("interactive"), AnyBoolean.TRUE);
    Catalog.instance().getCatalog().add(CommandArgs.commandLine__, argsMap);
////

// Proper main start....

    boolean version = cArgs.arg("-version");
    if (version)
    {
      Version v = new Version();
      try
      {
        System.out.println(v.exec(null));
      }
      catch(AnyException e)
      {
        e.printStackTrace();
      }
      finally
      {
        System.exit(0);
      }
    }
    
    if (!cArgs.arg("-q") && !argsMap.contains(CommandArgs.shebang__))
    {
      System.out.println("Inq Parser");
      System.out.println("Copyright (c) Inqwell Ltd 2002-2012");
      System.out.println("JavaCC Copyright (c) 2006, Sun Microsystems, Inc.");
      System.out.println("Docking Frames Copyright (c) Benjamin Sigg and others 2011");
      System.out.println("JDateChooser Copyright (c) Kai Toedter 1999 - 2009; Inqwell 2011");
      System.out.println("JLine Copyright (c) 2002-2006, Marc Prud'hommeaux <mwp1@cornell.edu>.");
    }  

    boolean show    = cArgs.arg("-show");

    String cwd = System.getProperties().getProperty("user.dir");
    String fs  = System.getProperties().getProperty("file.separator");

    AnyURL    url = new AnyURL();
    InputStream is;
    URL inUrl = null;
    if (cArgs.arg("-in", url) || cArgs.arg("-shebang", url))
    {
      inUrl = url.getURL(new AnyURL("file:///" + cwd + fs));
      is = inUrl.openStream();
      
    }
    else
    {
      // When no file was specified (we are reading the tty we assume)
      // set up jline library
      initJline();
      is = System.in;
    }

    Reader ir = new InputStreamReader(is);
    //if (cArgs.arg("-echo"))
    //  ir = new EchoReader(ir);
    // Can't do this because of buffering by the token mgr!

    Inq parser = new Inq(ir);
    String documentURL = (inUrl != null) ? inUrl.toString()
                                         : "file:///" + cwd + fs + "system.in";
    parser.setDocumentURL(documentURL);
    parser.isInteractive_ = true;
    parser.blockLevel_ = 0;

////
    p.add(UserProcess.package__, AnyAlwaysEquals.instance());
    Map privs = AbstractComposite.simpleMap();
    
    // This is a test. Not possible to add or remove "package" from
    // $process. The fact that $process.package is originally installed
    // as a ConstString prevents it from being changed by value.
    privs.add(AbstractMap.P_ADD, Process.A_MAXIMUM_PRIVILEGE);
    privs.add(AbstractMap.P_REMOVE, Process.A_MAXIMUM_PRIVILEGE);
    p.setPrivilegeLevels(privs, UserProcess.package__, false);
////

    Call.setupCommandLineArgs(documentURL, args, argsMap, cArgs, t);
    if (inUrl != null)
      argsMap.add(new ConstString("absin"), new AnyString(inUrl.toString()));
      
    //parser.enable_tracing();

    parser.userTxn_ = t;

    AnyURL callStart = null;
    if (inUrl == null)
      callStart = new AnyURL(documentURL);
    else
    {
      callStart = new AnyURL(inUrl);
      t.setExecURL(callStart);
    }

    t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));

    // Just in case script does graphics and events come up the awt thread
    synchronized(Globals.process__)
    {
      Globals.inqActive__ = true;
      SwingInvoker.initSwing();

      while (true)
      {
        System.out.flush();
        try
        {
          parser.lineOffset_ = 0;

          Any a = parser.inq();
          if (a == eof__)
            break;

          if (a == nonExec__)
            continue;

          Any r = EvalExpr.evalFunc(t,
                                    root,
                                    a.cloneAny());
          t.commit();
          if (show)
            System.out.println(r);
        }
        catch (ParseException x)
        {
          AnyException ce = new ContainedException(x, parser.documentURL_);
          ce.fillInCallStack(t);
          t.getCallStack().empty();
          System.err.println(ce.getMessage());
          ce.printStackTrace();
          t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
          parser.ReInit(ir);
        }
        catch (AnyException x)
        {
          x.fillInCallStack(t);
          t.getCallStack().empty();
          System.err.println(x.getMessage());
          x.printStackTrace();
          t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
          //parser.ReInit(ir);
        }
        catch (AnyRuntimeException x)
        {
          x.fillInCallStack(t);
          t.getCallStack().empty();
          System.err.println(x.getMessage());
          x.printStackTrace();
          t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
          //parser.ReInit(ir);
        }
        catch (Exception x)
        {
          AnyException ce = new ContainedException(x, parser.documentURL_);
          ce.fillInCallStack(t);
          t.getCallStack().empty();
          System.err.println(ce.getMessage());
          ce.printStackTrace();
          t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
          //parser.ReInit(ir);
        }
        catch (StackOverflowError x)
        {
          AnyException ce = new ContainedException(x, parser.documentURL_);
          ce.topOfStack(t);
          t.getCallStack().empty();
          ce.printStackTrace();
          t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
          //parser.ReInit(ir);
        }
        catch (TokenMgrError x)
        {
          AnyException ce = new ContainedException(x, parser.documentURL_);
          ce.fillInCallStack(t);
          t.getCallStack().empty();
          System.err.println(ce.getMessage());
          ce.printStackTrace();
          t.getCallStack().push(new Call.CallStackEntry(callStart, Interpreter.parser__));
          parser.ReInit(ir);
        }
      }
      Globals.inqActive__ = false;
    }
    parser.userTxn_ = null;
    Globals.removeProcessForThread(Thread.currentThread(), p);
    p.startThread(true); // make it a daemon from the cmd line

    if (!cArgs.arg("-q") && !argsMap.contains(CommandArgs.shebang__))
      System.out.println("Inq done");
  }

  public void setDocumentURL(String url)
  {
    if (url != null)
    {
      documentURL_    = url;
      documentAnyURL_ = new ConstString(url);

      token_source.setDocumentURL(this, url, documentAnyURL_);
    }
    else
    {
      documentURL_ = null;
      documentAnyURL_ = null;
      token_source.setDocumentURL(null, null, null);
    }
  }

  public Any runInq(Any root, AnyURL baseURL, Transaction t, InputStream i)
  {
    lineOffset_ = 0;
    userTxn_ = t;
    try
    {
      ReInit(i);
      token_source.SwitchTo(DEFAULT);
      setDocumentURL(baseURL.getURL().toString());
      return run(root, t);
    }
    finally
    {
      userTxn_ = null;
    }
  }

  public Any runInq(Any root, AnyURL baseURL, Transaction t, Reader r)
  {
    lineOffset_ = 0;
    userTxn_ = t;
    try
    {
      ReInit(r);
      token_source.SwitchTo(DEFAULT);
      setDocumentURL(baseURL.getURL().toString());
      return run(root, t);
    }
    finally
    {
      userTxn_ = null;
    }
  }

  public Any compileInq(Any root, AnyURL baseURL, Transaction t, InputStream i)
  {
    lineOffset_ = 0;
    userTxn_ = t;
    try
    {
      ReInit(i);
      token_source.SwitchTo(DEFAULT);
      setDocumentURL(baseURL.getURL().toString());
      return compile(root, t);
    }
    finally
    {
      userTxn_ = null;
    }
  }

  public Any compileInq(Any root, AnyURL baseURL, Transaction t, Reader r)
  {
    lineOffset_ = 0;
    userTxn_ = t;
    try
    {
      ReInit(r);
      token_source.SwitchTo(DEFAULT);
      setDocumentURL(baseURL.getURL().toString());
      return compile(root, t);
    }
    finally
    {
      userTxn_ = null;
    }
  }

  public Any layoutGui(Any context, Map components, Map mInqRoot, AnyView awtRoot, Any rootName, Transaction t, InputStream i)
  {
    Any ret = null;
    // Make a note of the line number before we start the layout. This is a new run
    // of the parser so its line number will be 1.  To give helpful error messages
    // relating to the file line number we need to know where in the file the layout
    // starts.
    lineOffset_ = t.getLineNumber();
    userTxn_    = t;
    setDocumentURL(t.getExecURL().toString());


    ReInit(i);
    token_source.SwitchTo(GUI);
    try
    {
      ret = StartGui(context, components, mInqRoot, awtRoot, rootName, t);
    }
    catch (ParseException x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (Exception x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (TokenMgrError x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    finally
    {
      userTxn_ = null;
    }
    return ret;
  }

  public Any layoutGui(Any context, Map components, Map mInqRoot, AnyView awtRoot, Any rootName, Transaction t, Reader r)
  {
    Any ret = null;
    // Make a note of the line number before we start the layout. This is a new run
    // of the parser so its line number will be 1.  To give helpful error messages
    // relating to the file line number we need to know where in the file the layout
    // starts.
    lineOffset_ = t.getLineNumber();
    userTxn_    = t;
    setDocumentURL(t.getExecURL().toString());


    ReInit(r);
    token_source.SwitchTo(GUI);
    try
    {
      ret = StartGui(context, components, mInqRoot, awtRoot, rootName, t);
    }
    catch (ParseException x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (Exception x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (TokenMgrError x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    finally
    {
      userTxn_ = null;
    }
    return ret;
  }

  public Any layoutDoc(Any context, StyledDocument doc, Transaction t, InputStream i)
  {
    Any ret = null;
    lineOffset_ = t.getLineNumber();
    userTxn_ = t;
    setDocumentURL(t.getExecURL().toString());

    ReInit(i);
    token_source.SwitchTo(DOC);
    try
    {
      LayoutDoc(context, doc, t);
    }
    catch (ParseException x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (Exception x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (TokenMgrError x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    finally
    {
      userTxn_ = null;
    }
    return ret;
  }

  public Any layoutDoc(Any context, StyledDocument doc, Transaction t, Reader r)
  {
    Any ret = null;

    lineOffset_ = t.getLineNumber();
    userTxn_ = t;
    setDocumentURL(t.getExecURL().toString());

    ReInit(r);
    token_source.SwitchTo(DOC);
    try
    {
      LayoutDoc(context, doc, t);
    }
    catch (ParseException x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (Exception x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    catch (TokenMgrError x)
    {
      throw new RuntimeContainedException(x, documentURL_);
    }
    finally
    {
      userTxn_ = null;
    }
    return ret;
  }

  Any run(Any root, Transaction t)
  {
    Any ret = null;

    blockLevel_ = 0;

    while (true)
    {
      try
      {
        Any a = inq();
        if (a == eof__)
          break;

        if (a == nonExec__)
          continue;

        ret = EvalExpr.evalFunc(t,
                                root,
                                a);
      }
      catch (ParseException x)
      {
        //t.setLineNumber(token.beginLine);
        throw new RuntimeContainedException(x, documentURL_);
      }
      catch (Exception x)
      {
        //t.setLineNumber(token.beginLine);
        throw new RuntimeContainedException(x, documentURL_);
      }
      catch (TokenMgrError x)
      {
        //t.setLineNumber(token.beginLine);
        throw new RuntimeContainedException(x, documentURL_);
      }
    }
    return ret;
  }

  Any compile(Any root, Transaction t)
  {
    // Compile the script and return as many statements as there are
    // in a sequence. Means that the script sample doesn't need to
    // be a block statement.
    Array ret = AbstractComposite.array();

    blockLevel_ = -1;

    while (true)
    {
      try
      {
        Any a = inq();
        if (a == eof__)
          break;

        if (a == nonExec__ || a == null)
          continue;

        ret.add(a);

      }
      catch (ParseException x)
      {
        throw new RuntimeContainedException(x, documentURL_);
      }
      catch (Exception x)
      {
        throw new RuntimeContainedException(x, documentURL_);
      }
      catch (TokenMgrError x)
      {
        throw new RuntimeContainedException(x, documentURL_);
      }
    }
    return ret;
  }

  String processStringEscapes(String s)
  {
    s = processStringEscapes(s, '\\');
    return s;
  }

  char processCharEscapes(String s)
  {
    return processCharEscapes(s, '\\');
  }

  char processCharEscapes(String s, char escape)
  {
    // see lexical specification
    if (s.indexOf(escape) < 0)
      return s.charAt(1);

    char echar = s.charAt(2);
    switch(echar)
    {
      case 'n': return '\n';  // or should this be (char)10  ?
      case 'r': return '\r';  // or should this be (char)12  ?
      case 't': return '\t';
      case 'b': return '\b';
      case 'f': return '\f';
      case '\\': return '\\';
      case '"':  return '"';
      case '\'': return '\'';
      default:
      {
        // provided the lexical definition below matches
        // this code no further checking is needed.  Consume
        // while current character is a digit and consider
        // as octal
        int     placeValue = 1;
        int     val        = 0;
        boolean lzero      = true;
        int to = 2;
        int len = s.length();
        do
        {
          val = val * placeValue + echar - '0';
          if (echar != '0')
            lzero = false;
          if (!lzero)
            placeValue *= 8;
        }
        while ((++to < len) && Character.isDigit(echar = s.charAt(to)));
        return (char)val;
      }
    }
  }

  String processStringEscapes(String s, char escape)
  {
    int pos, len;
    int cur = 0;

    if ((len = s.length()) == 0 || (pos = s.indexOf(escape)) < 0)
      return s;

    // Examine escape sequences and substitute for char equivalent
    StringBuffer buf = new StringBuffer(len);

    while (cur < len)
    {
      cur = doEscape(s, buf, cur, pos, len, escape);
      pos = s.indexOf(escape, cur);
    }

    return buf.toString();
  }

  int doEscape(String       s,
               StringBuffer buf,
               int          cur,
               int          pos,
               int          len,
               char         escape)
  {
    // if pos is non-negative it represents the \ character
    // at the start of an escape sequence.  Otherwise there
    // is no sequence left so copy remaining from cur

    int to = (pos < 0) ? len : pos;

    for (int i = cur; i < to; i++)
      buf.append(s.charAt(i));

    if (pos < 0)
      return len;

    // consume escape chars
    // step over escape char
    char echar = s.charAt(++to);

    switch(echar)
    {
      case 'n':
        buf.append(lineTerminator__); to++;
        break;

      case 'r':  buf.append('\r'); to++; break;
      case 't':  buf.append('\t'); to++; break;
      case 'b':  buf.append('\b'); to++; break;
      case 'f':  buf.append('\f'); to++; break;
      case '\\': buf.append('\\'); to++; break;
      case '"':  buf.append('"');  to++; break;
      case '\'': buf.append('\''); to++; break;
      case 'p':  buf.append(_package); to++; break;
      case 'e':  buf.append(_entity);  to++; break;
      case 'i':  buf.append(documentURL_);  to++; break;
      case 'l':  buf.append(token.beginLine);  to++; break;
      case '\r': to++; if (to < len && s.charAt(to) == '\n') to++; break;
      case '\n': to++; break;
      case 'u': unicode(s, s.charAt(++to), to, len, buf); break;
      default:
      {
        // provided the lexical definition below matches
        // this code no further checking is needed.  Consume
        // up to maxOctal digits
        // while current character is a digit and consider
        // as octal
        int     maxOctal   = echar > '3' ? 2 : 3;
        int     placeValue = 1;
        int     val        = 0;
        boolean lzero      = true;
        do
        {
          val = val * placeValue + echar - '0';
          if (echar != '0')
            lzero = false;
          if (!lzero)
            placeValue *= 8;
        }
        while ((++to < len) &&
               Character.isDigit(echar = s.charAt(to)) &&
               echar < '8' &&
               --maxOctal > 0);
        buf.append((char)val);
      }
    }

    return to;
  }

  // Decode unicode
  // The u has already been processed.
  private int unicode(String s, char echar, int to, int len, StringBuffer buf)
  {
    int     maxUnicode = 4;
    int     placeValue = 1;
    int     val        = 0;
    boolean lzero      = true;
    do
    {
      if (echar <= '9')
        val = val * placeValue + echar - '0';
      else
      {
        echar = Character.toUpperCase(echar);
        val = val * placeValue + echar - 'A' + 10;
      }
      if (echar != '0')
        lzero = false;
      if (!lzero)
        placeValue *= 16;
    }
    while ((++to < len) &&
           (Character.isDigit(echar = s.charAt(to)) ||
            (echar <= 'f' && echar >= 'a') ||
            (echar <= 'F' && echar >= 'A')) &&
           --maxUnicode > 0);
    buf.append((char)val);
    return to;
  }

  private void ensureTopLevel(String declType)
  {
    if (blockLevel_ < 0)
      throw new AnyRuntimeException("Declarations cannot be compiled");

    if (blockLevel_ != 0)
      throw new AnyRuntimeException(declType + " at " + token.beginLine + " must be declared at the outermost script level");
  }

  public static NodeSpecification setPrefices(NodeSpecification n)
  {
    if (n.entries() == 0)
      return n;

    Any first = n.getFirst();

    // explicit prefix (not including $this) leave as it is
    if (NodeSpecification.prefices__.contains(first))
      return n;

    // prefix is $this - remove.  Examine next token and if it is the
    // strict control token then remove that as well.
    if (first.equals(this__))
    {
      n.removeFirst();

      int entries = n.entries();

      if (entries < 2)
        n.addFirst(NodeSpecification.strict__);
      else if (n.getFirst().equals(NodeSpecification.strict__))
        n.removeFirst();

      return n;
    }
    
    // Either a control token or path element.  Add $stack prefix
    n.addFirst(NodeSpecification.strict__);
    n.addFirst(stack__);
/*
    // However (and this is a bit ugly I agree) if the first
    // element is an indirection then leave alone and allow
    // the indirection to define any $this, $stack etc. Makes
    // paths like {$this.x} work whereas otherwise they would
    // be redirected to $tack.x
    if (!(n.getFirst() instanceof Locate))
    {
      n.addFirst(NodeSpecification.strict__);
      n.addFirst(stack__);
    }
*/    
    return n;
  }

  // Like above but called when processing an embedded NS syntax like {...}
  // For the [...] syntax we are only called when the index is a node ref or
  // either "first" or "last" or "@first" or "@last".  Check for these
  // explicitly.
  static StringBuffer setPrefices(StringBuffer s)
  {
    String str = s.toString();

    if (str.equals(NodeSpecification.first__) ||
        str.equals(NodeSpecification.last__) ||
        str.equals(NodeSpecification.atIterFirst__.toString()) ||
        str.equals(NodeSpecification.atIterLast__.toString()))
      return s;

    /*
    // Use processing as above!
    NodeSpecification n = new NodeSpecification(str);
    n = setPrefices(n);
    */
    if (s.indexOf(NodeSpecification.this__) > -1) // will always be zero
    {
      s.delete(0, NodeSpecification.this__.length());
      if (s.length() == 0)
        s.insert(0, '.');
      else if (s.charAt(0) == '.')
      {
        if (s.length() != 1)
          s.delete(0,1);
      }
      return s;
    }

    if (s.charAt(0) == '$')  // explicit prefix
      return s;

    s.insert(0, "$stack.");
    //if (s.length() == 0)
    //  s.append('.');

    return s;
  }

  static Any complexEventType(Any        eventType,
                              Locate     path,
                              Set        fieldList,
                              Descriptor typeRef,
                              Func       funcRef,
                              Map        modifiers)
  {
    Map complexType = AbstractComposite.eventIdMap();
    complexType.add(EventConstants.EVENT_TYPE, eventType);

    if (nodeEvents__.contains(eventType))
    {
      // Look for any descriptor.  If none then wild-card.
      // The descriptor is passed in as a ProxyDescriptor so no references
      // to real ones are held in listeners.
      Any d = AnyAlwaysEquals.instance();
      if (typeRef != null)
        d = typeRef;

      complexType.add(Descriptor.descriptor__, d);

      if (pathEvents__.contains(eventType))
      {
        Any p = (path != null) ? path.getNodePath() : AnyAlwaysEquals.instance();
        complexType.add(EventConstants.EVENT_PATH, p);
      }

      if (eventType.equals(EventConstants.BOT_UPDATE))
      {
        Any f = (fieldList != null && fieldList.entries() != 0) ? fieldList
                                                                : AnyAlwaysEquals.instance();
        complexType.add(EventConstants.EVENT_FIELDS, f);
      }

      if (eventType.equals(EventConstants.BOT_CREATE))
      {
        complexType.add(EventConstants.EVENT_CREATE, AnyAlwaysEquals.instance());
      }

      if (eventType.equals(EventConstants.NODE_REMOVED) ||
          eventType.equals(EventConstants.NODE_ADDED) ||
          eventType.equals(EventConstants.NODE_REPLACED))
      {
        complexType.add(EventConstants.EVENT_VECTOR, AnyAlwaysEquals.instance());
      }
    }
    else if (execEvents__.contains(eventType))
    {
      // Caller ensures we cannot have both descriptor and function. Further,
      // function cannot be wild-carded.
      if (funcRef == null)
        throw new AnyRuntimeException("Must specify the exec entity");

      complexType.add(AbstractInputFunc.exec__, funcRef.getFQName());

    }
    else
    {
      // must be a gui event - modifiers is non-null in this case
      Iter i = modifiers.createKeysIterator();
      while (i.hasNext())
      {
        Any k = i.next();
        complexType.add(k, modifiers.get(k));
      }
    }
    return complexType;
  }

  static void illegalGeometry(String axis, String geom)
  {
    throw new AnyRuntimeException("Illegal geometry specification " + axis + ":" + geom);
  }

  static void setBorder (AnyComponent c,
                         int          borderType,
                         IntI         borderStyle,
                         AnyComponent borderComponent,
                         Any          caption,
                         IntI         captionPos,
                         IntI         captionJust,
                         IntI         xMargin,
                         IntI         yMargin,
                         Any          context,
                         Transaction  t)
  {
    Border b = buildBorder(borderType,
                           borderStyle,
                           borderComponent,
                           c.getBorderee(),
                           caption,
                           captionPos,
                           captionJust,
                           xMargin,
                           yMargin,
                           context,
                           t);
    if (b != null)
      c.applyBorder(b);
  }

  static void setBorder (JComponent   c,
                         int          borderType,
                         IntI         borderStyle,
                         AnyComponent borderComponent,
                         Any          caption,
                         IntI         captionPos,
                         IntI         captionJust,
                         IntI         xMargin,
                         IntI         yMargin,
                         Any          context,
                         Transaction  t)
  {
    Border b = buildBorder(borderType,
                           borderStyle,
                           borderComponent,
                           c,
                           caption,
                           captionPos,
                           captionJust,
                           xMargin,
                           yMargin,
                           context,
                           t);
    if (b != null)
      c.setBorder(b);
  }

  static Border buildBorder (int          borderType,
                             IntI         borderStyle,
                             AnyComponent borderComponent,
                             JComponent   bordered,
                             Any          caption,
                             IntI         captionPos,
                             IntI         captionJust,
                             IntI         xMargin,
                             IntI         yMargin,
                             Any          context,
                             Transaction  t)
  {
    Any aBorderType = null;

    if(borderType == GUI_ETCHED || borderType == GUI_BEVELED || borderType == GUI_LINE || borderType == GUI_NONE)
    {
      if (borderType == GUI_ETCHED)
      {
        if (borderStyle.getValue() == GUI_RAISED)
          aBorderType = MakeComponent.etchedRaised__;
        else
          aBorderType = MakeComponent.etchedLowered__;
      }
      else if (borderType == GUI_BEVELED)
      {
        if (borderStyle.getValue() == GUI_RAISED)
          aBorderType = MakeComponent.bevelRaised__;
        else
          aBorderType = MakeComponent.bevelLowered__;
      }
      else if (borderType == GUI_LINE)
        aBorderType = MakeComponent.line__;
      else
        aBorderType = MakeComponent.none__;

    }

    if (caption != null)
    {
      try
      {
        caption = EvalExpr.evalFunc(t,
                                    context,
                                    caption,
                                    StringI.class);
      }
      catch(Exception e)
      {
        throw new RuntimeContainedException(e);
      }
    }

    Border border = MakeComponent.makeBorder(aBorderType,
                                             (caption != null) ? caption.toString() : null,
                                             borderComponent,
                                             bordered,
                                             captionPos.getValue(),
                                             captionJust.getValue(),
                                             xMargin.getValue(),
                                             yMargin.getValue());

    if (border != null && border != MakeComponent.nullBorder__)
      return border;
    else
      return null;
  }

  static void setGeometry (AnyComponent c,
                           Any          xGeometry,
                           Any          yGeometry)
  {
    c.setMinimumSize(MakeComponent.getMinimumSize(xGeometry.toString(), yGeometry.toString(), c.getPreferredSize()));
    c.setMaximumSize(MakeComponent.getMaximumSize(xGeometry.toString(), yGeometry.toString(), c.getPreferredSize()));
  }

  static void setGeometry (JComponent   j,
                           Any          xGeometry,
                           Any          yGeometry)
  {
    j.setMinimumSize(MakeComponent.getMinimumSize(xGeometry.toString(), yGeometry.toString(), j.getPreferredSize()));
    j.setMaximumSize(MakeComponent.getMaximumSize(xGeometry.toString(), yGeometry.toString(), j.getPreferredSize()));
  }

  static void setAlignment (AnyComponent c,
                            int          axis,
                            FloatI       alignment)
  {
    setAlignment((JComponent)c.getAddee(), axis, alignment);
  }

  static void setAlignment (JComponent   j,
                            int          axis,
                            FloatI       alignment)
  {
    if (axis == JPanel.X_AXIS)
      j.setAlignmentY(alignment.getValue());
    else
      j.setAlignmentX(alignment.getValue());
  }

  static void setSize (AnyComponent c,
                       IntI         xSize,
                       IntI         ySize)
  {
    if (xSize.getValue() < 0)
      return;

    c.setSize(xSize.getValue(), ySize.getValue());
  }

  static void setSize (JComponent   j,
                       IntI         xSize,
                       IntI         ySize)
  {
    if (xSize.getValue() < 0)
      return;

    j.setSize(xSize.getValue(), ySize.getValue());
  }

  static boolean doBorder(AnyComponent c)
  {
    if (c instanceof AnyInternalFrame)
      return false;

    Object o = c.getAddee();
    return (!((o instanceof JMenu) || (o instanceof JToolBar)));
  }

  static boolean doSize(AnyComponent c)
  {
    Object o = c.getAddee();
    return (!((o instanceof JMenu) || (o instanceof JToolBar)));
  }

  static boolean doGeometry(AnyComponent c)
  {
    if (c instanceof AnyInternalFrame)
      return false;

    Object o = c.getComponent();
    // JMenu/JToolBar have no geometry;
    // JPanel has geometry but not at the point this is called.
    return ((!(o instanceof JMenu)) && (!(o instanceof JPanel)) && (!(o instanceof JToolBar)));
  }

  static int tableCellAlignment(char align)
  {
    switch(align)
    {
      case 'l':
        return TableLayoutConstants.LEFT;
      case 't':
        return TableLayoutConstants.TOP;
      case 'c':
        return TableLayoutConstants.CENTER;
      case 'r':
        return TableLayoutConstants.RIGHT;
      case 'b':
        return TableLayoutConstants.BOTTOM;
      case 'e':
        return TableLayoutConstants.LEADING;
      case 'a':
        return TableLayoutConstants.TRAILING;
      case 'f':
        return TableLayoutConstants.FULL;
    }

    throw new AnyRuntimeException("Illegal justification character: " + align);
  }

  static void insertDocument(StyledDocument doc, int position, ArrayList elements)
  {
    if (elements.size() != 0)
    {
      DefaultStyledDocument.ElementSpec[] esArray =
        new DefaultStyledDocument.ElementSpec[elements.size()];

      //System.out.println(elements);

      esArray = (DefaultStyledDocument.ElementSpec[])elements.toArray(esArray);
      insertDocument(doc, position, esArray);
    }
  }

  static void insertDocument(StyledDocument doc, int position, DefaultStyledDocument.ElementSpec[] esArray)
  {
    if (esArray.length != 0)
    {
      try
      {
        doc.insert(position, esArray);
      }
      catch (BadLocationException e)
      {
        throw new RuntimeContainedException(e);
      }
    }
  }

  // Return the length of the array representing a section between the given
  // offset and the first index of ch in chars[].  If not found then return
  // the remaining section.
  // If at (or beyond) end of array then return zero
  static int charIndexOf(char chars[], char ch, int off)
  {
    int end = chars.length;
    if (off >= end)
      return 0;
    for (int i = off; i < end; i++)
      if (chars[i] == ch)
        return i - off + 1;

    return end - off;
  }

  // Add some content to the currently open paragraph.  If the content
  // contains newline characters then the current paragraph is closed and
  // a new one opened to implement the line break.
  // This function leaves any paragraphs it creates open and assumes the
  // caller will close them (after may be adding more content)
  static void breakContent(char                              chars[],
                           ArrayList                         elements,
                           MutableAttributeSet               contentStyle,
                           DefaultStyledDocument.ElementSpec esParaStart,
                           DefaultStyledDocument.ElementSpec esParaEnd)
  {
    if (AnyDocument.endPara__ == null)
      AnyDocument.endPara__ = new DefaultStyledDocument.ElementSpec(null,
                                                                    DefaultStyledDocument.ElementSpec.ContentType,
                                                                    "\n".toCharArray(), 0, 1);
    int contentLen = chars.length;
    int paraStart  = 0;
    int paraBreak  = charIndexOf(chars, '\n', 0);

    if (paraBreak == 0)
      return;

    // Add the first or only section of content.  We want to use newlines within
    // the content as paragraph breaks.
    DefaultStyledDocument.ElementSpec content =
      new DefaultStyledDocument.ElementSpec(contentStyle,
                                            DefaultStyledDocument.ElementSpec.ContentType,
                                            chars,
                                            paraStart,
                                            paraBreak);

    elements.add(content);
    paraStart = paraBreak;
    while ((paraBreak = charIndexOf(chars, '\n', paraStart)) > 0)
    {
      elements.add(AnyDocument.endPara__);
      elements.add(esParaEnd);
      elements.add(esParaStart);
      content =
        new DefaultStyledDocument.ElementSpec(contentStyle,
                                              DefaultStyledDocument.ElementSpec.ContentType,
                                              chars,
                                              paraStart,
                                              paraBreak);
      elements.add(content);
      paraStart += paraBreak;
    }
  }

  // implements:  LOOKAHEAD( "{" ";" "}" )to return true if we don't find
  // a semi-colon before we find a close brace, indicating an indirect
  // key node spec, rather than an open block
  boolean isIndirectKeyNodeSpec()
  {
    int curToken = 1;
    int nesting  = 0;
    Token token;

    while (true)
    {
      token = getToken(curToken);
      // System.out.println("" + curToken + " " + token);
      switch (token.kind)
      {
        case SCOLON:
          return false;
        case PLUS:
          return false;
        case MINUS:
          return false;
        case SLASH:
          return false;
        case REM:
          return false;
        case ASSIGN:
          return false;
        case LT:
          return false;
        case GT:
          return false;
        case BANG:
          return false;
        case TILDE:
          return false;
        case REMATCH:
          return false;
        case HOOK:
          return false;
        case COLON:
          return false;
        case EQ:
          return false;
        case LE:
          return false;
        case GE:
          return false;
        case NE:
          return false;
        case LG_OR:
          return false;
        case LG_AND:
          return false;
        case INCR:
          return false;
        case DECR:
          return false;
        case BIT_AND:
          return false;
        case BIT_OR:
          return false;
        case XOR:
          return false;
        case LSHIFT:
          return false;
        case RSIGNEDSHIFT:
          return false;
        case RUNSIGNEDSHIFT:
          return false;
        case PLUSASSIGN:
          return false;
        case MINUSASSIGN:
          return false;
        case STARASSIGN:
          return false;
        case SLASHASSIGN:
          return false;
        case ANDASSIGN:
          return false;
        case ORASSIGN:
          return false;
        case REMASSIGN:
          return false;
        case LSHIFTASSIGN:
          return false;
        case RSIGNEDSHIFTASSIGN:
          return false;
        case RUNSIGNEDSHIFTASSIGN:
          return false;
        case LANDASSIGN:
          return false;
        case LORASSIGN:
          return false;
        case LPAREN:
          return false;
        case COMMA:
          return false;
        case RPAREN:
          return false;
        case LBRACE:
          nesting++;
          curToken++;
          break;
        case RBRACE:
          if (--nesting == 0)
            return (curToken == 2) ? false : true; // just in case empty block
          curToken++;
          break;
        default:
          curToken++;
          break;
      }
    }
  }

  // implements:  LOOKAHEAD( "(" some_operator ")" ) to return true if
  // we are dealing with a maths parenthesised expression (rather than
  // an indirect node spec.
  boolean isMathParenthesis()
  {
    int curToken = 1;
    Token token;

    if (getToken(curToken++).kind != LPAREN)
      return false;

    while (true)
    {
      token = getToken(curToken);
      // System.out.println("" + curToken + " " + token);
      switch (token.kind)
      {
        case PLUS:
          return true;
        case MINUS:
          return true;
        case STAR:
          return true;
        case SLASH:
          return true;
        case REM:
          return true;
        case ASSIGN:
          return true;
        case LT:
          return true;
        case GT:
          return true;
        case BANG:
          return true;
        case TILDE:
          return true;
        case REMATCH:
          return true;
        case HOOK:
          return true;
        case COLON:
          return true;
        case EQ:
          return true;
        case LE:
          return true;
        case GE:
          return true;
        case NE:
          return true;
        case LG_OR:
          return true;
        case LG_AND:
          return true;
        case INCR:
          return true;
        case DECR:
          return true;
        case BIT_AND:
          return true;
        case BIT_OR:
          return true;
        case XOR:
          return true;
        case LSHIFT:
          return true;
        case RSIGNEDSHIFT:
          return true;
        case RUNSIGNEDSHIFT:
          return true;
        case PLUSASSIGN:
          return true;
        case MINUSASSIGN:
          return true;
        case STARASSIGN:
          return true;
        case SLASHASSIGN:
          return true;
        case ANDASSIGN:
          return true;
        case ORASSIGN:
          return true;
        case REMASSIGN:
          return true;
        case LSHIFTASSIGN:
          return true;
        case RSIGNEDSHIFTASSIGN:
          return true;
        case RUNSIGNEDSHIFTASSIGN:
          return true;
        case LANDASSIGN:
          return true;
        case LORASSIGN:
          return true;
        case LPAREN:
          return true;
        case COMMA:
          return true;
        case RPAREN:
          return false;
        default:
          curToken++;
          break;
      }
    }
  }

  // implements:  LOOKAHEAD( grid ) to return true if the given
  // view is a AnyGrid. This way we can direct the grammar to
  // process the constraints required for TableLayout
  boolean isGrid(AnyView v)
  {
    return (v instanceof AnyGrid);
  }

  // Called by the TokenManager to keep the line number in the transaction
  // up to date while parsing the input
  void setLineNumber(int line)
  {
    userTxn_.setLineNumber(lineOffset_ + line);
  }
  
  // If the jline library is available and we are not on windows then
  // try to initialise it. For windows we let the dos prompt to history
  // for us...
  static void 
  initJline()
  {
    String os = System.getProperties().getProperty("os.name");
    if (os.toLowerCase().startsWith("windows"))
      return;
      
    // See if we have jline available - if so initialise it
    try
    {
      Class.forName("jline.ConsoleReader");
    }
    catch (Exception e)
    {
      // No
      return;
    }
    
    try
    {
      // All ok - initialise jline
      String historyFileName = System.getProperty(ConsoleRunner.property, null);
  
      // setup the input stream
      ConsoleReader reader = new ConsoleReader();
      reader.setDefaultPrompt("inq> ");
  
      if (historyFileName != null)
      {
        reader.setHistory(new History (new File (System.getProperty("user.home"),
                                                 ".inq" +
                                                   "." + historyFileName + ".history")));
      }
      else
      {
        reader.setHistory(new History(new File(System.getProperty("user.home"),
                                               ".inq.history")));
      }
  
      String completors = System.getProperty(ConsoleRunner.class.getName() + ".completors", "");
      ArrayList completorList = new ArrayList();
  
      for (StringTokenizer tok = new StringTokenizer(completors, ",");
           tok.hasMoreTokens() ;)
      {
        completorList.add((Completor) Class.forName(tok.nextToken()).newInstance());
      }
    
      if (completorList.size() > 0)
      {
        reader.addCompletor(new ArgumentCompletor(completorList));
      }
  
      ConsoleReaderInputStream.setIn(reader);
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
  }
}

PARSER_END(Inq)

TOKEN_MGR_DECLS:
{

  /*****************************************************/

  private Inq    inq_;

  private String streamName;

  // Include file stacks
  private Stack filesStack;
  private Stack fileNamesStack;
  private Stack fileLexerStateStack;
  private Stack packageStack;
  private Stack importsStack;

  // The url of the script we are currently executing, so
  // we can express other things with relative paths.
  // Passed through from parser class.
  String documentURL_    = "file:///";
  Any    documentAnyURL_;

  /*****************************************************/

  private void pushInputFile(Token t)
  {
    // process any substitutions within the include path
    String s = doSubst(t.image);

    // process the url - it may be relative.
    AnyURL u  = new AnyURL(s);
    AnyURL b  = new AnyURL(documentURL_);
    URL    iu = u.getURL(b);
    String su = iu.toString();

    // Push the current input file

    if (filesStack == null)
    {
      filesStack          = new Stack();
      fileNamesStack      = new Stack();
      fileLexerStateStack = new Stack();
      packageStack        = new Stack();
      importsStack        = new Stack();
    }

    if (fileNamesStack.contains(su))
      throw new AnyRuntimeException("Nested include of " + su + " from " + documentURL_);

    filesStack.push(input_stream);
    fileNamesStack.push(documentURL_);
    fileLexerStateStack.push(new Integer(curLexState));
    packageStack.push(inq_.getPackage());
    importsStack.push(inq_.getImports());

    // store the next stream url
    inq_.setDocumentURL(su);

    // Change to the new url
    //System.out.println("Including : " + su);
    try
    {
      InputStream is = iu.openStream();

      //Change to the new File
      JavaCharStream newFile = new JavaCharStream(is, 1, 1);
      ReInit(newFile, defaultLexState);
    }
    catch(IOException e)
    {
      throw new RuntimeContainedException(e);
    }
  }

/***************************************/

  private boolean popInputFile()
  {
    if (filesStack == null || filesStack.empty())
      return false;

    //Resume pushed file
    JavaCharStream   stream   = (JavaCharStream)filesStack.pop();
    Integer          state    = (Integer)fileLexerStateStack.pop();
    String           fileName = (String)fileNamesStack.pop();
    String           ipackage = (String)packageStack.pop();
    HashMap          imports  = (HashMap)importsStack.pop();

    inq_.setDocumentURL(fileName);
    inq_.setPackage(ipackage);
    inq_.setImports(imports);

    ReInit(stream,state.intValue());

    return true;
  }

/***************************************/

  private void CommonTokenAction (Token t)
  {
    if (t.kind==EOF)
    {
      if (popInputFile())
      {
        //Throw away the EOF command
        Token newToken=getNextToken();
        t.kind=newToken.kind;
        t.beginLine=newToken.beginLine;
        t.beginColumn=newToken.beginColumn;
        t.endLine=newToken.endLine;
        t.endColumn=newToken.endColumn;
        t.image=newToken.image;
        t.next=newToken.next;
        t.specialToken=newToken.specialToken;
      }
    }

    // Tell the parser's Inq transaction what the current line number is
    //System.out.println("CommonTokenAction " + t.beginLine);
    inq_.setLineNumber(t.beginLine);
  }

  private String doSubst(String s)
  {
    String[] tokens = s.split("[{}]");

    // Expect one (no special tokens) or three (eg "something{is}embedded")
    // ... and make it use regex better later !!
    if (tokens.length != 1 && tokens.length != 3)
      throw new AnyRuntimeException("Illegal include syntax: " + s);

    if (tokens.length == 1)
      return s;

    // Substitute the value in argsMap (if there is one)
    Map argsMap = (Map)Catalog.instance().getCatalog().get(CommandArgs.commandLine__);
    ConstString k = new ConstString(tokens[1]);
    if (argsMap.contains(k))
    {
      return tokens[0] + argsMap.get(k).toString() + tokens[2];
    }
    else
    {
      // Croak instead
      throw new AnyRuntimeException("No command line argument to substitute for " +
                                     k + " in " + s);
      //return tokens[0] + tokens[2];
    }
  }

  void setDocumentURL(Inq inq, String url, Any anyURL)
  {
    // Store the parser.  See include handling above
    inq_            = inq;

    documentURL_    = url;
    documentAnyURL_ = anyURL;
  }

  // Only provided because layoutGui and layoutDoc do not have URLs (yet) so
  // cannot use the setDocumentURL method, above.
  void setParser(Inq inq)
  {
    inq_ = inq;
  }

/***************************************/

} // TOKEN_MGR_DECLS


/* WHITE SPACE */

<DEFAULT, GUI, DOC> SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* Include */

<DEFAULT> SKIP :
{
  <"#" ([" ","\t"])* "include" ([" ","\t"])* "<" > : INSIDE_INCLUDE_FILE
}

<INSIDE_INCLUDE_FILE>
SKIP :
{
  < INCLUDE: (~[" ","\t",">"])+> {pushInputFile(jjFillToken());}
}

<INSIDE_INCLUDE_FILE>
SKIP :
{
  <">" ([" ","\t"])* > :  DEFAULT
}

/* if

<DEFAULT> SKIP :
{
  <"#" ([" ","\t"])* "if" ([" ","\t"])* "<" > : INSIDE_IF_FLAG
}

<INSIDE_IF_FLAG>
SKIP :
{
  < IFFLAG: (~[" ","\t",">"])+> {pushInputFile(jjFillToken());}
}

<INSIDE_INCLUDE_FILE>
SKIP :
{
  <">" ([" ","\t"])* > :  DEFAULT
}
 */

<DEFAULT, GUI, DOC> SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <SHELL_HASH_BANG: "#!" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

<DEFAULT, GUI, DOC> TOKEN : /* Reserved Words and Symbols */
{
  < SUM:              "sum" >  // The first keyword (do not add keywords before this)
| < AVG:              "avg" >
| < WAVG:             "wavg" >
| < IF:               "if" >
| < ELSE:             "else" >
| < SWITCH:           "switch" >
| < WHEN:             "when" >
| < OTHERWISE:        "otherwise" >
| < ABORT:            "abort" >
| < ABS:              "abs" >
| < ABSURL:           "absurl" >
| < ADD:              "add" >
| < AGGREGATE:        "aggregate" >
| < BREAK:            "break" >
| < ACCEPT:           "accept" >
| < CHARAT:           "charat" >
| < CLONE:            "clone" >
| < CLOSE:            "close" >
| < COLLATE:          "collate" >
| < COMMIT:           "commit" >
| < CONTAINS:         "contains" >
| < CONTAINSALL:      "containsall" >
| < CONTAINSANY:      "containsany" >
| < CONTAINSVALUE:    "containsvalue" >
| < CONTINUE:         "continue" >
| < COUNT:            "count" >
| < CREATE:           "create" >
| < CREATEFILE:       "createfile" >
| < CREATETMPFILE:    "createtmpfile" >
| < CREATING:         "creating" >
| < CRYPT:            "crypt" >
| < DELETE:           "delete" >
| < DELETEFILE:       "deletefile" >
| < DELETEING:        "deleting" >
| < DISTINCT:         "distinct" >
| < DOCLAYOUT:        "doclayout" >
| < ENDSWITH:         "endswith" >
| < EMPTY:            "empty" >
| < ENUM:             "enum" >
| < ENUMEXT:          "enumext" >
| < EXEC:             "exec" >
| < COMPILE:          "compile" >
| < EXIT:             "exit" >
| < FILEFILTER:       "filefilter" >
| < FIREMODEL:        "firemodel" >
| < FOREACH:          "foreach" >
| < GARBAGECOLLECT:   "garbagecollect" >
| < GROUPBY:          "groupby" >
| < GETDATE:          "getdate" >
| < GETBLOB:          "getblob" >
| < GETCURRENTSTACK:  "getcurrentstack" >
| < GETLOCALHOST:     "getlocalhost" >
| < GETLOGGER:        "getlogger" >
| < LOGGERNAMES:      "loggernames" >
| < GETDESKTOPSTATE:  "getdesktop" >
| < SETDESKTOPSTATE:  "setdesktop" >
| < GETNAME:          "getname" >
| < GETNODESET:       "getnodeset" >
| < GETUNIQUEKEY:     "getuniquekey" >
| < GETPRIMARYKEY:    "getprimarykey" >
| < HIDE:             "hide" >
| < IDENTITY:         "identity" >
| < INDEXOF:          "indexof" >
| < INTERRUPT:        "interrupt" >
| < ISCREATING:       "iscreating" >
| < ISMANAGED:        "ismanaged" >
| < ISEMPTYCHANNEL:   "ischannelempty" >
| < ISENUM:           "isenum" >
| < ISDIGIT:          "isdigit" >
| < ISLETTERORDIGIT:  "isletterordigit" >
| < ISLETTER:         "isletter" >
| < ISLOWERCASE:      "islowercase" >
| < ISSPACE:          "isspace" >
| < ISMODIFYING:      "ismodifying" >
| < ISNUMERIC:        "isnumeric" >
| < ISWHITESPACE:     "iswhitespace" >
| < ISUPPERCASE:      "isuppercase" >
| < ISTYPE:           "istype" >
| < SETCOMPRESSED:    "setcompressed" >
| < ISINSTANCE:       "isinstance" >
| < ISNULL:           "isnull" >
| < KEYSOF:           "keysof" >
| < KILL:             "kill" >
| < LAYOUT:           "layout" >
| < LEFTSTRING:       "leftstring" >
| < LENGTH:           "length" >
| < LINKTO:           "linkto" >
| < LOCAL:            "local" >
| < LOCK:             "lock" >
| < LOADCLIENT:       "loadclient" >
| < LOADSERVER:       "loadserver" >
| < MAXVAL:           "maxval" >
| < MINVAL:           "minval" >
| < MKDIR:            "mkdir" >
| < MKDIRS:           "mkdirs" >
| < MAXOF:            "maxof" >
| < MIDSTRING:        "midstring" >
| < MINOF:            "minof" >
| < MAX:              "max" >
| < MIN:              "min" >
| < MERGE:            "merge" >
| < MODIFYING:        "modifying" >
| < NEW:              "new" >
| < NODESOF:          "nodesof" >
| < INDICESOF:        "indicesof" >
| < OPEN:             "open" >
| < PARSE:            "parse" >
| < PRINT:            "print" >
| < PRIVILEGE:        "privilege" >
| < RAISES:           "raises" >
| < RANDOM:           "random" >
| < READ:             "read" >
| < READSTREAM:       "readstream" >
| < REGEX:            "regex" >
| < REMOVE:           "remove" >
| < REMOVEALL:        "removeall" >
| < REMOVEITER:       "removeiter" >
| < RENAMEFILE:       "renamefile" >
| < RESYNC:           "resync" >
| < RETAINALL:        "retainall" >
| < RETURN:           "return" >
| < REVERSE:          "reverse" >
| < RIGHTSTRING:      "rightstring" >
| < SERVERSOCKET:     "serversocket" >
| < SETBLOB:          "setblob" >
| < SETENTRYLOGGING:  "setentrylogging" >
| < SETNULL:          "setnull" >
| < SETNODESET:       "setnodeset" >
| < SETUNIQUEKEY:     "setuniquekey" >
//| < SETPRIVILEGE:     "setprivilege" >
| < SETEXCEPTIONHANDLER: "setexceptionhandler" >
| < SHOW:             "show" >
| < RESIZE:           "resize" >
| < TOFRONT:          "tofront" >
| < SORT:             "sort" >
| < SPAWN:            "spawn" >
| < SPLIT:            "split" >
| < STACKTRACEF:      "stacktrace" >
| < STARTSWITH:       "startswith" >
| < STRINGINDEX:      "strindex" >
| < STYLE:            "style" >
| < SUB:              "sub" >
| < GSUB:             "gsub" >
| < CREATETIMER:      "createtimer" >
| < CANCELTIMER:      "canceltimer" >
| < STARTTIMER:       "starttimer" >
| < FIRETIMER:        "firetimer" >
| < SETEVENTMASK:     "seteventmask" >
| < SYSTEM:           "syscmd" >
| < SENDMAIL:         "sendmail" >
| < SYSOPEN:          "sysopen" >
| < SYSPRINT:         "sysprint" >
| < THROW:            "throw" >
| < TOLOWER:          "tolower" >
| < TOUPPER:          "toupper" >
| < TRIM:             "trim" >
| < TRY:              "try" >
| < TRANSACTION:      "transaction" >
| < TYPEOF:           "typeof" >
| < WAIT:             "wait" >
| < WAITPROC:         "waitproc" >
| < NOTIFY:           "notify" >
| < NOTIFYALL:        "notifyall" >
| < UNLOCK:           "unlock" >
| < WRITESTREAM:      "writestream" >
| < WRITELN:          "writeln" >
| < LOGFILTER:        "logfilter" >
| < LOGMESSAGE:       "logmessage" >
| < LOGFINEST:        "logfinest" >
| < LOGFINER:         "logfiner" >
| < LOGFINE:          "logfine" >
| < LOGCONFIG:        "logconfig" >
| < LOGINFO:          "loginfo" >
| < LOGWARNING:       "logwarning" >
| < LOGSEVERE:        "logsevere" >
| < CATCH:            "catch" >
| < FINALLY:          "finally" >
| < WHILE:            "while" >
| < DO:               "do" >
| < FOR:              "for" >
| < CALL:             "call" >
| < CALLMETHOD:       "callmethod" >
| < INSTANCE:         "instance" >
| < CLASS:            "class" >
| < XFUNC:            "xfunc" >
| < SETFOCUS:         "setfocus" >
| < DETACHED:         "detached" >
| < CHILD:            "child" >
| < START:            "start" >
| < INPUT:            "input" >
| < OUTPUT:           "output" >
| < END:              "end" >
| < SEND:             "send" >
| < GETOBJECT:        "getobject" >
| < GETPROPERTY:      "getproperty" >
| < GETPROCESS:       "getprocess" >
| < STDIN:            "stdin" >
| < STDOUT:           "stdout" >
| < STDERR:           "stderr" >
| < SQRT:             "sqrt" >
| < SIN:              "sin" >
| < COS:              "cos" >
| < TAN:              "tan" >
| < ASIN:             "asin" >
| < ACOS:             "acos" >
| < ATAN:             "atan" >
| < CEIL:             "ceil" >
| < FLOOR:            "floor" >
| < TODEGREES:        "todegrees" >
| < TORADIANS:        "toradians" >
| < EXP:              "exp" >
| < LOG:              "logn" >
| < SCALE:            "scale" >
| < ROUND:            "round" >
| < ANY:              "any" >
| < BYTE:             "byte" >
| < CHAR:             "char" >
| < SHORT:            "short" >
| < INT:              "int" >
| < LONG:             "long" >
| < BOOLEAN:          "boolean" >
| < FLOAT:            "float" >
| < FUNC:             "func" >
| < CFUNC:            "cfunc" >
| < DOUBLE:           "double" >
| < DECIMAL:          "decimal" >
| < DATE:             "date" >
| < CALENDAR:         "calendar" >
| < STRING:           "string" >
| < OBJECT:           "object" >
| < ICON:             "image" >
| < COLOUR:           ("color" | "colour") >
| < FONT:             "font" >
| < COLLATOR:         "collator" >
| < DOCUMENT:         "document" >
| < FILE:             "file" >
| < TIMER:            "timer" >
| < BLOB:             "blob" >
| < FUNCTION:         "function" >
| < SERVICE:          "service" >
| < SYNCGUI:          "syncgui" >
| < SYNCEXT:          "syncext" >
| < RESOURCE:         "resource" >
| < TYPEDEF:          "typedef" >
| < ALIAS:            "alias" >
| < NOCACHE:          "nocache" >
| < FIELDNAME:        "fieldname" >
| < FIELDS:           "fields" >
| < LABEL:            "label" >
| < WIDTH:            "width" >
| < FORMAT:           "format" >
| < CONSTRUCT:        "construct" >
| < JOIN:             "join" >
| < MUTATE:           "mutate" >
| < DESTROY:          "destroy" >
| < PKEY:             "pkey" >
| < KEY:              "key" >
| < ELIGIBLE:         "eligible" >
| < EXISTS:           "exists" >
| < FQNAME:           "fqname" >
| < AUXCFG:           "auxcfg" >
| < UNIQUE:           "unique" >
| < FOREIGN:          "foreign" >
| < NATIVE:           "native" >
| < VOLATILE:         "volatile" >
| < CACHED:           "cached" >
| < IOBIND:           "iobind" >
| < SIMPLESQLIO:      "SimpleSqlIO" >
| < CSVIO:            "CsvIO" >
| < SETNAME:          "setname" >
| < ROWNAME:          "rowname" >
| < KEYNAME:          "keyname" >
| < MUSTJOIN:         "mustjoin" >
| < TARGET:           "target" >
| < TIMEZONE:         "timezone" >
| < CURRENCY:         "currency" >
| < PACKAGE:          "package" >
| < IMPORT:           "import" >
| < EVENT:            "event" >
| < HMAP:             ("hierarchymap" | "hmap") >
| < SMAP:             ("simplemap"    | "smap") >
| < OMAP:             "omap" >
| < WMAP:             "wmap" >
| < MAP:              "map" >
| < SET:              "set" >
| < USET:             "iset" >
| < OSET:             "oset" >
| < ARRAY:            "array" >
| < BYTEARRAY:        "bytearray" >
| < NULL:             "null" >
| < EQUALS:           "equals" >
| < EQUALSORNULL:     "equalsornull" >
| < EPATH:            "path" >
| < EXPIRE:           "expire" >
| < CATALOGED:        "cataloged" >
| < LISTEN:           "listen" >
| < UNLISTEN:         "unlisten" >
| < UPDATE:           "update" >
| < REPLACE:          "replace" >
| < LOGIN:            "serverlogin" >
| < VERSION:          "version" >
| < COMPLETE:         "complete" >
| < CONSUME:          "consume" >
| < IGNOREOWN:        "ignoreown" >
| < IOCSV:            "ioCSV" >
| < IOFIXED:          "ioFixed" >
| < IOBYTE:           "ioByte" >
| < IONATIVE:         "ioNative" >
| < IOPRINT:          "ioPrint" >
| < IOPROPS:          "ioProps" >
| < IOXML:            "ioXML" >
| < IOXMLX:           "ioXMLX" >
| < IOMQ:             "ioMq" >
| < MQCRCONN:         "mqcreateconnection" >
| < MQCRSESS:         "mqcreatesession" >
| < MQCRQUEUE:        "mqcreatequeue" >
| < MQCRTOPIC:        "mqcreatetopic" >
| < MQCRPRODUCER:     "mqcreateproducer" >
| < MQCRBYTESMSG:     "mqcreatebytesmessage" >
| < MQCRSTRMMSG:      "mqcreatestreammessage" >
| < MQCRMAPMSG:       "mqcreatemapmessage" >
| < MQCRMSG:          "mqcreatemessage" >
| < MQCRANYMSG:       "mqcreateanymessage" >
| < MQCRTXTMSG:       "mqcreatetextmessage" >
| < MQCRCONSUMER:     "mqcreateconsumer" >
| < MQCRDURSUB:       "mqcreatedurablesubscriber" >
| < MQUNSUB:          "mqunsubscribe" >
| < MQCRTMPTOP:       "mqcreatetemporarytopic" >
| < MQCRTMPQUE:       "mqcreatetemporaryqueue" >
| < MQCRQUEUEBR:      "mqcreatequeuebrowser" >
| < MQSTART:          "mqstart" >
| < MQSTOP:           "mqstop" >
| < MQSEND:           "mqsend" >
| < MQRECV:           "mqreceive" >
| < MQACK:            "mqacknowledge" >
| < MQCLRMSG:         "mqclearmessage" >
| < MQRSTMSG:         "mqresetmessage" >
| < MQCLOSE:          "mqclose" >
| < MQSETMSGLISTENER: "mqsetmessagelistener" >
| < MQSETCOMMIT:      "mqsetcommit" >
| < GPROPERTY:        "gProperty" >
| < GEVENT:           "gEvent" >
| < GEVENTTYPES:      "gEventTypes" >
| < GREMOVEEVENT:     "gRemoveEvent" >
| < GPOPUP:           "gPopup" >
| < GMODIFY:          "gModify" >
| < ACTION:           "gAction" >
| < FOCUSGAINED:      "gFocusgained" >
| < FOCUSLOST:        "gFocuslost" >
| < CHANGE:           "gChange" >
| < WACTIVATED:       "gWactivated" >
| < WCLOSING:         "gWclosing" >
| < WCLOSED:          "gWclosed" >
| < WDEACTIVATED:     "gWdeactivated" >
| < WDEICONIFIED:     "gWdeiconified" >
| < WICONIFIED:       "gWiconified" >
| < WOPENED:          "gWopened" >
| < MCLICKED:         "gMclicked" >
| < MEDIASIZE:        "gMediaSize" >
| < PARAALIGN:        "gParaAlign" >
| < GUICONSTANT:      "gGuiConstant" >
| < MENTERED:         "gMentered" >
| < MEXITED:          "gMexited" >
| < MPRESSED:         "gMpressed" >
| < MRELEASED:        "gMreleased" >
| < MPOPUP:           "gMpopup" >
| < MMOVED:           "gMmoved" >
| < MDRAGGED:         "gMdragged" >
| < MENUSELECTED:     "gMenuSelected" >
| < MENUDESELECTED:   "gMenuDeselected" >
| < MENUCANCELED:     "gMenuCanceled" >
| < POPUPVISIBLE:     "gPopupVisible" >
| < POPUPINVISIBLE:   "gPopupInvisible" >
| < POPUPCANCELED:    "gPopupCanceled" >
| < KTYPED:           "gKtyped" >
| < KPRESSED:         "gKpressed" >
| < KRELEASED:        "gKreleased" >
| < FCAPPROVE:        "gFCapprove" >
| < FCCANCEL:         "gFCcancel" >
| < DIALOG:           "gDialog" >
| < DIALOGOK:         "gDialogok" >
| < DIALOGCANCEL:     "gDialogcancel" >
| < ROWEDITDONE:      "gCellEditDone" >
| < ROWEDITCANCEL:    "gCellEditCancel" >
| < CELLEDIT:         "gCellEdit" >
| < CELLEDITSTOP:     "gCellEditStop" >
| < DOCCHANGE:        "gDocchange" >
| < DOCINSERT:        "gDocinsert" >
| < DOCREMOVE:        "gDocremove" >
| < SELECTION:        "gSelection" >
| < ITEM:             "gItem" >
| < TREESELECTION:    "gTreeselection" >
| < TREEEXPAND:       "gTreeexpand" >
| < TREECOLLAPSE:     "gTreecollapse" >
| < HIDDEN:           "gHidden" >
| < MOVED:            "gMoved" >
| < RESIZED:          "gResized" >
| < SHOWN:            "gShown" >
| < ECONTEXT:         "gContext" >
| < WINDOW:           "gWindow" >
| < IWINDOW:          "gIWindow" >
| < DESKTOP:          "gDesktop" >
| < MDI:              "gMDI" >
| < BOX:              "gBox" >
| < HBOX:             "gHBox" >
| < VBOX:             "gVBox" >
| < CARD:             "gCard" >
| < BUTTON:           "gButton" >
| < ARROW:            "gArrow" >
| < CHECKB:           "gCheck" >
| < TOGGLE:           "gToggle" >
| < TOGGLELIST:       "gToggleList" >
| < RADIO:            "gRadio" >
| < TOOLBAR:          "gToolBar" >
| < MENUBAR:          "gMenuBar" >
| < POPUPMENU:        "gPopupMenu" >
| < MENU:             "gMenu" >
| < MENUBUTTON:       "gMenuButton" >
| < MENUCHECK:        "gMenuCheck" >
| < MENURADIO:        "gMenuRadio" >
| < DATECHOOSER:      "gDateChooser" >
| < FILECHOOSER:      "gFileChooser" >
| < GLABEL:           "gLabel" >
| < TABLE:            "gTable" >
| < TREE:             "gTree" >
| < LIST:             "gList" >
| < TEXTFIELD:        "gTextField" >
| < PASSWDFIELD:      "gPasswdField" >
| < PROGRESSBAR:      "gProgressBar" >
| < SLIDER:           "gSlider" >
| < TEXTAREA:         "gTextArea" >
| < TEXTPANE:         "gTextPane" >
| < TAB:              "gTab" >
| < SPINNER:          "gSpinner" >
| < GSPLIT:           "gSplit" >
| < COMBOBOX:         "gComboBox" >
| < BUTTONGROUP:      "gButtonGroup" >
| < DOCK:             "gDock" >
| < DOCKBUTTON:       "gDockButton" >
| < DOCKMENU:         "gDockMenu" >
| < DOCKRADIO:        "gDockRadio" >
| < DOCKCHECK:        "gDockCheck" >
| < DOCKDROPDOWN:     "gDockDropDown" >
| < DOCKPOPUP:        "gDockPopup" >
| < DOCKBUTTONGROUP:  "gDockButtonGroup" >
//| < DOCKACTIONS:      "gDockActions" >
| < MBUTTON:          "mbutton" >
| < KEYCODE:          "keycode" >
| < KEYSTROKE:        "keystroke" >
| < KEYMOD:           "keymod" >
| < ALWAYS:           "always" >
| < RENDER:           "render" >
| < RENDERF:          "renderf" >
| < RENDERINFO:       "renderinfo" >
| < TYPE:             "type" >
| < DATA:             "data" >
| < EDITABLE:         "editable" >
| < DESCENDING:       "descending" >
| < IGNORECASE:       "ignorecase" >
| < DATEPART:         "datepart" >
| < DATEPARTSET:      "dateset" >
| < DATEPARTMAX:      "datepartmax" >
| < DATEDIFF:         "datediff" >
| < DATEADD:          "dateadd" >
| < DATETRUNC:        "datetrunc" >
| < DATECONSTANT:     "Calendar" >
| < DAYOFWEEK:        "DAY_OF_WEEK" >
| < WEEKOFYEAR:       "WEEK_OF_YEAR" >
| < DAYOFMONTH:       "DAY_OF_MONTH" >
| < DAYOFWEEKINMONTH: "DAY_OF_WEEK_IN_MONTH" >
| < DAYOFYEAR:        "DAY_OF_YEAR" >
| < DAY:              "DAY" >
| < HOUR:             "HOUR" >
| < HOUROFDAY:        "HOUR_OF_DAY" >
| < MILLISECOND:      "MILLISECOND" >
| < MINUTE:           "MINUTE" >
| < MONTH:            "MONTH" >
| < SECOND:           "SECOND" >
| < WEEKOFMONTH:      "WEEK_OF_MONTH" >
| < YEAR:             "YEAR" >
| < TAB_TOP:          "TAB_TOP" >
| < TAB_BOTTOM:       "TAB_BOTTOM" >
| < TAB_LEFT:         "TAB_LEFT" >
| < TAB_RIGHT:        "TAB_RIGHT" >
| < GUI_BOTTOM:       "GUI_BOTTOM" >
| < GUI_CENTER:       "GUI_CENTER" >
| < GUI_EAST:         "GUI_EAST" >
| < GUI_HORIZONTAL:   "GUI_HORIZONTAL" >
| < GUI_LEADING:      "GUI_LEADING" >
| < GUI_LEFT:         "GUI_LEFT" >
| < GUI_NEXT:         "GUI_NEXT" >
| < GUI_NORTH:        "GUI_NORTH" >
| < GUI_NORTH_EAST:   "GUI_NORTH_EAST" >
| < GUI_NORTH_WEST:   "GUI_NORTH_WEST" >
| < GUI_PREVIOUS:     "GUI_PREVIOUS" >
| < GUI_RIGHT:        "GUI_RIGHT" >
| < GUI_SOUTH:        "GUI_SOUTH" >
| < GUI_SOUTH_EAST:   "GUI_SOUTH_EAST" >
| < GUI_SOUTH_WEST:   "GUI_SOUTH_WEST" >
| < GUI_TOP:          "GUI_TOP" >
| < GUI_TRAILING:     "GUI_TRAILING" >
| < GUI_VERTICAL:     "GUI_VERTICAL" >
| < GUI_WEST:         "GUI_WEST" > 
| < SELECTED:         "SELECTED" >
| < DESELECTED:       "DESELECTED" >
| < SINGLE_SELECTION:            "SINGLE_SELECTION" >
| < SINGLE_INTERVAL_SELECTION:   "SINGLE_INTERVAL_SELECTION" >
| < MULTIPLE_INTERVAL_SELECTION: "MULTIPLE_INTERVAL_SELECTION" >
| < ROW_SELECTION:               "ROW_SELECTION" >
| < COLUMN_SELECTION:            "COLUMN_SELECTION" >
| < CELL_SELECTION:              "CELL_SELECTION" >
| < CONTIGUOUS_TREE_SELECTION:    "CONTIGUOUS_TREE_SELECTION" >
| < DISCONTIGUOUS_TREE_SELECTION: "DISCONTIGUOUS_TREE_SELECTION" >
| < SINGLE_TREE_SELECTION:        "SINGLE_TREE_SELECTION" >
| < X_AXIS:           "X_AXIS" >
| < Y_AXIS:           "Y_AXIS" >
| < HIDE_ON_CLOSE:        "HIDE_ON_CLOSE" >
| < DO_NOTHING_ON_CLOSE:  "DO_NOTHING_ON_CLOSE" >
| < DISPOSE_ON_CLOSE:     "DISPOSE_ON_CLOSE" >
| < EXIT_ON_CLOSE:        "EXIT_ON_CLOSE" >
| < OPEN_READ:            "OPEN_READ" >
| < OPEN_WRITE:           "OPEN_WRITE" >
| < OPEN_APPEND:          "OPEN_APPEND" >
| < SHIFT_MASK:           "SHIFT_MASK" >
| < CTRL_MASK:            "CTRL_MASK" >
| < META_MASK:            "META_MASK" >
| < ALT_MASK:             "ALT_MASK" >
| < FIXED_DELAY:          "FIXED_DELAY" >
| < FIXED_RATE:           "FIXED_RATE" >
| < P_DETACHED:           "PROCESS_DETACHED" >
| < P_CHILD:              "PROCESS_CHILD" >
| < PORTRAIT:             "PORTRAIT" >
| < LANDSCAPE:            "LANDSCAPE" >
| < REVERSE_PORTRAIT:     "REVERSE_PORTRAIT" >
| < REVERSE_LANDSCAPE:    "REVERSE_LANDSCAPE" >
| < ORIENT_VERTICAL:      "ORIENT_VERTICAL" >
| < ORIENT_HORIZONTAL:    "ORIENT_HORIZONTAL" >
| < FLAT_TABLE:           "FLAT_TABLE" >
| < MODAL_NONE:           "MODAL_NONE" >
| < MODAL_PARENT:         "MODAL_PARENT" >
| < MODAL_ALL:            "MODAL_ALL" >
| < TREE_TABLE:           "TREE_TABLE" >
| < MATH_PI:              "MATH_PI" >
| < MATH_E:               "MATH_E" >
| < CREATE_ERROR:         "CREATE_ERROR" >
| < CREATE_REPLACE:       "CREATE_REPLACE" >
| < CREATE_LEAVE:         "CREATE_LEAVE" >
| < STRENGTH_PRIMARY:     "STRENGTH_PRIMARY" >
| < STRENGH_SECONDARY:    "STRENGTH_SECONDARY" >
| < STRENGH_TERTIARY:     "STRENGTH_TERTIARY" >
| < STRENGH_IDENTICAL:    "STRENGTH_IDENTICAL" >
| < NO_DECOMPOSITION:        "NO_DECOMPOSITION" >
| < CANONICAL_DECOMPOSITION: "CANONICAL_DECOMPOSITION" >
| < FULL_DECOMPOSITION:      "FULL_DECOMPOSITION" >
| < NULL_HIGH:               "NULL_HIGH" >
| < NULL_LOW:                "NULL_LOW" >
| < GRID_FILL:               "GRID_FILL" >
| < GRID_MIN:                "GRID_MIN" >
| < GRID_PREF:               "GRID_PREF" >
| < LOG_ALL:                 "LOG_ALL" >
| < LOG_CONFIG:              "LOG_CONFIG" >
| < LOG_FINE:                "LOG_FINE" >
| < LOG_FINER:               "LOG_FINER" >
| < LOG_FINEST:              "LOG_FINEST" >
| < LOG_INFO:                "LOG_INFO" >
| < LOG_OFF:                 "LOG_OFF" >
| < LOG_SEVERE:              "LOG_SEVERE" >
| < LOG_WARNING:             "LOG_WARNING" >
| < AUTO_ACKNOWLEDGE:        "AUTO_ACKNOWLEDGE" >
| < CLIENT_ACKNOWLEDGE:      "CLIENT_ACKNOWLEDGE" >
| < DUPS_OK_ACKNOWLEDGE:     "DUPS_OK_ACKNOWLEDGE" >
| < NON_PERSISTENT:          "NON_PERSISTENT" >
| < PERSISTENT:              "PERSISTENT" >
| < MONDAY:                  "MONDAY" >
| < TUESDAY:                 "TUESDAY" >
| < WEDNESDAY:               "WEDNESDAY" >
| < THURSDAY:                "THURSDAY" >
| < FRIDAY:                  "FRIDAY" >
| < SATURDAY:                "SATURDAY" >
| < SUNDAY:                  "SUNDAY" >
| < JANUARY:                 "JANUARY" >
| < FEBRUARY:                "FEBRUARY" >
| < MARCH:                   "MARCH" >
| < APRIL:                   "APRIL" >
| < MAY:                     "MAY" >
| < JUNE:                    "JUNE" >
| < JULY:                    "JULY" >
| < AUGUST:                  "AUGUST" >
| < SEPTEMBER:               "SEPTEMBER" >
| < OCTOBER:                 "OCTOBER" >
| < NOVEMBER:                "NOVEMBER" >
| < DECEMBER:                "DECEMBER" >  // The last keyword (do not add keywords after this)
}

<GUI> TOKEN:
{
//  <GUI_IDENTIFIER: <IDENTIFIER> > |
  <GUI_GLUE:       "<>"      >
//| <GUI_SPACE:      "~"       >
| <GUI_NOTHING:    "#"       >
}


<DEFAULT, GUI, DOC> TOKEN : /* Path elements */
{
  < LBRACE:      "{" >
| < RBRACE:      "}" >
| < LBRACKET:    "[" >
| < RBRACKET:    "]" >
| < LPAREN:      "(" >
| < RPAREN:      ")" >
}

<DEFAULT, GUI> TOKEN : /* class literals */
{
  < BOOLCLASS:     "boolean.class" >
| < BYTECLASS:     "byte.class" >
| < CHARCLASS:     "char.class" >
| < DATECLASS:     "date.class" >
| < DOUBLECLASS:   "double.class" >
| < DECIMALCLASS:  "decimal.class" >
| < FLOATCLASS:    "float.class" >
| < INTCLASS:      "int.class" >
| < LONGCLASS:     "long.class" >
| < SHORTCLASS:    "short.class" >
| < STRINGCLASS:   "string.class" >
}

// Define layout syntax tokens, which occupy a separate lexical state
// to the main Inq language parser.

<DEFAULT, GUI> TOKEN : /* go to the Gui state */
{
  "GUI:" : GUI
}

<DEFAULT, DOC> TOKEN : /* go to the Doc state */
{
  "DOC:" : DOC
}

<DOC> TOKEN:
{
  <DOC_PARAGRAPH: "Para"    >
| <DOC_TABLEROWS: "TableRows" >
| <DOC_TABLECOLUMN: "TableColumn" >
| <DOC_CELL:      "Cell" >
| <DOC_STYLE:     "Style"   >
| <PAGE_BREAK:    "Break"   >
}

<DOC, GUI> TOKEN:
{
  <GUI_TABLE:          "Table"   >
| <GUI_ROW:            "Row" >
| <GUI_FLOW:           "Flow" >
| <GUI_ROWS:           "Rows"    >
| <GUI_COLUMNS:        "Columns" >
}

<GUI> TOKEN:
{
  <GUI_COLUMN:         "Column" >
| <GUI_CELL:           "Cell" >
| <GUI_HSPAN:          "HSpan" >
| <GUI_VSPAN:          "VSpan" >
| <GUI_GAP:            "Gap" >
| <GUI_ETCHED:         "Etched" >
| <GUI_BEVELED:        "Beveled" >
| <GUI_NONE:           "None" >
| <GUI_LINE:           "Line" >
| <GUI_RAISED:         "Raised" >
| <GUI_LOWERED:        "Lowered" >
| <GUI_CAPTION:        "Caption" >
| <GUI_COMPONENT:      "Component" >
| <GUI_MARGIN:         "Margin" >
| <GUI_GEOMETRY:       "Geometry" >
| <GUI_ALIGN:          "Align" >
| <GUI_NOFOCUS:        "Nofocus" >
| <GUI_SIZE:           "Size" >
| <GUI_SEPARATOR:      "Separator" >
| <GUI_LABEL:          "Label" >
| <GUI_SCROLL:         "Scroll" >
| <GUI_SPLIT:          "Split" >
| <GUI_SPLITX:         "SplitX" >
| <GUI_SPLITY:         "SplitY" >
| <GUI_CARD:           "Card" >
}

<DEFAULT, GUI, DOC> TOKEN : /* Statement separator */
{
  < SCOLON: ";" >
}

<DEFAULT, GUI, DOC> TOKEN : /* Arg separator */
{
  < COMMA: "," >
}

TOKEN : /* Resource types */
{
  < SQLSERVER : "sqlserver" >
}

/* OPERATORS */

<DEFAULT, GUI, DOC> TOKEN :
{
  < ASSIGN: "=" >
| < ASSIGNFIELDS: ":=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < LG_OR: "||" >
| < LG_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < POW: "^^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LANDASSIGN: "&&=" >
| < LORASSIGN: "||=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}

// Hmmm, this is separated from the above list because it is also
// defined in the GUI state to mean fixed space. In fact, this means that
// we cannot use a ~~ in expressions embedded within a layout string!!
// We would have to define another symbol and use that when inside a layout
TOKEN:
{
  < REMATCH: "~~" >
}

<DEFAULT, GUI, DOC> TOKEN:
{
  < COLON: ":" >
}

<DEFAULT, GUI, DOC> TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ("-")? ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
       ("-")? ( (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] )
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"])
        | ("\\"
            ( ["l","p","e","n","t","i","b","r","f","\\","'","\"", "\r", "\n"]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            //| "u" ["0"-"9", "a"-"f", "A"-"F"] ["0"-"9", "a"-"f", "A"-"F"] ["0"-"9", "a"-"f", "A"-"F"] ["0"-"9", "a"-"f", "A"-"F"]
              // ^^ done by the stream reader!!
            )
          )
      )*
      "\""
  >
|
  < BOOLEAN_LITERAL: "true" | "false" >
}

<DEFAULT, GUI, DOC> TOKEN : /* IDENTIFIER */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

<DEFAULT, GUI, DOC> TOKEN : /* NAME */
{
  < NAME: <IDENTIFIER> ( "." <IDENTIFIER> )+ >
}

<DEFAULT, GUI, DOC> TOKEN : /* NODE REF */
{
  < NODE_REF: <INODE_REF>
  >
|
  < #INODE_REF: <PREFIX> <SEPARATOR> (<BASIC_NREF> | <IDENTIFIER> )+
              | <PREFIX> ( <SEPARATOR> )?
              | <BASIC_NREF>
  >
|
  < #BASIC_NREF: ( ( <SEPARATOR> )? ( ( <IDENTIFIER>
                                      | <PATH_SPECIAL>
                                      | "%"
                                      //| ( <SEPARATOR> <LPAREN> ( <PREFIX> <SEPARATOR> )? ( ( <IDENTIFIER>
                                      //                                         // code too large !! | <PATH_SPECIAL>
                                      //                                         )
                                      //                                         ( <SEPARATOR> )?
                                      //                                       )+ <RPAREN> )
                                      ) ( <SEPARATOR> )?
                                    )+
                   ("#")?  // wild-card trailer
                 )
                 | "."
  >
|
  < #PREFIX:
        <THIS>
      | <STACK>
      | <LOOP>
      | <CONTEXT>
//      | <PARENT>
      | <ROOT>
      | <CATALOG>
      | <UIDEFAULTS>
      | <PROCESS>
      | <PATH>
//      | <LNULL>
//      | <PARAM>
      | <PROPERTIES>
  >
| < #STACK:       "$stack" >
| < #LOOP:        "$loop" >
| < #CONTEXT:     "$context" >
| < #THIS:        "$this" >
//| < #PARENT:      "$parent" >
| < #ROOT:        "$root" >
| < #CATALOG:     "$catalog" >
| < #UIDEFAULTS:  "$uidefaults" >
| < #PROCESS:     "$process" >
| < #PATH:        "$path" >
//| < #LNULL:       "$null" >
//| < #PARAM:       "$param" >
| < #PROPERTIES:  "$properties" >

|
  < #SEPARATOR: ( "." | "*" | "**" ) >
|
  < #PATH_SPECIAL:
       <CHANNEL>
     | <EXCEPTION>
     | <EXNAME>
     | <EXMSG>
     | <EXINFO>
     | <EXENVIRO>
     | <STACKTRACE>
     | <CAPPED>
     | <JAVASTACK>
     | <EXCOMMIT>
     | <USER>
     | <ASYNCGUI>
     | <WHO>
     | <TXT>
     | <ICO>
     | <ICOLEAF>
     | <ICOOPEN>
     | <ICOCLOSED>
     | <ICOUNT>
     | <AMAX>
     | <BG>
     | <FG>
     | <BOLD>
     | <FONTFAMILY>
     | <FONTSIZE>
     | <ATFORMAT>
     | <ITALIC>
     | <STRIKETHROUGH>
     | <UNDERLINE>
     | <FIRSTINDENT>
     | <LEFTINDENT>
     | <RIGHTINDENT>
     | <ALIGNMENT>
     | <LINESPACING>
     | <SPACEABOVE>
     | <SPACEBELOW>
     | <SSTYLE>
     | <SUBSCRIPT>
     | <SUPERSCRIPT>
     | <TABSTOPS>
     | <TOOLTIP>
     | <TABALIGN>
     | <TABLEAD>
     | <CELLPADDING>
     | <CELLALIGN>
     | <CELLFILL>
     | <CELLWIDTH>
     | <BORDERWIDTH>
     | <ROWSPAN>
     | <COLSPAN>
     | <URLREF>
     | <URLACTION>
     | <NEVENT>
     | <EVENTDATA>
     | <EVENTID>
     | <ACOMPONENT>
     | <ACONTEXT>
     | <ATNAME>
     | <FIRST>
     | <LAST>
     | <OLD>
     | <SIZE>
     | <DOMAIN>
     | <COPIES>
     | <ORIENTATION>
     | <NMEDIASIZE>
     | <PRINTABLEAREA>
  >
| < #CHANNEL:       "@channel" >
| < #EXCEPTION:     "@exception" >
| < #EXNAME:        "@exname" >
| < #STACKTRACE:    "@stackTrace" >
| < #CAPPED:        "@capped" >
| < #JAVASTACK:     "@javaStack" >
| < #EXCOMMIT  :    "@excommit" >
| < #EXMSG:         "@exmsg" >
| < #EXINFO:        "@exinfo" >
| < #EXENVIRO:      "@exenvironment" >
| < #USER:          "@user" >
| < #PASSWD:        "@passwd" >
| < #PKG:           "@package" >
| < #URL:           "@url" >
| < #SERVER:        "@server" >
| < #ASYNCGUI:      "@syncgui" >
| < #WHO:           "@who" >
| < #TXT:           "@txt" >
| < #ICO:           "@ico" >
| < #ICOLEAF:       "@icoLeaf" >
| < #ICOOPEN:       "@icoOpen" >
| < #ICOCLOSED:     "@icoClosed" >
| < #ICOUNT:        "@count" >
| < #AMAX:          "@max" >
| < #BG:            "@bg" >
| < #FG:            "@fg" >
| < #BOLD:          "@bold" >
| < #FONTFAMILY:    "@fontFamily" >
| < #FONTSIZE:      "@fontSize" >
| < #ATFORMAT:      "@format" >
| < #ITALIC:        "@italic" >
| < #STRIKETHROUGH: "@strikeThrough" >
| < #UNDERLINE:     "@underline" >
| < #FIRSTINDENT:   "@firstIndent" >
| < #LEFTINDENT:    "@leftIndent" >
| < #RIGHTINDENT:   "@rightIndent" >
| < #ALIGNMENT:     "@alignment" >
| < #LINESPACING:   "@lineSpacing" >
| < #SPACEABOVE:    "@spaceAbove" >
| < #SPACEBELOW:    "@spaceBelow" >
| < #SSTYLE:        "@style" >
| < #SUBSCRIPT:     "@subscript" >
| < #SUPERSCRIPT:   "@superscript" >
| < #TABSTOPS:      "@tabStops" >
| < #TOOLTIP:       "@toolTip" >
| < #TABPOS:        "@tabPos" >
| < #TABALIGN:      "@tabAlign" >
| < #TABLEAD:       "@tabLead" >
| < #CELLPADDING:   "@cellPadding" >
| < #CELLALIGN:     "@cellAlign" >
| < #CELLFILL:      "@cellFill" >
| < #CELLWIDTH:     "@cellWidth" >
| < #BORDERWIDTH:   "@borderWidth" >
| < #ROWSPAN:       "@rowSpan" >
| < #COLSPAN:       "@columnSpan" >
| < #URLREF:        "@urlRef" >
| < #URLACTION:     "@urlAction" >
| < #NEVENT:        "@event" >
| < #EVENTDATA:     "@eventData" >
| < #EVENTID:       "@eventId" >
| < #ACOMPONENT:    "@component" >
| < #ACONTEXT:      "@context" >
| < #DOMAIN:        "@domain" >
| < #ATNAME:        "@name" >
| < #FIRST:         "@first" >
| < #LAST:          "@last" >
| < #OLD:           "@old" >
| < #SIZE:          "@size" >
| < #COPIES:        "@copies" >
| < #ORIENTATION:   "@orientation" >
| < #NMEDIASIZE:    "@mediaSize" >
| < #PRINTABLEAREA: "@mediaPrintableArea" >
}

Any inq() :
{ Any s; }
{
  // This production looks a bit wierd but it means that we can, in fact
  // change the package as we go along.  This is just for #include
  // processing.  At least package statement can only occur outside
  // function declarations etc.  Consider enforcing only one per file
  // using our own state variables.
  [ ( "package" Name() { _package = token.image; } ";" )+ ]
  Imports()
  s = Statement()
  {
    return s;
  }
  | <EOF>
  {
    return eof__;
  }
}

void Imports() :
{}
{
  ( Import() )*
}

void Import() :
{ String pkg; String as; }
{
  "import"
  Name() { pkg = token.image; }
  <IDENTIFIER>
  {
    if (!token.image.equals("as"))
      throw new AnyRuntimeException("Found '" + token.image + "' expected 'as'");
  }
  <IDENTIFIER> { as = token.image; }
  ";"
  {
    if (imports_ == null)
      imports_ = new HashMap();

    imports_.put(as, pkg);
  }
}

Any Statement() :
{ Any s; }
{
  (LOOKAHEAD( { getToken(1).kind == LBRACE && !isIndirectKeyNodeSpec() } ) s = Block()
  | LOOKAHEAD(<IF>) s = If()
  | LOOKAHEAD(<SWITCH>) s = Switch()
  | LOOKAHEAD(<TRY> | <TRANSACTION>) s = Try()
  | LOOKAHEAD(<FOREACH>) s = Foreach()
  | s = While()
  | s = For()
  | s = Do() ";"
  | LOOKAHEAD("typedef" (<IDENTIFIER> | MakeAny())) s = TypeDeclaration()  // lookahead because of typedef()
  | s = FunctionDeclaration()
  | s = ResourceDeclaration() ";"
  | s = Expression() ";"
  | ";" { return nonExec__; } )
  {

    if (s instanceof Func)
    {
      Func f = (Func)s;
      if (f.getLineNumber() < 0)
      {
        f.setLineNumber(token.beginLine);
        f.setColumn(token.beginColumn);
      }
    }

    return s;
  }
}

// The expression syntax and precedence.  Method names are taken from
// http://java.sun.com/docs/books/tutorial/java/nutsandbolts/expressions.html

Any Expression() :
{ Any a; }
{
  ( a = Assignment()
  | a = Declaration()
  )
  {
    // Just in case
    if (a instanceof Func)
    {
      Func f = (Func)a;
      if (f.getLineNumber() < 0)
      {
        f.setLineNumber(token.beginLine);
        f.setColumn(token.beginColumn);
      }
    }
    return a;
  }
}

Any Declaration() :
{ Any a; }
{
  ( a = TypedDeclaration()
  | a = UnTypedDeclaration()
  | a = GuiDeclaration()
  | a = IODeclaration()
  )
  {
    return a;
  }
}

// Root of the operator tree.
Any Assignment() :
{
  Any a;
  Any op2 = null;
  OperatorVisitor assign = null;
  OperatorVisitor compound = null;
}
{
  a = Conditional() [ LOOKAHEAD(2) ( "="   { assign = new Assign(); }
                                   | ":="  { assign = new AssignByFields(); }
                                   | "+="  { assign = new Assign(); compound = new Add(); }
                                   | "-="  { assign = new Assign(); compound = new Subtract(); }
                                   | "*="  { assign = new Assign(); compound = new Multiply(); }
                                   | "/="  { assign = new Assign(); compound = new Divide(); }
                                   | "%="  { assign = new Assign(); compound = new Modulo(); }
                                   | "||=" { assign = new Assign(); compound = new LogicalOr(); }
                                   | "&&=" { assign = new Assign(); compound = new LogicalAnd(); }
                                   )
                      op2 = Expression() ]
  {
    if (op2 != null)
    {
      if (!(a instanceof Locate))
        throw new AnyRuntimeException("Only a node reference can be a lvalue" +
                                      " at line " + token.beginLine +
                                      " column " + token.beginColumn);

      if (compound == null)
        a = new EvalExpr(a, op2, assign);
      else
        a = new EvalExpr(a, new EvalExpr(a, op2, compound), assign);
    }

    return a;
  }
}

Any Conditional() :
{ Any a; Any trueExpr = null; Any falseExpr = null; boolean matched = false; }
{
  a = LogicalOr()
  [ "?" trueExpr = Expression() { matched = true; } ":" falseExpr = Expression() ]
  {
    if (matched)
    {
      Ternary t;
      a = t = new Ternary(trueExpr, falseExpr, a);
      if (a instanceof Func)
        t.setLineNumber(((Func)a).getLineNumber());
      else if (trueExpr instanceof Func)
        t.setLineNumber(((Func)trueExpr).getLineNumber());
      else if (falseExpr instanceof Func)
        t.setLineNumber(((Func)falseExpr).getLineNumber());
    }

    return a;
  }
}

Any LogicalOr() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; }
{
  a = LogicalAnd()
  (<LG_OR> op2 = LogicalAnd()
  {
    oper = new LogicalOr();
    a = new EvalExpr (a, op2, oper);
  }
  )*
  {
    return a;
  }
}

Any LogicalAnd() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; }
{
  a = BitwiseOr()
  (<LG_AND> op2 = BitwiseOr()
  {
    oper = new LogicalAnd();
    a = new EvalExpr (a, op2, oper);
  }
  )*
  {
    return a;
  }
}

Any BitwiseOr() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; }
{
  a = Equality()
  (<BIT_OR> op2 = Equality()
  {
    oper = new BitwiseOr();
    a = new EvalExpr (a, op2, oper);
  }
  )*
  {
    return a;
  }
}

Any Equality() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; Token t = null; }
{
  a = Relational()
  ( (t = <EQ> | t = <NE>) op2 = Relational()
  {
    if (t != null)
    {
      if (t.kind == EQ)
        oper = new Equals();
      else
        oper = new NotEquals();

      a = new EvalExpr(a, op2, oper);
    }
  }
  )*
  {
    return a;
  }
}

Any Relational() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; Token t = null; }
{
  a = Additive()
  ((t = <GT> | t = <LT> | t = <GE> | t = <LE> | t = <REMATCH> ) op2 = Additive()
  {
    if (t != null)
    {
      switch (t.kind)
      {
        case GT:
          oper = new GreaterThan();
          break;
        case LT:
          oper = new LessThan();
          break;
        case GE:
          oper = new GreaterThanOrEqualTo();
          break;
        case LE:
          oper = new LessThanOrEquals();
          break;
        case REMATCH:
          oper = new Match();
          break;
      }

      a = new EvalExpr (a, op2, oper);
    }
  }
  )*
  {
    return a;
  }
}

Any Additive() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; Token t = null; }
{
  a = Multiplicative()
  ((t = <PLUS> | t = <MINUS>) op2 = Multiplicative()
  {
    if (t != null)
    {
      if (t.kind == PLUS)
        oper = new Add();
      else
        oper = new Subtract();

      a = new EvalExpr (a, op2, oper);
    }
  }
  )*
  {
    return a;
  }
}

Any Multiplicative() :
{ Any a; Any op2 = null; OperatorVisitor oper = null; Token t = null; }
{
  a = Power()
  ((t = <STAR> | t = <SLASH> | t = <REM>) op2 = Power()
  {
    if (t != null)
    {
      if (t.kind == STAR)
        oper = new Multiply();
      else if (t.kind == SLASH)
        oper = new Divide();
      else
        oper = new Modulo();

      a = new EvalExpr (a, op2, oper);
    }
  }
  )*
  {
    return a;
  }
}

Any Power() :
{ Any a; Any op2 = null; }
{
  a = Unary()
  (
  "^^"
  op2 = Unary()
  {
    a = new EvalExpr (a, op2, new Pow());
  }
  )*
  {
    return a;
  }
}

Any Unary() :
{
  Any a;
  int line = token.beginLine;
}
{
    <MINUS> a = Operand() { a = new EvalExpr(a, null, new Negate()); return a; }
  | <BANG>  a = Operand() { a = new Not(a); return a; }
  | <INCR>  a = NodeRef() { a = new EvalExpr(a, null, new PreIncrement()); return a; }
  | <DECR>  a = NodeRef() { a = new EvalExpr(a, null, new PreDecrement()); return a; }
  | a = Operand() { return a; }
}

Any Operand() :
{ Any a; }
{
  ( a = Sum()
  | a = Avg()
  | a = If()
  | a = Switch()
  | a = Abort()
  | a = Abs()
  | a = Add()
  | a = Aggregate()
  | a = Break()
  | a = CharAt()
  | a = CloneMe()
  | a = Close()
  | a = Commit()
  | a = Contains()
  | a = ContainsAll()
  | a = ContainsAny()
  | a = ContainsValue()
  | a = Continue()
  | a = Count()
  | a = Create()
  | a = CreateTimer()
  | a = CancelTimer()
  | a = StartTimer()
  | a = FireTimer()
  | a = CreateFile()
  | a = CreateTempFile()
  | a = Crypt()
  | a = DateAdd()
  | a = DateDiff()
  | a = DateTrunc()
  | a = DatePart()
  | a = DatePartSet()
  | a = DatePartMax()
  | a = Delete()
  | a = DeleteFile()
  | a = Distinct()
  | a = Empty()
  | a = EndsWith()
  | a = Enum()
  | a = IsEnum()
  | a = EnumExternal()
  | a = FieldName()
  | a = Exec()
  | a = Compile()
  | a = Exit()
  | a = Expire()
  | a = FQName()
  | a = Foreach()
  | a = GetLogger()
  | a = GroupBy()
//  | a = GetAux()
  | a = Getdate()
  | a = GetLocalHost()
  | a = GetName()
  | a = GetNodeSet()
  | a = GetType()
  | a = GetUniqueKey()
  | a = Hide()
  | a = Identity()
  | a = IndexOf()
  | a = Interrupt()
  | a = IsCreating()
  | a = IsManaged()
  | a = Creating()
  | a = Deleting()
  | a = Modifying()
  | a = IsModifying()
  | a = IsType()
  | a = KeysOf()
  | a = Kill()
  | a = KeycodeAsAny()
  | a = KeystrokeAsAny()
  | a = LoggerNames()
  | a = LogMessage()
  | a = LogFinest()
  | a = LogFiner()
  | a = LogFine()
  | a = LogConfig()
  | a = LogInfo()
  | a = LogWarning()
  | a = LogSevere()
  | a = MQCreateConnection()
  | a = MQCreateSession()
  | a = MQCreateQueue()
  | a = MQCreateTopic()
  | a = MQCreateProducer()
  | a = MQCreateBytesMessage()
  | a = MQCreateStreamMessage()
  | a = MQCreateMapMessage()
  | a = MQCreateMessage()
  | a = MQCreateAnyMessage()
  | a = MQCreateTextMessage()
  | a = MQCreateConsumer()
  | a = MQCreateDurableSubscriber()
  | a = MQUnsubscribe()
  | a = MQCreateTemporaryQueue()
  | a = MQCreateTemporaryTopic()
  | a = MQCreateQueueBrowser()
  | a = MQStart()
  | a = MQStop()
  | a = MQSend()
  | a = MQReceive()
  | a = MQAcknowledge()
  | a = MQClearMsg()
  | a = MQReset()
  | a = MQClose()
  | a = MQSetMessageListener()
  | a = MQSetCommit()
  | a = Layout()
  | a = DoDocLayout()
  | a = Length()
  | a = LinkTo()
  | a = Listen()
  | a = LoadClient()
  | a = LoadServer()
  | a = Lock()
  | a = Login()
  | a = Max()
  | a = MaxOf()
  | a = MaxVal()
  | a = MediaSize()
  | a = Min()
  | a = MinOf()
  | a = MinVal()
  | a = Merge()
  | a = MkDirs()
  | a = New()
  | a = IsInstance()
  | a = EqualsOrNull()
  | a = Notify()
  | a = Open()
  | a = Path()
  | a = ParaAlignment()
  | a = Parse()
  | a = Format()
  | a = Print()
  | a = Random()
  | a = Read()
  | a = ReadStream()
  | a = Remove()
  | a = RemoveAll()
  | a = RemoveIter()
  | a = RenameFile()
  | a = Render()
  | a = RenderF()
  | a = RenderInfo()
  | a = Resync()
  | a = RetainAll()
  | a = Return()
  | a = IsNull()
  | a = IsEmptyChannel()
  | a = IsWhiteSpace()
  | a = IsSpace()
  | a = IsUpperCase()
  | a = IsLowerCase()
  | a = IsLetterOrDigit()
  | a = IsLetter()
  | a = IsDigit()
  | a = IsNumeric()
  | a = SetCompressed()
  | a = SetNull()
//  | a = SetPrivilege()
  | a = SetUniqueKey()
  | a = SetNodeSet()
  | a = GetDesktop()
  | a = SetDesktop()
  | a = Show()
  | a = Sort()
  | a = Reverse()
  | a = Spawn()
  | a = Split()
  | a = Collate()
  | a = StartsWith()
  | a = StringIndex()
  | a = Sub()
  | a = SubString()
  | a = StackTrace()
  | a = System()
  | a = SendMail()
  | a = SysOpen()
  | a = SysPrint()
  | a = Throw()
  | a = ToLower()
  | a = ToUpper()
  | a = Trim()
  | a = ToFront()
  | a = AbsUrl()
  | a = Try()
  | a = UnListen()
  | a = SetEventMask()
  | a = Unlock()
  | a = Version()
  | a = Wait()
  | a = WaitProc()
  | a = WriteLn()
  | a = WriteStream()
  | a = Call()
  | a = CallMethod()
  | a = SendRequest()
  | a = GetProcess()
  | a = GetObject()
  | a = GetProperty()
  | a = SetBlob()
  | a = GetBlob()
  | a = SetEntryLogging()
  | a = GetCurrentStack()
  | a = Xfunc()
  | a = SetExceptionHandler()
  | a = FocusTo()
  | a = Accept()
  | a = Typedef()
  | a = NodesOf()
  | LOOKAHEAD( { getToken(1).kind == LBRACE && !isIndirectKeyNodeSpec() } ) a = Block()
  //| LOOKAHEAD( { isMathParenthesis() } ) "(" a = Expression() ")"
  | "(" a = Expression() ")"
  | LOOKAHEAD(NodeRef() <INCR>) a = NodeRef() <INCR> { a = new EvalExpr(a, null, new PostIncrement()); }
  | LOOKAHEAD(NodeRef() <DECR>) a = NodeRef() <DECR> { a = new EvalExpr(a, null, new PostDecrement()); }
  | a = NodeRef()
  | a = LiteralAsAny()
  | a = gEvent()
  | a = gRemoveEvent()
  | a = EventList()
  | a = gProperty()
  | a = gPopup()
  | a = GuiConstant()
  | a = DateConstant()
  | a = PredefinedConstants()
  | a = LogConstants()
  | a = AlwaysEquals()
  | a = Sqrt()
  | a = Sin()
  | a = Cos()
  | a = Tan()
  | a = Asin()
  | a = Acos()
  | a = Atan()
  | a = Ceil()
  | a = Scale()
  | a = Floor()
  | a = ToDegrees()
  | a = ToRadians()
  | a = Exp()
  | a = Log()
  | a = Round()
  | a = GarbageCollect()
  | a = Null()
  )
  {
    return a;
  }
}

Any PredefinedConstants() :
{ Any ret = null; }
{
  ( "TAB_TOP"                     { ret = AnyTabbedPane.TOP; }
  | "TAB_BOTTOM"                  { ret = AnyTabbedPane.BOTTOM; }
  | "TAB_LEFT"                    { ret = AnyTabbedPane.LEFT; }
  | "TAB_RIGHT"                   { ret = AnyTabbedPane.RIGHT; }
  | "GUI_BOTTOM"                  { ret = MakeComponent.BOTTOM; }
  | "GUI_CENTER"                  { ret = MakeComponent.CENTER; }
  | "GUI_EAST"                    { ret = MakeComponent.EAST; }
  | "GUI_HORIZONTAL"              { ret = MakeComponent.HORIZONTAL; }
  | "GUI_LEADING"                 { ret = MakeComponent.LEADING; }
  | "GUI_LEFT"                    { ret = MakeComponent.LEFT; }
  | "GUI_NEXT"                    { ret = MakeComponent.NEXT; }
  | "GUI_NORTH"                   { ret = MakeComponent.NORTH; }
  | "GUI_NORTH_EAST"              { ret = MakeComponent.NORTH_EAST; }
  | "GUI_NORTH_WEST"              { ret = MakeComponent.NORTH_WEST; }
  | "GUI_PREVIOUS"                { ret = MakeComponent.PREVIOUS; }
  | "GUI_RIGHT"                   { ret = MakeComponent.RIGHT; }
  | "GUI_SOUTH"                   { ret = MakeComponent.SOUTH; }
  | "GUI_SOUTH_EAST"              { ret = MakeComponent.SOUTH_EAST; }
  | "GUI_SOUTH_WEST"              { ret = MakeComponent.SOUTH_WEST; }
  | "GUI_TOP"                     { ret = MakeComponent.TOP; }
  | "GUI_TRAILING"                { ret = MakeComponent.TRAILING; }
  | "GUI_VERTICAL"                { ret = MakeComponent.VERTICAL; }
  | "GUI_WEST"                    { ret = MakeComponent.WEST; }
  | "TREE_TABLE"                  { ret = AnyTable.TREE_TABLE; }
  | "FLAT_TABLE"                  { ret = AnyTable.FLAT_TABLE; }
  | "MODAL_NONE"                  { ret = AnyDialog.modalNone__; }
  | "MODAL_PARENT"                { ret = AnyDialog.modalParent__; }
  | "MODAL_ALL"                   { ret = AnyDialog.modalAll__; }
  | "SELECTED"                    { ret = ListenerAdapterFactory.selected__; }
  | "DESELECTED"                  { ret = ListenerAdapterFactory.deSelected__; }
  | "SINGLE_SELECTION"            { ret = MakeComponent.SINGLE_SELECTION; }
  | "SINGLE_INTERVAL_SELECTION"   { ret = MakeComponent.SINGLE_INTERVAL_SELECTION; }
  | "MULTIPLE_INTERVAL_SELECTION" { ret = MakeComponent.MULTIPLE_INTERVAL_SELECTION; }
  | "ROW_SELECTION"               { ret = MakeComponent.rowSelection__; }
  | "COLUMN_SELECTION"            { ret = MakeComponent.columnSelection__; }
  | "CELL_SELECTION"              { ret = MakeComponent.cellSelection__; }
  | "CONTIGUOUS_TREE_SELECTION"   { ret = MakeComponent.CONTIGUOUS_TREE_SELECTION; }
  | "DISCONTIGUOUS_TREE_SELECTION" { ret = MakeComponent.DISCONTIGUOUS_TREE_SELECTION; }
  | "SINGLE_TREE_SELECTION"       { ret = MakeComponent.SINGLE_TREE_SELECTION; }
  | "X_AXIS"                      { ret = MakeComponent.X_AXIS; }
  | "Y_AXIS"                      { ret = MakeComponent.Y_AXIS; }
  | "HIDE_ON_CLOSE"               { ret = AnyWindow.HIDE_ON_CLOSE; }
  | "DO_NOTHING_ON_CLOSE"         { ret = AnyWindow.DO_NOTHING_ON_CLOSE; }
  | "EXIT_ON_CLOSE"               { ret = AnyWindow.EXIT_ON_CLOSE; }
  | "DISPOSE_ON_CLOSE"            { ret = AnyWindow.DISPOSE_ON_CLOSE; }
  | "OPEN_READ"                   { ret = PhysicalIO.read__; }
  | "OPEN_WRITE"                  { ret = PhysicalIO.write__; }
  | "OPEN_APPEND"                 { ret = PhysicalIO.append__; }
  | "FIXED_DELAY"                 { ret = AnyTimerTask.FIXED_DELAY; }
  | "FIXED_RATE"                  { ret = AnyTimerTask.FIXED_RATE; }
  | "PROCESS_DETACHED"            { ret = Process.DETACHED; }
  | "PROCESS_CHILD"               { ret = Process.CHILD; }
  | "PORTRAIT"                    { ret = PrintConstants.PORTRAIT; }
  | "LANDSCAPE"                   { ret = PrintConstants.LANDSCAPE; }
  | "REVERSE_PORTRAIT"            { ret = PrintConstants.REVERSE_PORTRAIT; }
  | "REVERSE_LANDSCAPE"           { ret = PrintConstants.REVERSE_LANDSCAPE; }
  | "ORIENT_VERTICAL"             { ret = MakeComponent.VERTICAL; }
  | "ORIENT_HORIZONTAL"           { ret = MakeComponent.HORIZONTAL; }
  | "MATH_PI"                     { ret = AnyMath.getPi(); }
  | "MATH_E"                      { ret = AnyMath.getE(); }
  | "STRENGTH_PRIMARY"            { ret = AnyCollator.PRIMARY; }
  | "STRENGTH_SECONDARY"          { ret = AnyCollator.SECONDARY; }
  | "STRENGTH_TERTIARY"           { ret = AnyCollator.TERTIARY; }
  | "STRENGTH_IDENTICAL"          { ret = AnyCollator.IDENTICAL; }
  | "NO_DECOMPOSITION"            { ret = AnyCollator.NO_DECOMPOSITION; }
  | "CANONICAL_DECOMPOSITION"     { ret = AnyCollator.CANONICAL_DECOMPOSITION; }
  | "FULL_DECOMPOSITION"          { ret = AnyCollator.FULL_DECOMPOSITION; }
  | "NULL_HIGH"                   { ret = OrderBy.NULL_HIGH; }
  | "NULL_LOW"                    { ret = OrderBy.NULL_LOW; }
  | "GRID_FILL"                   { ret = AnyGrid.GRID_FILL; }
  | "GRID_MIN"                    { ret = AnyGrid.GRID_MINIMUM; }
  | "GRID_PREF"                   { ret = AnyGrid.GRID_PREFERRED; }
  | "AUTO_ACKNOWLEDGE"            { ret = SessionI.AUTO_ACKNOWLEDGE; }
  | "CLIENT_ACKNOWLEDGE"          { ret = SessionI.CLIENT_ACKNOWLEDGE; }
  | "DUPS_OK_ACKNOWLEDGE"         { ret = SessionI.DUPS_OK_ACKNOWLEDGE; }
  | "NON_PERSISTENT"              { ret = SessionI.NON_PERSISTENT; }
  | "PERSISTENT"                  { ret = SessionI.PERSISTENT; }
  | "MONDAY"                      { ret = AnyDate.MONDAY; }
  | "TUESDAY"                     { ret = AnyDate.TUESDAY; }
  | "WEDNESDAY"                   { ret = AnyDate.WEDNESDAY; }
  | "THURSDAY"                    { ret = AnyDate.THURSDAY; }
  | "FRIDAY"                      { ret = AnyDate.FRIDAY; }
  | "SATURDAY"                    { ret = AnyDate.SATURDAY; }
  | "SUNDAY"                      { ret = AnyDate.SUNDAY; }
  | "JANUARY"                     { ret = AnyDate.JANUARY; }
  | "FEBRUARY"                    { ret = AnyDate.FEBRUARY; }
  | "MARCH"                       { ret = AnyDate.MARCH; }
  | "APRIL"                       { ret = AnyDate.APRIL; }
  | "MAY"                         { ret = AnyDate.MAY; }
  | "JUNE"                        { ret = AnyDate.JUNE; }
  | "JULY"                        { ret = AnyDate.JULY; }
  | "AUGUST"                      { ret = AnyDate.AUGUST; }
  | "SEPTEMBER"                   { ret = AnyDate.SEPTEMBER; }
  | "OCTOBER"                     { ret = AnyDate.OCTOBER; }
  | "NOVEMBER"                    { ret = AnyDate.NOVEMBER; }
  | "DECEMBER"                    { ret = AnyDate.DECEMBER; }
 )
  {
    return ret;
  }
}

Any LogConstants() :
{
  Any ret;
}
{
  ( "LOG_ALL"                     { ret = AnyLogManager.LOG_ALL; }
  | "LOG_OFF"                     { ret = AnyLogManager.LOG_OFF; }
  | ret = LogLevel()
  )
  {
    return ret;
  }
}

Any LogLevel() :
{
  Any ret;
}
{
  ( "LOG_CONFIG"                { ret = AnyLogManager.LOG_CONFIG; }
  | "LOG_FINE"                  { ret = AnyLogManager.LOG_FINE; }
  | "LOG_FINER"                 { ret = AnyLogManager.LOG_FINER; }
  | "LOG_FINEST"                { ret = AnyLogManager.LOG_FINEST; }
  | "LOG_INFO"                  { ret = AnyLogManager.LOG_INFO; }
  | "LOG_SEVERE"                { ret = AnyLogManager.LOG_SEVERE; }
  | "LOG_WARNING"               { ret = AnyLogManager.LOG_WARNING; }
  )
  {
    return ret;
  }
}

Any Null() :
{}
{
  "null"   { return AnyNull.instance(); }
}

Any AlwaysEquals() :
{}
{
  "equals"   { return AnyAlwaysEquals.instance(); }
}

Any Sqrt() :
{
  Any a;
}
{
  "sqrt"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Sqrt());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Sin() :
{
  Any a;
}
{
  "sin"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Sin());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Cos() :
{
  Any a;
}
{
  "cos"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Cos());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Tan() :
{
  Any a;
}
{
  "tan"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Tan());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Asin() :
{
  Any a;
}
{
  "asin"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Asin());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Acos() :
{
  Any a;
}
{
  "acos"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Acos());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Atan() :
{
  Any a;
}
{
  "atan"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Atan());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Ceil() :
{
  Any a;
}
{
  "ceil"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Ceil());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Floor() :
{
  Any a;
}
{
  "floor"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Floor());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any ToDegrees() :
{
  Any a;
}
{
  "todegrees"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Degree());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any ToRadians() :
{
  Any a;
}
{
  "toradians"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Rad());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Exp() :
{
  Any a;
}
{
  "exp"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Exp());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Log() :
{
  Any a;
}
{
  "logn"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Log());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Scale() :
{
  Any a;
}
{
  "scale"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Scale());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any IsNumeric() :
{
  Any a;
}
{
  "isnumeric"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new IsNumeric());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any Round() :
{
  Any a;
}
{
  "round"
  "("
  a = Expression()
  ")"
  {
    EvalExpr e = new EvalExpr(a, null, new Round());
    e.setLineNumber(token.beginLine);
    return e;
  }
}

Any IOOpenConstants() :
{}
{
  ( "OPEN_READ"   { return PhysicalIO.read__; }
  | "OPEN_WRITE"  { return PhysicalIO.write__; }
  | "OPEN_APPEND" { return PhysicalIO.append__; }
  )
}

/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
Any If() :
{ Any ifCond = null, ifExpr = null, elseExpr = null; int line; }
{
  "if" { line = token.beginLine; }
  "(" ifCond = Expression()
  ")"
  ifExpr = Statement() ( LOOKAHEAD(1) "else" elseExpr = Statement() )?
  {
    If iff = new If(ifCond, ifExpr, elseExpr);
    iff.setLineNumber(line);
    return iff;
  }
}

Any While() :
{ Any whileCond, whileExpr; int line; }
{
  "while" {line = token.beginLine; }
  "(" whileCond = Expression() ")" whileExpr = Statement()
  {
    While w = new While(whileCond, whileExpr);
    w.setLineNumber(line);
    return w;
  }
}

Any Do() :
{ Any doCond, doExpr; int line; }
{
  "do" {line = token.beginLine; } doExpr = Statement() "while" doCond = Expression()
  {
    While w = new While(doCond, doExpr, true);
    w.setLineNumber(line);
    return w;
  }
}

Any For() :
{
  Any init = null;
  Any test = null;
  Any finl = null;
  Any expr;
  int line;
}
{
  "for" {line = token.beginLine; }
  "("
  [ init = Expression() ]
  ";"
  [ test = Expression() ]
  ";"
  [ finl = Expression() ]
  ")"
  expr = Statement()
  {
    For f = new For(init, test, finl, expr);
    f.setLineNumber(line);
    return f;
  }
}

// Switch
Any Switch() :
{
  Array whens = AbstractComposite.array();
  Any   otherwise = null;
  Any   cond;
  Any   expr;
  int   line;
}
{
 "switch" { line = token.beginLine; }
 "{" (( "when"
        "("
        cond = Expression()
        ")"
        expr = Statement()
       )
       {
          Choose.TestExpr te = new Choose.TestExpr(cond, expr);
         whens.add(te);
       }
      )+
  [ "otherwise" otherwise = Statement() ]
  "}"
  {
    Choose c = new Choose(whens, otherwise);
    c.setLineNumber(line);
    return c;
  }
}


// Built-in functions

Any Sum() :
{
  Any sumRoot;
  Any sumNode;
  int line;
}
{
  "sum" { line = token.beginLine; } "(" sumRoot = Expression() "," sumNode = Expression() ")"
  {
    Sum s = new Sum (sumRoot, sumNode);
    s.setLineNumber(line);
    return s;
  }
}

Any Avg() :
{
  Any sumRoot;
  Any sumNode;
  int line;
}
{
  "avg" { line = token.beginLine; } "(" sumRoot = Expression() "," sumNode = Expression() ")"
  {
    Sum s = new Sum (sumRoot, sumNode);
    s.setLineNumber(line);
    s.setTakeAverage(true);
    return s;
  }
}

Any WAvg() :
{
  Any sumRoot;
  Any sumNode;
  Any wgtNode;
  int line;
}
{
  "wavg" { line = token.beginLine; }
  "("
  sumRoot = Expression()
  ","
  sumNode = Expression()
  ","
  wgtNode = Expression()
  ")"
  {
    WAvg w = new WAvg (sumRoot, sumNode, wgtNode);
    w.setLineNumber(line);
    return w;
  }
}

Any Abort() :
{ int line; }
{
  "abort" { line = token.beginLine; } "(" ")"
  {
    Abort a = new Abort();
    a.setLineNumber(line);
    return a;
  }
}

Any Abs() :
{ Any a = null; int line; }
{
  "abs" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    EvalExpr e = new EvalExpr(a, new Abs());
    e.setLineNumber(line);
    return e;
  }
}

Any AbsUrl() :
{ Any rel; Any abs = null; int line; }
{
  "absurl" { line = token.beginLine; }
  "("
  rel = Expression()
  [ "," abs = Expression() ]
  ")"
  {
    AbsUrl a = new AbsUrl(rel, abs);
    a.setLineNumber(line);
    return a;
  }
}

Any Commit() :
{ int line; }
{
  "commit" { line = token.beginLine; } "(" ")"
  {
    Commit c = new Commit();
    c.setLineNumber(line);
    return c;
  }
}

Any Contains() :
{ Any container; Any contained; int line; }
{
  "contains" { line = token.beginLine; }
  "(" container = Expression() "," contained = Expression() ")"
  {
    Contains c = new Contains(container, contained);
    c.setLineNumber(line);
    return c;
  }
}

Any IndexOf() :
{ Any container; Any contained; int line; }
{
  "indexof" { line = token.beginLine; }
  "(" container = Expression() "," contained = Expression() ")"
  {
    IndexOf i = new IndexOf(container, contained);
    i.setLineNumber(line);
    return i;
  }
}

Any KeysOf() :
{
  Any map;
  int line;
}
{
  "keysof" { line = token.beginLine; }
  "(" map = Expression() ")"
  {
    KeysOf k = new KeysOf(map);
    k.setLineNumber(line);
    return k;
  }
}

Any Collate() :
{ Any collator; Any op1; Any op2 = null; int line; }
{
  "collate" { line = token.beginLine; }
  "("
  collator = Expression()
  ","
  op1 = Expression()
  [ "," op2 = Expression() ]
  ")"
  {
    Collate c = new Collate(collator, op1, op2);
    c.setLineNumber(line);
    return c;
  }
}

Any ContainsAll() :
{ Any container; Any contains; int line; }
{
  "containsall" { line = token.beginLine; }
  "(" container = Expression() "," contains = Expression() ")"
  {
    ContainsAll c = new ContainsAll(container, contains);
    c.setLineNumber(line);
    return c;
  }
}

Any ContainsAny() :
{ Any container; Any contains; int line; }
{
  "containsany" { line = token.beginLine; }
  "(" container = Expression() "," contains = Expression() ")"
  {
    ContainsAny c = new ContainsAny(container, contains);
    c.setLineNumber(line);
    return c;
  }
}

Any ContainsValue() :
{ Any container; Any contained; int line; }
{
  "containsvalue" { line = token.beginLine; }
  "(" container = Expression() "," contained = Expression() ")"
  {
    ContainsValue c = new ContainsValue(container, contained);
    c.setLineNumber(line);
    return c;
  }
}

Any Continue() :
{ int line; }
{
  "continue" { line = token.beginLine; }
  {
    Continue c = new Continue();
    c.setLineNumber(line);
    return c;
  }
}

Any Count() :
{ Any a; int line; }
{
  "count" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    Count c = new Count(a);
    c.setLineNumber(line);

    return c;
  }
}

Any NodesOf() :
{
  Any     container;
  Any     path;
  boolean indices = false;
  int     line;
}
{
  ( "nodesof" | "indicesof" { indices = true; } ) { line = token.beginLine; }
  "("
  container = Expression()
  ","
  path = Expression()
  ")"
  {
    NodesOf n = new NodesOf(container, path);
    n.setIndices(indices);
    n.setLineNumber(line);

    return n;
  }
}

Any Create() :
{
  Any a;
  Any eventData = null;
  Any action    = null;
  int line;
}
{
  "create" { line = token.beginLine; }
  "("
  a = Expression()
  [ "," eventData = Expression() [ "," action = CreateAction() ] ]
  ")"
  {
    Create c = new Create(a, eventData, action);
    c.setLineNumber(line);
    return c;
  }
}

Any CreateAction() :
{}
{
  "CREATE_ERROR"   { return Create.CREATE_ERROR; }
  |
  "CREATE_REPLACE" { return Create.CREATE_REPLACE; }
  |
  "CREATE_LEAVE"   { return Create.CREATE_LEAVE; }
}

Any IsCreating() :
{
  Any a;
  int line;
}
{
  "iscreating" { line = token.beginLine; }
  "("
  a = Expression()
  ")"
  {
    IsCreating c = new IsCreating(a);
    c.setLineNumber(line);
    return c;
  }
}

Any IsManaged() :
{
  Any a;
  int line;
}
{
  "ismanaged" { line = token.beginLine; }
  "("
  a = Expression()
  ")"
  {
    IsManaged m = new IsManaged(a);
    m.setLineNumber(line);
    return m;
  }
}

Any Creating() :
{
  Any descriptor = null;
  Any getType = null;
  Any typedef = null;
  String typeName = null;
  String packageOverride = _package;
  int line;
}
{
  "creating" { line = token.beginLine; }
  "("
  ( [ ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
        <IDENTIFIER> { typeName = token.image; }
      )
      | getType = GetType()
      | typedef = Typedef()
    ]
  )
  ")"
  {
    if (getType == null && typedef == null)
    {
      Locate l = new LocateNode("$catalog." + packageOverride + ".types." + typeName);
      l.setLineNumber(line);
      descriptor = l;
    }
    else if (getType != null)
    {
      descriptor = getType;
    }
    else
      descriptor = typedef;

    Creating c = new Creating(descriptor);
    c.setLineNumber(line);
    return c;
  }
}

Any Modifying() :
{
  Any descriptor = null;
  Any getType = null;
  Any typedef = null;
  String typeName = null;
  String packageOverride = _package;
  int line;
}
{
  "modifying" { line = token.beginLine; }
  "("
  ( [ ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
        <IDENTIFIER> { typeName = token.image; }
      )
      | getType = GetType()
      | typedef = Typedef()
    ]
  )
  ")"
  {
    if (getType == null && typedef == null)
    {
      Locate l = new LocateNode("$catalog." + packageOverride + ".types." + typeName);
      l.setLineNumber(line);
      descriptor = l;
    }
    else if (getType != null)
    {
      descriptor = getType;
    }
    else
      descriptor = typedef;

    Modifying m = new Modifying(descriptor);
    m.setLineNumber(line);
    return m;
  }
}

Any IsModifying() :
{
  Any a;
  int line;
}
{
  "ismodifying" { line = token.beginLine; }
  "("
  a = Expression()
  ")"
  {
    IsModifying i = new IsModifying(a);
    i.setLineNumber(line);
    return i;
  }
}

Any Deleting() :
{
  Any descriptor = null;
  Any getType = null;
  Any typedef = null;
  String typeName = null;
  String packageOverride = _package;
  int line;
}
{
  "deleting" { line = token.beginLine; }
  "("
  ( [ ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
        <IDENTIFIER> { typeName = token.image; }
      )
      | getType = GetType()
      | typedef = Typedef()
    ]
  )
  ")"
  {
    if (getType == null && typedef == null)
    {
      Locate l = new LocateNode("$catalog." + packageOverride + ".types." + typeName);
      l.setLineNumber(line);
      descriptor = l;
    }
    else if (getType != null)
    {
      descriptor = getType;
    }
    else
      descriptor = typedef;

    Deleting d = new Deleting(descriptor);
    d.setLineNumber(line);
    return d;
  }
}

Any CreateFile() :
{ Any a; int line; }
{
  "createfile" { line = token.beginLine; } "(" a = Expression() ")"
  {
    CreateNewFile c = new CreateNewFile(a);
    c.setLineNumber(line);
    return c;
  }
}

Any CreateTempFile() :
{
  Any prefix;
  Any suffix = null;
  Any dir    = null;
  int line;
}
{
  "createtmpfile" { line = token.beginLine; }
  "("
  prefix = Expression()
  [ "," suffix = Expression()
    [ "," dir = Expression() ]
  ]
  ")"
  {
    CreateTempFile c = new CreateTempFile(prefix, suffix, dir);
    c.setLineNumber(line);
    return c;
  }
}

Any CreateTimer() :
{
  Any func;
  Any whenOrDelay;
  Any period = AnyNull.instance();
  Any delayOrRate = AnyTimerTask.FIXED_DELAY;
  int line;
  Any start = AnyBoolean.TRUE;
}
{
  "createtimer" { line = token.beginLine; }
  "("
  func = Expression()
  ","
  whenOrDelay = Expression()
  [ LOOKAHEAD(2) "," period = Expression()
    [ LOOKAHEAD(2) "," delayOrRate = Expression() ] ]
  [ "," "start" "=" start = Expression() ]
  ")"
  {
    ScheduleAt s =  new ScheduleAt(func, whenOrDelay, period, delayOrRate, start);
    s.setLineNumber(line);

    return s;
  }
}

Any CancelTimer() :
{ Any a; int line; }
{
  "canceltimer" { line = token.beginLine; } "(" a = Expression() ")"
  {
    CancelTimer c = new CancelTimer(a);
    c.setLineNumber(line);
    return c;
  }
}

Any StartTimer() :
{
  Any timer;
  Any delay = null;
  int line;
}
{
  "starttimer" { line = token.beginLine; }
  "("
  timer = Expression()
  [ "," delay = Expression() ]
  ")"
  {
    StartTimer s = new StartTimer(timer, delay);
    s.setLineNumber(line);
    return s;
  }
}

Any FireTimer() :
{ Any a; int line; }
{
  "firetimer" { line = token.beginLine; } "(" a = Expression() ")"
  {
    FireTimer f = new FireTimer(a);
    f.setLineNumber(line);
    return f;
  }
}

Any Crypt() :
{ Any a; int line; }
{
  "crypt" { line = token.beginLine; } "(" a = Expression() ")"
  {
    Crypt c = new Crypt(a);
    c.setLineNumber(line);
    return c;
  }
}

Any DateAdd() :
{ Any theDate;
  Any datePart;
  Any value;
  Any cal = null;
  int line;
}
{
  "dateadd" { line = token.beginLine; }
  "("
  datePart = DatePartAny()
  ","
  value    = Expression()
  ","
  theDate  = Expression()
  [ "," "calendar" "=" cal = Expression() ]
  ")"
  {
    DateAdd d = new DateAdd(datePart, value, theDate, cal);
    d.setLineNumber(line);
    return d;
  }
}

Any DateDiff() :
{ Any datePart;
  Any d1;
  Any d2;
  Any cal = null;
  int line;
}
{
  "datediff" { line = token.beginLine; }
  "("
  datePart = DatePartAny()
  ","
  d1       = Expression()
  ","
  d2       = Expression()
  [ "," "calendar" "=" cal = Expression() ]
  ")"
  {
    DateDiff d = new DateDiff(datePart, d1, d2, cal);
    d.setLineNumber(line);
    return d;
  }
}

Any DateTrunc() :
{ Any datePart;
  Any d1;
  Any cal = null;
  int line;
}
{
  "datetrunc" { line = token.beginLine; }
  "("
  datePart = DatePartAny()
  ","
  d1       = Expression()
  [ "," "calendar" "=" cal = Expression() ]
  ")"
  {
    DateFlat d = new DateFlat(datePart, d1, cal);
    d.setLineNumber(line);
    return d;
  }
}

Any DatePart() :
{ 
  Any datePart;
  Any d;
  Any cal = null;
  int line;
}
{
  "datepart" { line = token.beginLine; }
  "("
  datePart = DatePartAny()
  ","
  d        = Expression()
  [ "," "calendar" "=" cal = Expression() ]
  ")"
  {
    DatePart dp = new DatePart(datePart, d, cal);
    dp.setLineNumber(line);
    return dp;
  }
}

Any DatePartSet() :
{
  Any datePart = null;
  Locate d;
  Any val = null;
  Any p1  = null;
  Any p2  = null;
  Any p3  = null;
  Any p4  = null;
  Any p5  = null;
  Any p6  = null;
  Any cal = null;
  int line;
}
{
  "dateset" { line = token.beginLine; }
  "("
  (
    ( datePart = DatePartAny()
      ","
      d = NodeRef()
      ","
      val = Expression()
      [ "," "calendar" "=" cal = Expression() ]
    )
    |
    (
      d = NodeRef()
      ","
      p1 = Expression()
      ","
      p2 = Expression()
      ","
      p3 = Expression()
      ","
      p4 = Expression()
      ","
      p5 = Expression()
      [ LOOKAHEAD("," "calendar")
        (
          "," "calendar" "=" cal = Expression()
        )
        |
        ( ","
          p6 = Expression()
          [ "," "calendar" "=" cal = Expression() ]
        )
      ]
    )
  )
  ")"
  {

    DatePartSet dp;
    if (datePart != null)
      dp = new DatePartSet(datePart, d, val, cal);
    else
    {
      Array arr = AbstractComposite.array();
      arr.add(p1);
      arr.add(p2);
      arr.add(p3);
      arr.add(p4);
      arr.add(p5);
      if (p6 != null)
        arr.add(p6);

      val = arr;
      dp = new DatePartSet(d, val, cal);
    }
    dp.setLineNumber(line);
    return dp;
  }
}

Any DatePartMax() :
{
  Any datePart;
  Any d;
  Any cal = null;
  int line;
}
{
  "datepartmax" { line = token.beginLine; }
  "("
  datePart = DatePartAny()
  ","
  d        = Expression()
  [ "," "calendar" "=" cal = Expression() ]
  ")"
  {
    DatePartMax dp = new DatePartMax(datePart, d, cal);
    dp.setLineNumber(line);
    return dp;
  }
}

Any DatePartAny() :
{}
{
  ( "DAY_OF_WEEK"
  | "DAY"
  | "WEEK_OF_YEAR"
  | "DAY_OF_MONTH"
  | "DAY_OF_WEEK_IN_MONTH"
  | "DAY_OF_YEAR"
  | "HOUR_OF_DAY"
  | "HOUR"
  | "MILLISECOND"
  | "MINUTE"
  | "MONTH"
  | "SECOND"
  | "WEEK_OF_MONTH"
  | "YEAR"
  )
  {
    switch (token.kind)
    {
      case DAYOFWEEK:        return AnyDate.DAY_OF_WEEK;
      case WEEKOFYEAR:       return AnyDate.WEEK_OF_YEAR;
      case DAYOFMONTH:       return AnyDate.DAY_OF_MONTH;
      case DAYOFWEEKINMONTH: return AnyDate.DAY_OF_WEEK_IN_MONTH;
      case DAYOFYEAR:        return AnyDate.DAY_OF_YEAR;
      case DAY:              return AnyDate.DAY_OF_YEAR;
      case HOUROFDAY:        return AnyDate.HOUR_OF_DAY;
      case HOUR:             return AnyDate.HOUR;
      case MILLISECOND:      return AnyDate.MILLISECOND;
      case MINUTE:           return AnyDate.MINUTE;
      case MONTH:            return AnyDate.MONTH;
      case SECOND:           return AnyDate.SECOND;
      case WEEKOFMONTH:      return AnyDate.WEEK_OF_MONTH;
      case YEAR:             return AnyDate.YEAR;
      default: return AnyDate.DAY_OF_MONTH;
    }
  }
}

Any DateConstant() :
{ Any a; String gc; }
{
  "Calendar"
  "("
  <IDENTIFIER> { gc = token.image; }
  ")"
  {
    Class c = com.inqwell.any.AnyDate.class;
    try
    {
      Field f = c.getField(gc);
      return (Any)(f.get(null));
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

Any KeyModifierAsAny() :
{}
{
  ( "SHIFT_MASK"
  |  "CTRL_MASK"
  |  "META_MASK"
  |  "ALT_MASK"
  )
  {
    switch (token.kind)
    {
      case SHIFT_MASK: return AnyComponent.SHIFT_MASK;
      case CTRL_MASK:  return AnyComponent.CTRL_MASK;
      case META_MASK:  return AnyComponent.META_MASK;
      case ALT_MASK:   return AnyComponent.ALT_MASK;
    }
  }
}

Any Delete() :
{ Locate l; int line; }
{
  "delete" { line = token.beginLine; } "(" l = NodeRef() ")"
  {
    Delete d = new Delete(l);
    d.setLineNumber(line);
    return d;
  }
}

Any Distinct() :
{ Any root; Any expr; Any target = null; BooleanI remove = null; int line; }
{
  "distinct" { line = token.beginLine; }
  "("
  root = Expression()
  ","
  expr = Expression()
  ("," ( LOOKAHEAD("remove") ( "remove" "=" remove = BooleanLiteralAsAny() )
       | target = Expression()
       )
  )*
  ")"
  {
    if (!(expr instanceof Func))
      throw new AnyRuntimeException("distinct expression must be a function");

    Distinct d = new Distinct(root, (Func)expr, target);
    d.setLineNumber(line);

    if (remove != null)
      d.setRemove(remove.getValue());

    return d;
  }
}

Any DeleteFile() :
{ Any a; int line; }
{
  "deletefile" { line = token.beginLine; } "(" a = Expression() ")"
  {
    DeleteFile d = new DeleteFile(a);
    d.setLineNumber(line);
    return d;
  }
}

Any Empty() :
{ Any a; int line; }
{
  "empty" { line = token.beginLine; } "(" a = Expression() ")"
  {
    Empty e = new Empty(a);
    e.setLineNumber(line);
    return e;
  }
}

Any Enum() :
{
  String packageOverride = _package;
  String typeName;
  String fieldName;
  String symbol;
  int    line;
}
{
  "enum" { line = token.beginLine; }
  "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  typeName = FieldImport() { fieldName = token.image; }
  ","
  <IDENTIFIER> { symbol = token.image; }
  ")"
  {
    Locate l;
    Enum e = new Enum(l = new LocateNode("$catalog." + packageOverride + ".types." + typeName),
                    new ConstString(fieldName),
                    new ConstString(symbol));
    e.setLineNumber(line);
    l.setLineNumber(line);
    return e;
  }
}

Any IsEnum() :
{
  String packageOverride = _package;
  String typeName;
  String fieldName;
  Any    value;
  int    line;
}
{
  "isenum" { line = token.beginLine; }
  "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  typeName = FieldImport() { fieldName = token.image; }
  ","
  value = Expression()
  ")"
  {
    Locate l;
    IsEnum e = new IsEnum(l = new LocateNode("$catalog." + packageOverride + ".types." + typeName),
                    new ConstString(fieldName),
                    value);
    e.setLineNumber(line);
    l.setLineNumber(line);
    return e;
  }
}

Any EnumExternal() :
{
  Func   a;
  Locate l               = null;
  String packageOverride = _package;
  String typeName        = null;
  String fieldName       = null;
  Any    symbol          = null;
  Any    getType            = null;
  Any    fieldAny           = null;
  int    line;
}
{
  "enumext" { line = token.beginLine; }
  "("
  (
    LOOKAHEAD( NodeRef() ")" ) l = NodeRef()
    |
    (
      ( ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
          typeName = FieldImport() { fieldName = token.image; }
        )
        |
        ( "typeof" "=" "(" getType = Expression() "," fieldAny = Expression() ")" )
      )
      ","
      (
        LOOKAHEAD(<IDENTIFIER>) <IDENTIFIER> { symbol = new ConstString(token.image); }
        |
        symbol = Expression()
      )
    )
  )
  ")"
  {
    if (l != null)
    {
      a = new EnumExternal(l);
      l.setLineNumber(line);
    }
    else
    {
      if (getType == null)
      {
        Locate ll;
        a = new EnumStaticExternal(ll = new LocateNode("$catalog." + packageOverride + ".types." + typeName),
                                                  new ConstString(fieldName),
                                                  symbol);
        ll.setLineNumber(line);
      }
      else
      {
        a = new EnumStaticExternal(getType, fieldAny, symbol);
      }
    }
    a.setLineNumber(line);
    return a;
  }
}

Any FieldName() :
{
  String packageOverride = _package;
  String typeName;
  String fieldName;
  int    line;
}
{
  "fieldname" { line = token.beginLine; }
  "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  typeName = FieldImport() { fieldName = token.image; }
  ")"
  {
    Locate l;
    FieldName f = new FieldName(l = new LocateNode("$catalog." + packageOverride + ".types." + typeName),
                                new ConstString(fieldName));
    f.setLineNumber(line);
    l.setLineNumber(line);
    return f;
  }
}

Any EqualsOrNull() :
{ Any op1; Any op2; int line; }
{
  "equalsornull" { line = token.beginLine; }
  "("
  op1 = Expression()
  ","
  op2 = Expression()
  ")"
  {
    EqualsOrNull e = new EqualsOrNull(op1, op2);
    e.setLineNumber(line);
    return e;
  }
}

Any Exec() :
{ Any script; Any base = null; int line; }
{
  "exec" { line = token.beginLine; }
  "("
  script = Expression()
  [ "," base = Expression() ]
  ")"
  {
    if (base == null)
      base = documentAnyURL_;
      
    ExecInq e = new ExecInq(script, base);
    e.setLineNumber(line);

    return e;
  }
}

Any Compile() :
{ Any script; int line; ; Any placeAt = null; }
{
  "compile" { line = token.beginLine; }
  "("
  script = Expression()
  [ "," placeAt = Expression() ]
  ")"
  {
    Compile c = new Compile(script, documentAnyURL_, placeAt);
    c.setLineNumber(line);

    return c;
  }
}

Any Exit() :
{ Any exitStatus = null; int line; }
{
  "exit"  { line = token.beginLine; }
  "("
  [ exitStatus = Expression() ]
  ")"
  {
    Exit e = new Exit(exitStatus);
    e.setLineNumber(line);
    return e;
  }
}

Any Expire() :
{
  String            packageOverride = _package;
  String            botName = null;
  Any               getType = null;
  Any               initVal = null;
  Locate            l;
  int               line;
}
{
  "expire" { line = token.beginLine; } "("
  ( ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
      <IDENTIFIER> { botName = token.image; }
    )
  | getType = GetType()
  )
  ")"
  {
    Expire e;
    if (getType == null)
    {
      e = new Expire(l = new LocateNode("$catalog." + packageOverride + ".types." + botName));
      l.setLineNumber(line);
    }
    else
    {
      e = new Expire(getType);
    }
    e.setLineNumber(line);
    return e;
  }
}

Any Foreach() :
{ Any root; Any expr; BooleanI b = null; int line; }
{
  "foreach" { line = token.beginLine; }
  "("
  root = Expression()
  [ "," b = BooleanLiteralAsAny() ]
  ")"
  expr = Statement()
  {
    ForEach f;
    if (b != null && b.getValue())
      f = new ForEachCS(root, expr);
    else
      f = new ForEach(root, expr);

    f.setLineNumber(line);

    return f;
  }
}

Any GarbageCollect() :
{ int line; }
{
  "garbagecollect"  { line = token.beginLine; }
  "("
  ")"
  {
    GarbageCollect gc = new GarbageCollect();
    gc.setLineNumber(line);
    return gc;
  }
}

Any GetName() :
{ Any a; int line; }
{
  "getname" { line = token.beginLine; } "(" a = Expression() ")"
  {
    GetName g = new GetName(a);
    g.setLineNumber(line);
    return g;
  }
}

Any GetType() :
{ Any a; int line; }
{
  "typeof" { line = token.beginLine; } "(" a = Expression() ")"
  {
    GetType g = new GetType(a);
    g.setLineNumber(line);
    return g;
  }
}

Any IsType() :
{
  Any a;
  Any type;
  int line;
}
{
  "istype" { line = token.beginLine; }
  "("
  a = Expression()
  ","
  type = Expression()
  ")"
  {
    IsType i = new IsType(a, type);
    i.setLineNumber(line);
    return i;
  }
}

Any Typedef() :
{
  String  typPackageOverride = _package;
  String  typ                = null;
  String  field              = null;
  Locate  typeRef;
  int     line;
}
{
  "typedef" { line = token.beginLine; }
  "("
  ( [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
                            typ = FieldImport() { field = token.image; } )
  ")"
  {
    typeRef = new LocateNode("$catalog." + typPackageOverride + ".types." + typ);
    typeRef.setLineNumber(line);
    return typeRef;
  }
}

Any GroupBy() :
{
  Any root;
  Any distinct;
  Any start;
  Any foreach = null;
  Any end = null;
  int line;
}
{
  "groupby" { line = token.beginLine; }
  "("
  root = Expression()
  ","
  distinct = Expression()
  ","
  start = Expression()
  (
    ","
    ( ( "foreach" "=" foreach = Expression() )
      |
      ( "end"     "=" end = Expression() )
    )
  )*
  ")"
  {
    GroupBy gb = new GroupBy(root,
                             distinct,
                             start,
                             foreach,
                             end);
    gb.setLineNumber(line);
    return gb;
  }
}

Any LogMessage() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logmessage" { line = token.beginLine; }
  "("
  logger = Expression()
  ","
  level = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogFinest() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logfinest" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_FINEST; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogFiner() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logfiner" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_FINER; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogFine() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logfine" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_FINE; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogConfig() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logconfig" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_CONFIG; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogInfo() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "loginfo" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_INFO; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogWarning() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logwarning" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_WARNING; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogSevere() :
{
  Any   logger;
  Any   level;

  int line;
}
{
  "logsevere" { line = token.beginLine; }
  "(" { level = AnyLogManager.LOG_SEVERE; } 
  logger = Expression()
  logger = LogTrailing(logger, level, line)
  {
    return logger;
  }
}

Any LogTrailing(Any logger, Any level, int line) :
{
  Any   message;
  Array params = null;
  Any   arg;
}
{
  ","
  message = Expression()
  ( ","
    arg = Expression()
    {
      if (params == null)
        params = AbstractComposite.array();

      params.add(arg);
    }
  )*
  ")"
  {
    LogMessage logMessage = new LogMessage(logger, level, message, params);
    logMessage.setLineNumber(line);
    return logMessage;
  }
}

Any GetLogger() :
{
  Any name;

  int line;
}
{
  "getlogger" { line = token.beginLine; }
  "("
  name = Expression()
  ")"
  {
    GetLogger g = new GetLogger(name);
    g.setLineNumber(line);
    return g;
  }
}

Any LoggerNames() :
{
  int line;
}
{
  "loggernames" { line = token.beginLine; }
  "("
  ")"
  {
    GetLoggerNames g = new GetLoggerNames();
    g.setLineNumber(line);
    return g;
  }
}

Any MQCreateConnection() :
{
  int line;
  Any cf;
  Any user   = null;
  Any passwd = null;
}
{
  "mqcreateconnection" { line = token.beginLine; } 
  "("
  cf = Expression()
  ( ","
    user = Expression()
    ","
    passwd = Expression()
  )?
  ")"
  {
    MqCreateConnection m = new MqCreateConnection(cf, user, passwd);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateSession() :
{
  int line;
  Any conn;
  Any ack = null;
  Any txn;
}
{
  "mqcreatesession" { line = token.beginLine; } 
  "("
  conn = Expression()
  ","
  txn = Expression()
  [ ","
    ack = Expression()
  ]
  ")"
  {
    MqCreateSession m = new MqCreateSession(conn, ack, txn);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateQueue() :
{
  int line;
  Any sess;
  Any qname;
}
{
  "mqcreatequeue" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  qname = Expression()
  ")"
  {
    MqCreateQueue m = new MqCreateQueue(sess, qname);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateTopic() :
{
  int line;
  Any sess;
  Any topicName;
}
{
  "mqcreatetopic" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  topicName = Expression()
  ")"
  {
    MqCreateTopic m = new MqCreateTopic(sess, topicName);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateProducer() :
{
  int line;
  Any sess;
  Any dest = null;
}
{
  "mqcreateproducer" { line = token.beginLine; } 
  "("
  sess = Expression()
  (
  ","
  dest = Expression()
  )?
  ")"
  {
    MqCreateProducer m = new MqCreateProducer(sess, dest);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateBytesMessage() :
{
  int line;
  Any sess;
  Any bytes = null;
}
{
  "mqcreatebytesmessage" { line = token.beginLine; } 
  "("
  sess = Expression()
  [ "," bytes = Expression() ]
  ")"
  {
    MqCreateBytesMessage m = new MqCreateBytesMessage(sess, bytes);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateStreamMessage() :
{
  int line;
  Any sess;
  Any bytes = null;
}
{
  "mqcreatestreammessage" { line = token.beginLine; } 
  "("
  sess = Expression()
  [ "," bytes = Expression() ]
  ")"
  {
    MqCreateStreamMessage m = new MqCreateStreamMessage(sess, bytes);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateMapMessage() :
{
  int line;
  Any sess;
}
{
  "mqcreatemapmessage" { line = token.beginLine; } 
  "("
  sess = Expression()
  ")"
  {
    MqCreateMapMessage m = new MqCreateMapMessage(sess);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateTemporaryQueue() :
{
  int line;
  Any sess;
}
{
  "mqcreatetemporaryqueue" { line = token.beginLine; } 
  "("
  sess = Expression()
  ")"
  {
    MqCreateTemporaryQueue m = new MqCreateTemporaryQueue(sess);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateTemporaryTopic() :
{
  int line;
  Any sess;
}
{
  "mqcreatetemporarytopic" { line = token.beginLine; } 
  "("
  sess = Expression()
  ")"
  {
    MqCreateTemporaryTopic m = new MqCreateTemporaryTopic(sess);
    m.setLineNumber(line);
    return m;
  }
}

Any MQStart() :
{
  int line;
  Any conn;
}
{
  "mqstart" { line = token.beginLine; } 
  "("
  conn = Expression()
  ")"
  {
    MqStart m = new MqStart(conn);
    m.setLineNumber(line);
    return m;
  }
}

Any MQStop() :
{
  int line;
  Any conn;
}
{
  "mqstop" { line = token.beginLine; } 
  "("
  conn = Expression()
  ")"
  {
    MqStop m = new MqStop(conn);
    m.setLineNumber(line);
    return m;
  }
}

Any MQUnsubscribe() :
{
  int line;
  Any sess;
  Any name;
}
{
  "mqunsubscribe" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  name = Expression()
  ")"
  {
    MqUnsubscribe m = new MqUnsubscribe(sess, name);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateMessage() :
{
  int line;
  Any sess;
}
{
  "mqcreatemessage" { line = token.beginLine; } 
  "("
  sess = Expression()
  ")"
  {
    MqCreateMessage m = new MqCreateMessage(sess);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateAnyMessage() :
{
  int line;
  Any sess;
  Any any = null;
}
{
  "mqcreateanymessage" { line = token.beginLine; } 
  "("
  sess = Expression()
  [ "," any = Expression() ]
  ")"
  {
    MqCreateAnyMessage m = new MqCreateAnyMessage(sess, any);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateTextMessage() :
{
  int line;
  Any sess;
  Any any = null;
}
{
  "mqcreatetextmessage" { line = token.beginLine; } 
  "("
  sess = Expression()
  [ "," any = Expression() ]
  ")"
  {
    MqCreateTextMessage m = new MqCreateTextMessage(sess, any);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateConsumer() :
{
  int line;
  Any sess;
  Any dest;
  Any sel     = null;
  Any nolocal = null;
}
{
  "mqcreateconsumer" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  dest = Expression()
  [ ","
    sel = Expression()
    [ ","
      nolocal = Expression()
    ]
  ]
  ")"
  {
    MqCreateConsumer m = new MqCreateConsumer(sess, dest, sel, nolocal);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateDurableSubscriber() :
{
  int line;
  Any sess;
  Any topic;
  Any name;
  Any sel     = null;
  Any nolocal = null;
}
{
  "mqcreatedurablesubscriber" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  topic = Expression()
  ","
  name = Expression()
  ( ","
    sel = Expression()
    ","
    nolocal = Expression()
  )?
  ")"
  {
    MqCreateDurableSubscriber m = new MqCreateDurableSubscriber(sess,
                                                                topic,
                                                                name,
                                                                sel,
                                                                nolocal);
    m.setLineNumber(line);
    return m;
  }
}

Any MQSetMessageListener() :
{
  int line;
  Any sess;
  Any f;
}
{
  "mqsetmessagelistener" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  f = Expression()
  ")"
  {
    MqSetMessageListener m = new MqSetMessageListener(sess, f);
    m.setLineNumber(line);
    return m;
  }
}

Any MQCreateQueueBrowser() :
{
  int line;
  Any sess;
  Any queue;
  Any sel     = null;
}
{
  "mqcreatequeuebrowser" { line = token.beginLine; } 
  "("
  sess = Expression()
  ","
  queue = Expression()
  [ ","
    sel = Expression()
  ]
  ")"
  {
    MqCreateQueueBrowser m = new MqCreateQueueBrowser(sess, queue, sel);
    m.setLineNumber(line);
    return m;
  }
}

Any MQSend() :
{
  int line;
  Any destOrProd;
  Any msg;
  Any delMode = null;
  Any priority = null;
  Any ttl = null;
}
{
  "mqsend" { line = token.beginLine; }
  "("
  destOrProd = Expression()
  ","
  msg = Expression()
  ( ","
    delMode = Expression()
    ","
    priority = Expression()
    ","
    ttl = Expression()
  )?
  ")"
  {
    MqSend m = new MqSend(destOrProd,
                          msg,
                          delMode,
                          priority,
                          ttl);
    m.setLineNumber(line);
    return m;
  }
}

Any MQReceive() :
{
  int line;
  Any destOrConsum;
  Any timeout = null;
}
{
  "mqreceive" { line = token.beginLine; }
  "("
  destOrConsum = Expression()
  ( ","
    timeout = Expression()
  )?
  ")"
  {
    MqReceive m = new MqReceive(destOrConsum,
                                timeout);
    m.setLineNumber(line);
    return m;
  }
}

Any MQAcknowledge() :
{
  int line;
  Any message;
}
{
  "mqacknowledge" { line = token.beginLine; }
  "("
  message = Expression()
  ")"
  {
    MqAcknowledge m = new MqAcknowledge(message);
    m.setLineNumber(line);
    return m;
  }
}

Any MQClearMsg() :
{
  int line;
  Any msg;
}
{
  "mqclearmessage" { line = token.beginLine; }
  "("
  msg = Expression()
  ")"
  {
    MqClearMsg m = new MqClearMsg(msg);
    m.setLineNumber(line);
    return m;
  }
}

Any MQReset() :
{
  int line;
  Any msg;
}
{
  "mqresetmessage" { line = token.beginLine; }
  "("
  msg = Expression()
  ")"
  {
    MqReset m = new MqReset(msg);
    m.setLineNumber(line);
    return m;
  }
}

Any MQClose() :
{
  int line;
  Any jms;
}
{
  "mqclose" { line = token.beginLine; }
  "("
  jms = Expression()
  ")"
  {
    MqClose m = new MqClose(jms);
    m.setLineNumber(line);
    return m;
  }
}

Any MQSetCommit() :
{
  int line;
  Any c;
}
{
  "mqsetcommit" { line = token.beginLine; } 
  "("
  c = Expression()
  ")"
  {
    MqSetCommit m = new MqSetCommit(c);
    m.setLineNumber(line);
    return m;
  }
}

Any MkDirs() :
{ Any a; int line; boolean b;}
{
  ( "mkdir" { b = false; line = token.beginLine; }
  | "mkdirs" { b = true; line = token.beginLine; }
  )
  "("
  a = Expression()
  ")"
  {
    MakeDirs m = new MakeDirs(a, b);
    m.setLineNumber(line);
    return m;
  }
}

Any MaxOf() :
{
  Any    root;
  Locate l;
  int    line;
  Any    child = null;
}
{
  "maxof" { line = token.beginLine; }
  "("
  root = Expression()
  ","
  l = NodeRef() { l.setLineNumber(token.beginLine); }
  [ "," "child" "=" child = Expression() ]
  ")"
  {
    MaxOf m = new MaxOf(root, l, child);
    m.setLineNumber(line);

    return m;
  }
}

Any MinOf() :
{
  Any    root;
  Locate l;
  int    line;
  Any    child = null;
}
{
  "minof" { line = token.beginLine; }
  "("
  root = Expression()
  ","
  l = NodeRef() { l.setLineNumber(token.beginLine); }
  [ "," "child" "=" child = Expression() ]
  ")"
  {
    MinOf m = new MinOf(root, l, child);
    m.setLineNumber(line);

    return m;
  }
}

Any FQName() :
{
  Any   expr;
  int   line;
}
{
  "fqname" { line = token.beginLine; } "("
  expr = Expression()
  ")"
  {
    GetFQName g = new GetFQName(expr);
    g.setLineNumber(line);

    return g;
  }
}

/*
Any FileFilter() :
{
  Any        descr      = AnyFileFilter.allFiles__;
  Any        filterExpr = null;
  Any        acceptDirs = AnyBoolean.TRUE;
  String     descrStr   = null;
}
{
  "filefilter"
  "("
  [ descrStr = LiteralAsString()
    [ "," filterExpr = Expression()
      [ "," acceptDirs = Expression()
      ]
    ]
  ]
  ")"
  {
    if (descrStr != null)
      descr = new AnyString(descrStr);

    return new MakeFileFilter(descr, filterExpr, acceptDirs);
  }
}
*/

Any Getdate() :
{ int line; }
{
  "getdate" { line = token.beginLine; } "(" ")"
  {
    GetDate g = new GetDate();
    g.setLineNumber(line);
    return g;
  }
}

Any GetLocalHost() :
{ int line; }
{
  "getlocalhost" { line = token.beginLine; } "(" ")"
  {
    GetLocalHost g = new GetLocalHost();
    g.setLineNumber(line);
    return g;
  }
}

Any Identity() :
{ Any a; int line; }
{
  "identity" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    IdentityOf i = new IdentityOf(a);
    i.setLineNumber(line);
    return i;
  }
}

Any Interrupt() :
{ Any a; int line; }
{
  "interrupt" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    Interrupt i = new Interrupt(a);
    i.setLineNumber(line);
    return i;
  }
}

Any IsEmptyChannel() :
{ Any a; int line; }
{
  "ischannelempty" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    IsEmpty i = new IsEmpty(a);
    i.setLineNumber(line);
    return i;
  }
}

Any SetCompressed() :
{ Any oc; Any mode; int line; }
{
  "setcompressed" { line = token.beginLine; }
  "("
  oc = Expression()
  ","
  mode = Expression()
   ")"
  {
    SetCompression s = new SetCompression(oc, mode);
    s.setLineNumber(line);
    return s;
  }
}

Any IsNull() :
{
  Any a;
  Any v = null;
  int line; }
{
  "isnull" { line = token.beginLine; }
  "("
  a = Expression()
  [ "," v = Expression() ]
  ")"
  {
    IsNull i = new IsNull(a, v);
    i.setLineNumber(line);
    return i;
  }
}

Any GetBlob() :
{ Any a; int line; }
{
  "getblob" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    GetBlob g = new GetBlob(a);
    g.setLineNumber(line);
    return g;
  }
}

Any GetCurrentStack() :
{ Any a; int line; }
{
  "getcurrentstack" { line = token.beginLine; }
  "(" ")"
  {
    GetCurrentStack g = new GetCurrentStack();
    g.setLineNumber(line);
    return g;
  }
}

Any Kill() :
{ Any a; int line; }
{
  "kill" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    Kill k = new Kill(a);
    k.setLineNumber(line);
    return k;
  }
}

Any Length() :
{ Any a; int line; }
{
  "length" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    Length l = new Length(a);
    l.setLineNumber(line);
    return l;
  }
}

Any CharAt() :
{ Any str; Any index; int line; }
{
  "charat" { line = token.beginLine; }
  "("
  str = Expression()
  ","
  index = Expression()
  ")"
  {
    CharAt c = new CharAt(str, index);
    c.setLineNumber(line);
    return c;
  }
}

Any Trim() :
{ Any a; int line; }
{
  "trim" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    Trim t = new Trim(a);
    t.setLineNumber(line);
    return t;
  }
}

Any EndsWith() :
{ Any s1; Any s2; int line; }
{
  "endswith" { line = token.beginLine; }
  "("
  s1 = Expression()
  ","
  s2 = Expression()
  ")"
  {
    EndsWith e = new EndsWith(s1, s2);
    e.setLineNumber(line);
    return e;
  }
}

Any StartsWith() :
{ Any s1; Any s2; Any offset = null; int line; }
{
  "startswith" { line = token.beginLine; }
  "("
  s1 = Expression()
  ","
  s2 = Expression()
  [ "," offset = Expression() ]
  ")"
  {
    StartsWith s = new StartsWith(s1, s2, offset);
    s.setLineNumber(line);
    return s;
  }
}

Any StringIndex() :
{ Any container;
  Any contained;
  Any fromIndex = null;
  int line;
}
{
  "strindex" { line = token.beginLine; }
  "("
  container = Expression()
  ","
  contained = Expression()
  [ "," fromIndex = Expression() ]
  ")"
  {
    StringIndex s = new StringIndex(container, contained, fromIndex);
    s.setLineNumber(line);
    return s;
  }
}

Any SubString() :
{
  Any   str;
  Any   beginIndex;
  Any   endIndex = null;
  int   t;
  short mode;
  int   line;
}
{
  ( "leftstring"
  | "midstring"
  | "rightstring"
  ) { line = token.beginLine; t = token.kind; }

  "("
  str = Expression()
  ","
  beginIndex = Expression()
  [ "," endIndex = Expression() ]
  ")"
  {
    switch(t)
    {
      case LEFTSTRING:  mode = SubString.LEFT;  break;
      case MIDSTRING:   mode = SubString.MID;   break;
      case RIGHTSTRING: mode = SubString.RIGHT; break;
      default: mode = SubString.LEFT; // just to shut compiler up
    }

    SubString s = new SubString(str, beginIndex, endIndex, mode);
    s.setLineNumber(line);
    return s;
  }
}

Any Lock() :
{
  Any toLock;
  Any timeout   = null;
  Any condition = null;
  int line;
}
{
  "lock" { line = token.beginLine; }
  "("
  toLock = Expression()
  [ ","
    timeout = Expression()
    [ "," condition = Expression() ]
  ]
  ")"
  {
    Lock l = new Lock(toLock, timeout, condition);
    l.setLineNumber(line);
    return l;
  }
}

Any Layout() :
{
  Any components;
  Any inqRoot;
  Any awtRoot;
  Any layoutString = null;
  Any rootName     = null;
  int line;
}
{
  "layout"  { line = token.beginLine; }
  "("
  components = Expression()
  ","
  inqRoot    = Expression()
  ","
  awtRoot    = Expression()
  [ "," rootName = Expression() [ "," layoutString = Expression() ] ]
  ")"
  {
    // 3, 4 or 5 args are possible
    if (layoutString == null && rootName == null)
    {
      layoutString = awtRoot;
      awtRoot      = null;
    }
    else if (layoutString == null)
    {
      layoutString = rootName;
      rootName     = null;
    }
    Layout l = new Layout(components, inqRoot, awtRoot, rootName, layoutString);
    l.setLineNumber(line);
    return l;
  }
}

Any DoDocLayout() :
{ Any doc; Any layoutString; int line; }
{
  "doclayout" { line = token.beginLine; }
  "("
  doc = Expression()
  ","
  layoutString = Expression()
  ")"
  {
    LayoutDoc l = new LayoutDoc(doc, layoutString);
    l.setLineNumber(line);
    return l;
  }
}

Any Login() :
{
  Any user;
  Any password;
  Any pkg;
  Any url;
  Any srv;
  Any cert;
  Any ignoreExp;
  Any exit;
  int line;
}
{
  "serverlogin" { line = token.beginLine; }
  "("
  user      = Expression()
  ","
  password  = Expression()
  ","
  pkg       = Expression()
  ","
  url       = Expression()
  ","
  srv       = Expression()
  ","
  cert      = Expression()
  ","
  ignoreExp = Expression()
  ","
  exit      = Expression()
  ")"
  {
    Login l = new Login(user, password, pkg, url, srv, cert, ignoreExp, exit);
    l.setLineNumber(line);
    return l;
  }
}

Any LoadClient() :
{ Any source; Any sync = null; int line; }
{
  "loadclient" { line = token.beginLine; }
  "("
  source = Expression()
  [ "," sync = Expression() ]
  ")"
  {
    LoadClient lc = new LoadClient(source, sync);
    lc.setBaseURL(documentURL_);
    lc.setLineNumber(line);
    return lc;
  }
}

Any LoadServer() :
{ Any source; Any context = null; int line; }
{
  "loadserver" { line = token.beginLine; }
  "("
  source = Expression()
  [ "," context = Expression() ]
  ")"
  {
    LoadServer ls = new LoadServer(source, context);
    ls.setBaseURL(documentURL_);
    ls.setLineNumber(line);
    return ls;
  }
}

Any Add() :
{
  Any node;
  Any path;
  Any raiseEvent = AnyBoolean.TRUE;
  Any proto = null;
  int line;
}
{
  "add" { line = token.beginLine; }
  "("
  node = Expression()
  ","
  path = Expression()
  [ "," raiseEvent = Expression() [ "," proto = Expression() ] ]
  ")"
  {
    AddTo a = new AddTo(node, path, raiseEvent, proto);
    a.setLineNumber(line);
    return a;
  }
}

Any LinkTo() :
{ NodeSpecification node; NodeSpecification path; int line; }
{
  /*
  Path now upgraded - to be fixed
  */
  "linkto" { line = token.beginLine; }
  "("
   ")"
  /*
  "(" node = Path() ","
   path = Path()
   ")"
  {
    LinkTo l = new LinkTo(node, path);
    l.setLineNumber(line);
    return l;
  }
  */
  { return AnyNull.instance(); }
}

Any MaxVal() :
{ Any a; int line; }
{
  "maxval" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    MaxVal m = new MaxVal(a);
    m.setLineNumber(line);
    return m;
  }
}

Any MinVal() :
{ Any a; int line; }
{
  "minval" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    MinVal m = new MinVal(a);
    m.setLineNumber(line);

    return m;
  }
}

Any Max() :
{ Any op1; Any op2; int line; }
{
  "max" { line = token.beginLine; }
  "("
  op1 = Expression()
  ","
  op2 = Expression()
  ")"
  {
    Func m = new EvalExpr(op1, op2, new Max());
    m.setLineNumber(line);
    return m;
  }
}

Any Min() :
{ Any op1; Any op2; int line; }
{
  "min" { line = token.beginLine; }
  "("
  op1 = Expression()
  ","
  op2 = Expression()
  ")"
  {
    Func m = new EvalExpr(op1, op2, new Min());
    m.setLineNumber(line);
    return m;
  }
}

Any Merge() :
{ Any mergeTo; Any mergeFrom; int line; }
{
  "merge" { line = token.beginLine; }
  "("
  mergeTo = Expression()
  ","
  mergeFrom = Expression()
  ")"
  {
    Merge m = new Merge(mergeTo, mergeFrom);
    m.setLineNumber(line);

    return m;
  }
}

Any New() :
{
  String            packageOverride = _package;
  String            typeName = null;
  String            fieldName = null;
  Any               initVal = null;
  Any               getType = null;
  int               line;
}
{
  "new" { line = token.beginLine; }
  "("
  ( ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
      typeName = FieldImport() { fieldName = token.image; }
    )
  | getType = GetType()
  )
  [ "," initVal = Expression() ]
  ")"
  {
    NewInstance ret;
    if (getType != null)
    {
      ret = new NewInstance(getType, initVal);
    }
    else
    {
      Locate l;
      ret = new NewInstance(l = new LocateNode("$catalog." + packageOverride + ".types." + typeName), initVal);
      l.setLineNumber(line);

      if (fieldName != typeName)
      {
        // Slightly bodgy but means we specified a particular field within
        // an structure type.  This facility means we can make simple variables
        // from fields of existing types without having to know what fundamental
        // type we are creating.  Doesn't affect Native typedefs because the
        // result is the same.
        ret.setField(AbstractValue.flyweightString(fieldName));
      }
    }
    ret.setLineNumber(line);
    return ret;
  }
}

Any IsInstance() :
{
  String            packageOverride = _package;
  String            botName;
  Any               instance;
  int               line;
}
{
  "isinstance" { line = token.beginLine; }
  "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { botName = token.image; }
  ","
  instance = Expression()
  ")"
  {
    Locate l;
    IsInstance i = new IsInstance(l = new LocateNode("$catalog." + packageOverride + ".types." + botName), instance);
    i.setLineNumber(line);
    l.setLineNumber(line);
    return i;
  }
}

Any CloneMe() :
{
  Any     toClone;
  Any     copyFrom = null;
  String  typPackageOverride = _package;
  String  typ                = null;
  String  field              = null;
  int     line;
}
{
  // clone the single operand, which can be an expression or a typedef field
  "clone" { line = token.beginLine; }
  "("
  toClone = Expression()
  [ "," copyFrom = Expression() ]
  ")"
  {
    Clone c =  new Clone(toClone, copyFrom);
    c.setLineNumber(line);
    return c;
  }
}

Any Path() :
{ Locate l; }
{
  "path" "(" l = NodeRef() ")"
//  { return l.getNodePath(); }
  {
    MakePath m = new MakePath(l.getNodePath());
    m.setLineNumber(token.beginLine);
    return m;
  }
}

Any Read() :
{
  String            packageOverride = _package;
  String            botName = null;
  Any               keyVal;
  Any               readArg;
  Any               getType = null;
  Read              read;
  Token             t;
  int               line;
}
{
  "read" "(" { line = token.beginLine; }
  ( ( [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
      <IDENTIFIER> { botName = token.image; }
    )
  | getType = GetType()
  )
  ","
  keyVal = Expression()
  {
    if (getType == null)
    {
      Locate l;
      read = new Read(l = new LocateNode("$catalog." + packageOverride + ".types." + botName), keyVal);
      l.setLineNumber(line);
    }
    else
    {
      read = new Read(getType, keyVal);
    }
    read.setKeyName(KeyDef.defaultKey__);
    read.setTarget(defaultTarget__);
    read.setLineNumber(line);
  }
  ( "," ( t = <KEYNAME>
        | t = <TARGET>
        | t = <SETNAME>
        | t = <ROWNAME>
        | t = <ALIAS>
        | t = <MERGE>
        | t = <CHILD>
        | t = <MAX>
        )
        "="
    readArg = Expression()
    {
      switch(t.kind)
      {
        case KEYNAME: read.setKeyName(readArg);  break;
        case TARGET:  read.setTarget(readArg);   break;
        case ROWNAME: read.setRowAlias(readArg); break;
        case SETNAME: read.setSetAlias(readArg); break;
        case ALIAS:   read.setTypedefAlias(readArg); break;
        case MERGE:   read.setMerge(readArg); break;
        case CHILD:   read.setChild(readArg); break;
        case MAX:     read.setMaxCount(readArg); break;
      }
    }
  )*
  ")"
  {
    return read;
  }
}

Any Resync() :
{
  String            packageOverride = _package;
  String            botName;
  Any               keyVal;
  int               line;
}
{
  "resync" { line = token.beginLine; }
  "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { botName = token.image; } ","
  keyVal = Expression()
  ")"
  {
    Locate l;
    Resync r = new Resync(l = new LocateNode("$catalog." + packageOverride + ".types." + botName), keyVal);
    r.setLineNumber(line);
    l.setLineNumber(line);
    return r;
  }
}

Any Aggregate() :
{
  String            packageOverride = _package;
  String            botName;
  Locate            instVal;
  Any               aggArg;
  Aggregate         agg;
  int               attrKind;
  int               line;
}
{
  "aggregate" { line = token.beginLine; } "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { botName = token.image; } ","
  instVal = NodeRef()
  {
    Locate l;
    agg = new Aggregate(instVal,
                        l = new LocateNode("$catalog." + packageOverride + ".types." + botName));
    agg.setKeyName(KeyDef.defaultKey__);
    agg.setLineNumber(line);
    l.setLineNumber(line);
  }
  ( "," ( "keyname"
        | "setname"
        | "alias"
        | "map"
        | "mustjoin"
        | "key"
        | "foreach"
        | "rowname"
        | "max"
        )
        { attrKind = token.kind; }
    "="
    aggArg = Expression()
    {
      switch(attrKind)
      {
        case KEYNAME:  agg.setKeyName(aggArg);  break;
        case SETNAME:  agg.setSetAlias(aggArg); break;
        case ALIAS:    agg.setTypedefAlias(aggArg); break;
        case MAP:      agg.setKeyMap(aggArg); break;
        case MUSTJOIN: agg.setMustJoin(aggArg); break;
        case KEY:      agg.setKey(aggArg); break;
        case FOREACH:  agg.setForeach(aggArg); break;
        case ROWNAME:  agg.setRowName(aggArg); break;
        case MAX:      agg.setMaxCount(aggArg); break;
      }
    }
  )*
  ")"
  {
    return agg;
  }
}

Any Open() :
{ Any stream; Any what; Any mode; int line; }
{
  "open" { line = token.beginLine; }
  "("
  stream = Expression() ","
  what   = Expression() ","
  mode   = IOOpenConstants()
  ")"
  {
    Open o = new Open(stream, what, mode);
    o.setLineNumber(line);
    return o;
  }
}

Any Close() :
{ Any stream; int line; }
{
  "close" { line = token.beginLine; }
  "("
  stream = Expression()
  ")"
  {
    Close c = new Close(stream);
    c.setLineNumber(line);
    return c;
  }
}

Any Accept() :
{ Any serverSocket; Any ioStream; int line; }
{
  "accept" { line = token.beginLine; }
  "("
  serverSocket = Expression()
  ","
  ioStream = Expression()
  ")"
  {
    Accept aa = new Accept(serverSocket, ioStream);
    aa.setLineNumber(line);
    return aa;
  }
}

Any Print() :
{ Any toPrint; Any jobAttrs = null; int line; }
{
  "print" { line = token.beginLine; }
  "("
  toPrint   = Expression()
  [ "," jobAttrs = Expression() ]
  ")"
  {
    Print p = new Print(toPrint, jobAttrs);
    p.setLineNumber(line);
    return p;
  }
}

Any Random() :
{
  int line;
  Any type  = null;
  Any range = null;
}
{
  "random" { line = token.beginLine; }
  "("
  [ type = Expression()
    [ "," range = Expression() ]
  ]  
  ")"
  {
    Random r = new Random(type, range);
    r.setLineNumber(line);
    return r;
  }
}


Any ReadStream() :
{ Any a = null; int line; }
{
  "readstream" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    ReadStream r = new ReadStream(a);
    r.setLineNumber(line);
    return r;
  }
}

Any SetNull() :
{ Locate l; int line; }
{
  "setnull" { line = token.beginLine; }
  "(" l = NodeRef() ")"
  {
    SetNull s = new SetNull(l);
    s.setLineNumber(line);
    return s;
  }
}

Any SetBlob() :
{ Locate l; Any val; int line; }
{
  "setblob" { line = token.beginLine; }
  "("
  l = NodeRef()
  ","
  val = Expression()
  ")"
  {
    SetBlob s = new SetBlob(l, val);
    s.setLineNumber(line);
    return s;
  }
}

Any SetEntryLogging() :
{
  String    entity;
  String    special  = null;
  Any       aSpecial = null;
  String    packageOverride  = _package;
  BooleanI  logged;
  int       line;
}
{
  "setentrylogging" { line = token.beginLine; }
  "("
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  ( <IDENTIFIER> { entity = token.image; } )
  ","
  ( ( ( "construct"  { special = token.image; }
      | "join"       { special = token.image; }
      | "mutate"     { special = token.image; }
      | "destroy"    { special = token.image; }
      ) { aSpecial = AbstractValue.flyweightString(special); }
      "," logged = BooleanLiteralAsAny()
    )
    |
    logged = BooleanLiteralAsAny()
  )
  ")"
  {
    Any aEntity;
    Any aPkg;

    if (entity.equals("all"))
      aEntity = AnyAlwaysEquals.instance();
    else
    {
      if (aSpecial == null)
        aEntity = AbstractValue.flyweightString(entity);
      else
        aEntity = aSpecial;
    }
    
    if (packageOverride.equals("all"))
      aPkg = AnyAlwaysEquals.instance();
    else
    {
      if (aSpecial == null)
        aPkg = AbstractValue.flyweightString(packageOverride);
      else
        aPkg = AbstractValue.flyweightString(packageOverride + ".types." + entity);
    }
    
    SetEntryLogging s = new SetEntryLogging(aPkg, aEntity, logged.getValue());
    s.setLineNumber(line);
    return s;
  }
}

Any Show() :
{ Any win; Any withResize = null; Any relativeTo = null; int line; }
{
  "show" { line = token.beginLine; }
  "(" win = Expression()
   //[ "," withResize = Expression() ]
   ( ","
     (
       ( "resize" "=" withResize = Expression() )
       |
       ( "target" "=" relativeTo = Expression() )
     )
   )*
   ")"
  {
    Show s = new Show(win, withResize, relativeTo);
    s.setLineNumber(line);
    return s;
  }
}

Any Hide() :
{ Any win; int line; }
{
  "hide" { line = token.beginLine; } "(" win = Expression()
         ")"
  {
    Hide h = new Hide(win);
    h.setLineNumber(line);
    return h;
  }
}

Any ToFront() :
{ Any win; int line; }
{
  "tofront" { line = token.beginLine; }
  "(" win = Expression()
  ")"
  {
    ToFront t = new ToFront(win);
    t.setLineNumber(line);
    return t;
  }
}

Any Reverse() :
{
  Any toRev;
  int line;
}
{
  "reverse" { line = token.beginLine; }
  "("
  toRev = Expression()
  ")"
  {
    Reverse r = new Reverse(toRev);

    r.setLineNumber(line);

    return r;
  }
}

Any Sort() :
{
  Any toSort;
  Array sortBy   = null;
  Any sortNode   = null;
  Any descending = null;
  Any ignorecase = null;
  Any nullExpr   = null;
  int line;
}
{
  "sort" { line = token.beginLine; }
  "("
  toSort = Expression()
  // We're reusing the "null" keyword so the grammar has to be
  // a bit creative, given that what we really want is just
  // expressions. Means that null = xxx can appear amid the
  // sort expressions. Never mind.
  ( LOOKAHEAD(2)
    "," ( LOOKAHEAD("null") ( "null" "=" nullExpr = Expression() )
        | sortNode = Expression()
          {
            if (sortBy == null)
              sortBy = AbstractComposite.array();
            sortBy.add(sortNode);
          }
        )
  )+
  ( "," ( ( "descending" "=" descending = Expression() )
        | ( "ignorecase" "=" ignorecase = Expression() )
        //| ( "null"       "=" nullExpr   = Expression() )
        )
  )*
  ")"
  {
    OrderBy o = new OrderBy(toSort, sortBy);
    if (descending != null)
      o.setDescending(descending);
    if (ignorecase != null)
      o.setIgnoreCase(ignorecase);
    if (nullExpr != null)
      o.setNullMode(nullExpr);
    o.setLineNumber(line);
    return o;
  }
}

Any Spawn() :
{
  Any   pName;
  Any   pType         = null;
  Token t;
  Call  callOnStart   = null;
  Call  callOnEnd     = null;
  Any   inputChannel  = null;
  Any   outputChannel = null;
  Any   syncExt       = null;
  int   line;
}
{
  "spawn" { line = token.beginLine; }
  "("
  pName = Expression()
  // This bit is old syntax - to be removed...
  [ LOOKAHEAD(2) ","
    ( "detached" | "child" ) { switch(token.kind)
                               {
                                 case DETACHED: pType = Process.DETACHED; break;
                                 case CHILD:    pType = Process.CHILD;    break;
                               }
                             }
  ]
  (","   ( "start"   "=" { callOnStart   = Call(); }
         | "end"     "=" { callOnEnd     = Call(); }
         | "input"   "=" { inputChannel  = Expression(); }
         | "output"  "=" { outputChannel = Expression(); }
         | "type"    "=" { pType         = Expression(); }
         | "syncext" "=" { syncExt       = Expression(); }
         )
  )*
  ")"
  {
    if (pName == null || pType == null)
      throw new AnyRuntimeException("name or type missing");

    SpawnProcess s = new SpawnProcess(pName,
                                      pType,
                                      inputChannel,
                                      outputChannel,
                                      callOnStart,
                                      callOnEnd,
                                      syncExt);
    s.setLineNumber(line);
    return s;
  }
}

Any Split() :
{ Any toSplit; Any regex; Any limit = null; int line; }
{
  "split" { line = token.beginLine; }
  "("
  toSplit = Expression()
  ","
  regex = Expression()
  [ "," limit = Expression() ]
  ")"
  {
    Split s = new Split(toSplit, regex, limit);
    s.setLineNumber(line);
    return s;
  }
}

Any Sub() :
{ Any replWith; Any regex; Any replIn = null; Token t; int line; }
{
  ( t = <SUB> | t = <GSUB> )  { line = token.beginLine; }
  "("
  replWith = Expression()
  ","
  regex = Expression()
  [ "," replIn = Expression() ]
  ")"
  {
    RegexSub r = new RegexSub(replWith, replIn, regex);

    if (t.kind == GSUB)
      r.setReplaceAll(true);

    r.setLineNumber(line);
    return r;
  }
}

Any StackTrace() :
{ }
{
  "stacktrace" "(" ")"
  {
    return new StackTrace();
  }
}

Any System() :
{
  Any cmd;
  Any cmdOutput = null;
  Any cmdError  = null;
  Any cmdInput  = null;
  Any wait      = null;
  int line;
}
{
  "syscmd" { line = token.beginLine; }
  "(" cmd = Expression()
      ( "," ( ( "wait"   "=" wait = Expression() )
            | ( "stdout" "=" cmdOutput = Expression() )
            | ( "stderr" "=" cmdError  = Expression() )
            | ( "stdin"  "=" cmdInput  = Expression() )
            )
      )*
  ")"
  {
    SystemCmd s = new SystemCmd(cmd, cmdOutput, cmdError, cmdInput, wait);
    s.setLineNumber(line);
    return s;
  }
}

Any SendMail() :
{ Any mailInfo; int line; }
{
  "sendmail" { line = token.beginLine; }
  "(" mailInfo = Expression() ")"
  {
    SendMail s = new SendMail(mailInfo);
    s.setLineNumber(line);
    return s;
  }
}

Any SysPrint() :
{
  Any f;
  int line;
}
{
  "sysprint" { line = token.beginLine; }
  "(" f = Expression() ")"
  {
    SysPrint s = new SysPrint(f);
    s.setLineNumber(line);
    return s;
  }
}

Any SysOpen() :
{
  Any f;
  int line;
}
{
  "sysopen" { line = token.beginLine; }
  "(" f = Expression() ")"
  {
    SysOpen s = new SysOpen(f);
    s.setLineNumber(line);
    return s;
  }
}

Any WaitProc() :
{ Any proc; Any timeout = null; int line; }
{
  "waitproc" { line = token.beginLine; }
  "("
  proc = Expression()
  [ "," timeout = Expression() ]
  ")"
  {
    WaitProc w = new WaitProc(proc, timeout);
    w.setLineNumber(line);
    return w;
  }
}

Any Wait() :
{ Any a; Any timeout = null; int line; }
{
  "wait" { line = token.beginLine; }
  "("
  a = Expression()
  [ "," timeout = Expression() ]
  ")"
  {
    Wait w = new Wait(a, timeout);
    w.setLineNumber(line);
    return w;
  }
}

Any Notify() :
{
  Any a;
  Any expression = null;
  int line;
  boolean all = false;
}
{
  ( "notify" | "notifyall" { all = true;} ) { line = token.beginLine; }
  "("
  a = Expression()
  [ "," expression = Expression() ]
  ")"
  {
    Notify n = new Notify(a, expression, all);
    n.setLineNumber(line);
    return n;
  }
}

Any ToLower() :
{ Any s; int line; }
{
  "tolower" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    ToLower t = new ToLower(s);
    t.setLineNumber(line);
    return t;
  }
}

Any ToUpper() :
{ Any s; int line; }
{
  "toupper" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    ToUpper t = new ToUpper(s);
    t.setLineNumber(line);
    return t;
  }
}

Any IsDigit() :
{ Any s; int line; }
{
  "isdigit" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsDigit i = new IsDigit(s);
    i.setLineNumber(line);
    return i;
  }
}

Any IsLetter() :
{ Any s; int line; }
{
  "isletter" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsLetter i = new IsLetter(s);
    i.setLineNumber(line);
    return i;
  }
}

Any IsLetterOrDigit() :
{ Any s; int line; }
{
  "isletterordigit" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsLetterOrDigit i = new IsLetterOrDigit(s);
    i.setLineNumber(line);
    return i;
  }
}

Any IsLowerCase() :
{ Any s; int line; }
{
  "islowercase" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsLowerCase i = new IsLowerCase(s);
    i.setLineNumber(line);
    return i;
  }
}

Any IsUpperCase() :
{ Any s; int line; }
{
  "isuppercase" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsUpperCase i = new IsUpperCase(s);
    i.setLineNumber(line);
    return i;
  }
}

Any IsSpace() :
{ Any s; int line; }
{
  "isspace" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsSpaceChar i = new IsSpaceChar(s);
    i.setLineNumber(line);
    return i;
  }
}

Any IsWhiteSpace() :
{ Any s; int line; }
{
  "iswhitespace" { line = token.beginLine; }
  "("
  s = Expression()
  ")"
  {
    IsWhiteSpace i = new IsWhiteSpace(s);
    i.setLineNumber(line);
    return i;
  }
}

Any Throw() :
{
  Any msg      = null;
  Any userInfo = null;
  Any handler  = null;
  int line;
}
{
  "throw" { line = token.beginLine; }
  "("
  [
    msg = Expression()
    [
      "," userInfo = Expression()
      [
        "," handler = Expression()
      ]
    ]
  ]
  ")"
  {
    Throw t = new Throw(msg, userInfo, handler);
    t.setLineNumber(line);
    return t;
  }
}

Any Try() :
{
  Any     aTry;
  Any     aCatch   = null;
  Any     aFinally = null;
  boolean nested   = false;
  Any     create   = null;
  int     line;
}
{
  ( "try"
    |
    ( "transaction" { nested = true; }
      [ ( "("
          "create" "=" create = Expression()
          ")"
        )
      ]
    )
  )
  { line = token.beginLine; }
  aTry = Block()
  [ "catch"   aCatch   = Block() ]
  [ "finally" aFinally = Block() ]
  {
    if (!nested && aCatch == null && aFinally == null)
      throw new AnyRuntimeException("try without catch or finally at line " + line);

    Try t;
    if (nested)
      t = new TxnBlock(create, aTry, aCatch, aFinally);
    else
      t = new Try(aTry, aCatch, aFinally);

    t.setLineNumber(line);
    return t;
  }
}

Any Unlock() :
{ Any a; int line; }
{
  "unlock" { line = token.beginLine; }
  "(" a = Expression() ")"
  {
    Unlock u = new Unlock(a);
    u.setLineNumber(line);
    return u;
  }
}

Any WriteLn() :
{
  Array args = AbstractComposite.array();
  Any   stream;
  Any   arg;
  int   line;
}
{
  "writeln" { line = token.beginLine; }
  "("
  stream = Expression()
  ("," arg = Expression() { args.add(arg); } )+
  ")"
  {
    WriteStream w;
    if (args.entries() == 1)
      w = new WriteStream(stream, args.get(0));
    else
      w = new WriteStream(stream, args);

    w.setLn(true);
    w.setLineNumber(line);
    return w;
  }
}

Any WriteStream() :
{
  Array args = AbstractComposite.array();
  Any stream;
  Any arg;
  int line;
}
{
  "writestream" { line = token.beginLine; }
  "("
  stream = Expression()
  ("," arg = Expression() { args.add(arg); } )+
  ")"
  {
    WriteStream w;
    if (args.entries() == 1)
      w = new WriteStream(stream, args.get(0));
    else
      w = new WriteStream(stream, args);

    w.setLineNumber(line);
    return w;
  }
}

Any Remove() : // Note order of args in script is different to code to reflect likely usage
{ Any node; Any key = null; Any raiseEvent = AnyBoolean.TRUE; int line; }
{
  "remove" { line = token.beginLine; }
  "(" node = Expression()
           [ "," raiseEvent = Expression() [ "," key = Expression() ] ]
       ")"
  {
    RemoveFrom r = new RemoveFrom(node, key, raiseEvent);
    r.setLineNumber(line);
    return r;
  }
}

Any RemoveAll() :
{ Any c1; Any c2; int line; }
{
  "removeall" { line = token.beginLine; }
  "(" c1 = Expression() "," c2 = Expression() ")"
  {
    RemoveAll r = new RemoveAll (c1, c2);
    r.setLineNumber(line);
    return r;
  }
}

Any RemoveIter() :
{ BooleanI raiseEvent = AnyBoolean.TRUE; int line; }
{
  "removeiter" { line = token.beginLine; }
  "("
  [ raiseEvent = BooleanLiteralAsAny() ]
  ")"
  {
    RemoveFrom r = new RemoveFrom();
    r.setRaiseEvent(raiseEvent.getValue());
    r.setIterMode(true);
    r.setLineNumber(line);
    return r;
  }
}

Any RenameFile() :
{ Any from; Any to; int line; }
{
  "renamefile" { line = token.beginLine; }
  "("
  from = Expression()
  ","
  to = Expression()
  ")"
  {
    RenameFile r = new RenameFile(from, to);
    r.setLineNumber(line);
    return r;
  }
}

Any RetainAll() :
{ Any c1; Any c2; int line; }
{
  "retainall" { line = token.beginLine; }
  "(" c1 = Expression() "," c2 = Expression() ")"
  {
    RetainAll r = new RetainAll(c1, c2);
    r.setLineNumber(line);
    return r;
  }
}

Any Render() :
{
  Any     a;
  Any     format = null;
  String  typPackageOverride = _package;
  String  typ                = null;
  String  field              = null;
  int     line;
}
{
  "render" { line = token.beginLine; }
  "("
  a = Expression()
  ( LOOKAHEAD(2) ","
    (
      ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
                      typ = FieldImport() { field = token.image; } )
      | ( "format"   "=" format = Expression() )
    )
  )*
  ")"
  {
    Locate typeRef = null;
    if (typ != null)
    {
      typeRef = new LocateNode("$catalog." + typPackageOverride + ".types." + typ);
      typeRef.setLineNumber(line);
    }

    // Generally there will be either a typeRef (from which a format string
    // will be obtained) or an explicit format string.  Latter takes precedence

    Render r = new Render(a,
                          typeRef,
                          (field != null) ? AbstractValue.flyweightString(field)
                                          : null,
                          format);
    r.setLineNumber(line);

    return r;
  }
}

Any RenderF() :
{
  Any     format;
  Array   values = AbstractComposite.array();
  Any     value;
  int     line;
}
{
  "renderf" { line = token.beginLine; }
  "("
  format = Expression()
  ","
  ( value = Expression() { values.add(value); }
    (
      ","
      value = Expression() { values.add(value); }
    )*
  )
  ")"
  {
    RenderF r = new RenderF(format, values);
    r.setLineNumber(line);

    return r;
  }
}

Any Format() :
{
  Any formatStr;
  Any anyType;
  int line;
}
{
  "format" { line = token.beginLine; }
  "("
  formatStr = Expression()
  ","
  anyType = Expression()
  ")"
  {
    MakeFormatter f = new MakeFormatter(formatStr, anyType);
    return f;
  }
}

Any Parse() :
{
  Any toParse;
  Any formatter;
  Any result;
  Any silent = null;
  int line;
}
{
  "parse" { line = token.beginLine; }
  "("
  toParse   = Expression() ","
  formatter = Expression() ","
  result    = Expression()
  [ "," silent = Expression() ]
  ")"
  {
    Parse p = new Parse(toParse, formatter, result, silent);
    p.setLineNumber(line);
    return p;
  }
}

Any RenderInfo() :
{
  MakeRenderInfo r;
  int            line;
}
{
  "renderinfo" { line = token.beginLine; }
  "("
  r = AnyRenderInfo()
  ")"
  {
    r.setLineNumber(line);
    return r;
  }
}

/*
RenderInfo AnyRenderInfo() :
{
  Any        toRender           = null;
  Locate     responsible        = null;
  String     typPackageOverride = _package;
  String     typ                = null;
  String     field              = null;
  String     format             = null;
  String     label              = null;
  String     width              = null;
  Any        data               = null;
  AnyBoolean always             = new AnyBoolean(false);
  AnyBoolean editable           = new AnyBoolean(false);
}
{

  (LOOKAHEAD(3) toRender = Expression()
    | ( "data"    "=" responsible = NodeRef() )
    | ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
                      typ = FieldImport() { field = token.image; } )
    | ( "format"   "=" <STRING_LITERAL>  { format = token.image; } )
    | ( "label"    "=" <STRING_LITERAL>  { label  = token.image; } )
    | ( "width"    "=" <INTEGER_LITERAL> { width  = token.image; } )
    | ( "type"     "=" data     = MakeAny() )
    | ( "always"   "=" always   = BooleanLiteralAsAny() )
    | ( "editable" "=" editable = BooleanLiteralAsAny() )
  )
  ("," ( ( "data"    "=" responsible = NodeRef() )
       | ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
                         typ = FieldImport() { field = token.image; } )
       | ( "format"   "=" <STRING_LITERAL>  { format = token.image; } )
       | ( "label"    "=" <STRING_LITERAL>  { label  = token.image; } )
       | ( "width"    "=" <INTEGER_LITERAL> { width  = token.image; } )
       | ( "type"     "=" data     = MakeAny() )
       | ( "always"   "=" always   = BooleanLiteralAsAny() )
       | ( "editable" "=" editable = BooleanLiteralAsAny() )
       )
  )*
  {
    AnyRenderInfo ari = new AnyRenderInfo(toRender);

    try
    {
      ari.setEditable(editable.getValue());

      if (format != null)
        ari.setFormat(processStringEscapes(format.substring(1, format.length()-1)));

      if (field != null)
        ari.setField(field);

      if (data != null)
        ari.setData(data);

      if (label != null)
        ari.setLabel(processStringEscapes(label.substring(1, label.length()-1)));

      if (always != null)
        ari.setAlwaysEvaluate(always.getValue());

      if (width != null)
      {
        IntI aw = new ConstInt(width);
        ari.setWidth(aw.getValue());
      }

      if (typ != null)
        ari.setFQName(typPackageOverride + ".types." + typ);

      if (responsible != null)
        ari.setResponsibleData(responsible);
    }
    catch(AnyException x)
    {
      throw new RuntimeContainedException(x);
    }

    return ari;
  }
}
*/

MakeRenderInfo AnyRenderInfo() :
{
  Any        toRender           = null;
  Locate     responsible        = null;
  String     typPackageOverride = _package;
  String     typ                = null;
  String     field              = null;
  Any        format             = null;
  Any        label              = null;
  Any        width              = null;
  Any        data               = null;
  Any        always             = null;
  Any        editable           = null;
  Any        getType            = null;
  Any        fieldAny           = null;
}
{

  (LOOKAHEAD(3) toRender = Expression()
    | ( "data"    "=" responsible = NodeRef() )
    //| ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
    //                  typ = FieldImport() { field = token.image; } )
    | ( ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
                        typ = FieldImport() { field = token.image; } )
        |
        ( "typeof" "=" "(" getType = Expression() "," fieldAny = Expression() ")" )
        //( getType = GetType() "," fieldAny = Expression() )
      )
    | ( "format"   "=" format = Expression() )
    | ( "label"    "=" label = Expression() )
    | ( "width"    "=" width = Expression() )
    | ( "type"     "=" data     = MakeAny() )
    | ( "always"   "=" always   = Expression() )
    | ( "editable" "=" editable = Expression() )
  )
  ("," ( ( "data"    "=" responsible = NodeRef() )
       | ( ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
                            typ = FieldImport() { field = token.image; } )
           |
           ( "typeof" "=" "(" getType = Expression() "," fieldAny = Expression() ")" )
           //( getType = GetType() "," fieldAny = Expression() )
         )
       | ( "format"   "=" format = Expression() )
       | ( "label"    "=" label = Expression() )
       | ( "width"    "=" width = Expression() )
       | ( "type"     "=" data     = MakeAny() )
       | ( "always"   "=" always   = Expression() )
       | ( "editable" "=" editable = Expression() )
       )
  )*
  {
//    if (typ == null && toRender == null)
//      throw new AnyRuntimeException("renderinfo has no expression and no typedef/field at line " + token.beginLine);
    
    String fQName = null;
    if (typ != null)
      fQName = typPackageOverride + ".types." + typ;

    MakeRenderInfo mri;

    if (getType != null)
    {
      GetType gt = new GetType(getType);
      if (getType instanceof Func)
        gt.setLineNumber(((Func)getType).getLineNumber());
      mri = new DynamicMakeRenderInfo(gt, fieldAny,
                                      toRender,
                                      responsible,
                                      fQName,
                                      field,
                                      format,
                                      label,
                                      width,
                                      data,
                                      always,
                                      editable);
    }
    else
      mri = new MakeRenderInfo(toRender,
                               responsible,
                               fQName,
                               field,
                               format,
                               label,
                               width,
                               data,
                               always,
                               editable);


    return mri;
  }
}

Any SetUniqueKey() :
{ Any node; Any key; int line; }
{
  "setuniquekey" { line = token.beginLine; }
  "(" node = Expression() "," key = Expression() ")"
  {
    SetUniqueKey s = new SetUniqueKey (node, key);
    s.setLineNumber(line);
    return s;
  }
}

Any SetNodeSet() :
{ Any node; Any nodeSet; int line; }
{
  "setnodeset" { line = token.beginLine; }
  "(" node = Expression() "," nodeSet = Expression() ")"
  {
    SetNodeSet s = new SetNodeSet (node, nodeSet);
    s.setLineNumber(line);
    return s;
  }
}

Any GetNodeSet() :
{ Any node; Any nodeSet; int line; }
{
  "getnodeset" { line = token.beginLine; }
  "(" node = Expression() ")"
  {
    GetNodeSet g = new GetNodeSet (node);
    g.setLineNumber(line);
    return g;
  }
}

Any GetDesktop() :
{ int line; }
{
  "getdesktop" { line = token.beginLine; }
  "("
  ")"
  {
    GetDesktopState g = new GetDesktopState();
    g.setLineNumber(line);
    return g;
  }
}

Any SetDesktop() :
{ Any state; int line; }
{
  "setdesktop" { line = token.beginLine; }
  "(" state = Expression() ")"
  {
    SetDesktopState s = new SetDesktopState(state);
    s.setLineNumber(line);
    return s;
  }
}

Any GetUniqueKey() :
{ Any node; int line; }
{
  ( "getuniquekey"
  | "getprimarykey"
  )
  { line = token.beginLine; } "(" node = Expression() ")"
  {
    GetUniqueKey g = new GetUniqueKey (node);
    g.setLineNumber(line);
    return g;
  }
}

Call Call() :
{
  String  func;
  String  packageOverride  = _package;
  Map     args             = AbstractComposite.simpleMap();
  boolean forceGlobal      = false;
  int     line;
}
{
  "call"  { line = token.beginLine; }
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); forceGlobal = true; } ":" )]
  <IDENTIFIER> { func = token.image; }
  "("
  [ CallArg(args) ("," CallArg(args))* ]
  ")"
  {
    if (forceGlobal && packageOverride.equals("global"))
      packageOverride = _package;

    Locate l;
    Call c = new Call(l = new LocateNode("$catalog." + packageOverride + ".exprs." + func),
                    forceGlobal ? null : documentAnyURL_,
                    args);
    c.setLineNumber(line);
    return c;
  }
}

CallMethod CallMethod() :
{
  Any     methodName      = null;
  Any     className       = null;
  Any     instanceExpr    = null;
  Any     arg1            = null;
  Array   args            = AbstractComposite.array();
  int     line;
}
{
  "callmethod" { line = token.beginLine; }
  "("

  (
    LOOKAHEAD(Expression() "," <CLASS>)
    (
      methodName = Expression()
      ","
      <CLASS> "=" className = Expression()
    )
    |
    (
      <CLASS> "=" className = Expression()
    )
    |
    (
      methodName = Expression()
      ","
      ( <INSTANCE> "=" instanceExpr = Expression() )
    )
  )
  [ "," CallMethodArg(args) ("," CallMethodArg(args))* ]

  ")"
  {
    CallMethod c;

    if (methodName == null)
    {
      //System.out.println("ctor version");
      c = new CallMethod(className, args);
    }
    else
    {
      //System.out.println("method version "  + methodName + " " + classOrInstance + " " + isInstance);
      c = new CallMethod(methodName,
                         (className != null) ? className : instanceExpr,
                         args,
                         instanceExpr != null);
    }

    c.setLineNumber(line);

    return c;
  }
}

void CallMethodArg(Array args) :
{ Any a; }
{
  a = Expression() { args.add(a); }
}

Any Listen() :
{
  Any        listenTo;
  String     svcPackageOverride = _package;
  String     packageOverride    = _package;
  String     svc                = null;
  String     typ                = null;
  Array      baseEventTypes     = AbstractComposite.array();
  Set        fieldList          = AbstractComposite.fieldSet();
  Locate     path               = null;
  Any        createData         = null;
  BooleanI   consume            = AnyBoolean.FALSE;
  BooleanI   ignoreOwn          = AnyBoolean.FALSE;
  Map        args               = AbstractComposite.simpleMap();
  Any        func               = null;
  String     eventFunc          = null;
  int        line;
}
{
  "listen" { line = token.beginLine; }
  "("
  listenTo = Expression()
  // Optional (and with required LOOKAHEAD) until service usage is removed
  ","
  (
    (
      "service" "=" [LOOKAHEAD(Name() ":") (Name() { svcPackageOverride = mapImport(token.image); } ":" )]
                    <IDENTIFIER> { svc = token.image; }
      ","
      "event" "=" ListenEventTypeList(baseEventTypes)
      (LOOKAHEAD(2) "," ( ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
                                          <IDENTIFIER> { typ = token.image; } )
                          | ( "fields"  "=" FieldList(fieldList) )
                          | ( "path"    "=" path = NodeRef() )
                          | ( "create"  "=" createData = Expression() )
                          | ( "consume" "=" consume = BooleanLiteralAsAny() )
                        )
      )*
      ("," SRCallArg(args))*
    )
    |
    (
      func = Expression()
      ","
      "event" "=" ListenEventTypeList(baseEventTypes)
      (LOOKAHEAD(2) "," ( ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
                                          <IDENTIFIER> { typ = token.image; } )
                          | ( "exec" "=" [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
                                          <IDENTIFIER> { eventFunc = token.image; } )
                          | ( "fields"    "=" FieldList(fieldList) )
                          | ( "path"      "=" path = NodeRef() )
                          | ( "create"    "=" createData = Expression() )
                          | ( "consume"   "=" consume = BooleanLiteralAsAny() )
                          | ( "ignoreown" "=" ignoreOwn = BooleanLiteralAsAny() )
                        )
      )*
      ("," CallArg(args))*
    )
  )
  ")"
  {
    if (svc != null)
    {
      Locate li;
      SendRequest sr = new SendRequest(new ConstString(svcPackageOverride + ".services." + svc),
                                       (args.entries() != 0) ? args : null,
                                       li = new LocateNode("$root.ichannel"));

      li.setLineNumber(line);
      Descriptor d = null;
      if (typ != null)
        d = new ProxyDescriptor(new ConstString(packageOverride + ".types." + typ));

      // plug in event types
      for (int i = 0; i < baseEventTypes.entries(); i++)
      {
        Any eventType = baseEventTypes.get(i);

        if (complexEvents__.contains(eventType))
          eventType = complexEventType(eventType, path, fieldList, d, null, null);

        sr.addEventType(eventType);
      }

      sr.setPropagateContext(false);
      if (consume.getValue())
        sr.setConsume(true);

      Listen l = new Listen(listenTo, sr);
      l.setCreateData(createData);
      l.setLineNumber(line);
      return l;
    }
    else
    {
      // The "new" listener format. The above block to be retired as and when...

      if (typ != null && eventFunc != null)
        throw new AnyRuntimeException("typedef and exec cannot appear together");

      // May be there is a typedef argument
      Descriptor d = null;
      if (typ != null)
        d = new ProxyDescriptor(new ConstString(packageOverride + ".types." + typ));

      // Note - this is currently ambiguous - a function and a service of the
      // same name both set up to raise events would be indistinguishable.
      // TODO.
      Func f = null;
      if (eventFunc != null)
        f = new ProxyFunc(new ConstString(packageOverride + ":" + eventFunc));

      // Make the event types
      Array eventTypes = AbstractComposite.array();
      for (int i = 0; i < baseEventTypes.entries(); i++)
      {
        Any eventType = baseEventTypes.get(i);

        if (complexEvents__.contains(eventType))
          eventType = complexEventType(eventType, path, fieldList, d, f, null);

        eventTypes.add(eventType);
      }

      ListenTo l = new ListenTo(listenTo,
                                eventTypes,
                                func,
                                (args.entries() != 0) ? args : null,
                                createData);

      if (consume.getValue())
        l.setConsume(true);

      if (ignoreOwn.getValue())
        l.setIgnoreOwn(true);

      l.setLineNumber(line);
      return l;
    }
  }
}

Any UnListen() :
{
  Any listeningTo   = null;
  Any dispatchingTo = null;
  int line;
}
{
  // If the single argument version is used then the argument
  // must in fact be dispatchingTo (returned by the
  // corresponding listen() ). That is we no longer not need
  // to know the node we were originally listen()ing to.
  // The two argument version is maintained for backward
  // compatibility.
  "unlisten" { line = token.beginLine; }
  "("
  listeningTo = Expression()
  (
    ","
    dispatchingTo = Expression()
  )?
  ")"
  {
    UnListen u = new UnListen(listeningTo, dispatchingTo);
    u.setLineNumber(line);
    return u;
  }
}

Any SetEventMask() :
{
  Any        node;
  String     svcPackageOverride = _package;
  String     packageOverride    = _package;
  String     svc                = null;
  String     typ                = null;
  Locate     path               = null;
  Array      baseEventTypes     = AbstractComposite.array();
  Array      eventTypes         = null;
  Set        fieldList          = AbstractComposite.fieldSet();
  int        lineNumber;
}
{
  "seteventmask" { lineNumber = token.beginLine; }
  "("
  node = Expression()
  ","
  (
    Null()
    |
    (
      "event" "=" ListenEventTypeList(baseEventTypes)
      (LOOKAHEAD(2) "," ( ( "typedef" "=" [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
                                          <IDENTIFIER> { typ = token.image; } )
                          | ( "fields"    "=" FieldList(fieldList) )
                          | ( "path"      "=" path = NodeRef() )
                        )
      )*
    )
  )
  ")"
  {
    Descriptor d = null;
    if (typ != null)
      d = new ProxyDescriptor(new ConstString(packageOverride + ".types." + typ));

    // plug in event types
    for (int i = 0; i < baseEventTypes.entries(); i++)
    {
      if (i == 0)
        eventTypes = AbstractComposite.array();

      Any eventType = baseEventTypes.get(i);

      if (complexEvents__.contains(eventType))
        eventType = complexEventType(eventType, path, fieldList, d, null, null);

      eventTypes.add(eventType);
    }

    Any events = (eventTypes == null) ? AnyNull.instance() : eventTypes;

    SetEventMask s = new SetEventMask(node, events);
    s.setLineNumber(lineNumber);

    return s;
  }
}

Any Version() :
{
}
{
  "version" "(" ")"
  {
    return new Version();
  }
}

void ListenEventTypeList(Array eventTypes) :
{
}
{
  "(" ListenEventType(eventTypes) ("," ListenEventType(eventTypes) )* ")"
}

void RaisesEventTypeList(Array eventTypes) :
{
}
{
  "(" RaisesEventType(eventTypes) ("," RaisesEventType(eventTypes) )* ")"
}

void ListenEventType(Array eventTypes) :
{
  Any eventType = null;
}
{
  ( "create"
  | "delete"
  | "add"
  | "expire"
  | "cataloged"
  | "update"
  | "replace"
  | "remove"
  | "start"
  | "complete"
  )
  {
    switch (token.kind)
    {
      case CREATE:    eventType = EventConstants.BOT_CREATE;    break;
      case DELETE:    eventType = EventConstants.BOT_DELETE;    break;
      case ADD:       eventType = EventConstants.NODE_ADDED;    break;
      case EXPIRE:    eventType = EventConstants.BOT_EXPIRE;    break;
      case CATALOGED: eventType = EventConstants.BOT_CATALOGED; break;
      case REPLACE:   eventType = EventConstants.NODE_REPLACED; break;
      case REMOVE:    eventType = EventConstants.NODE_REMOVED;  break;
      case UPDATE:    eventType = EventConstants.BOT_UPDATE;    break;
      case START:     eventType = EventConstants.EXEC_START;    break;
      case COMPLETE:  eventType = EventConstants.EXEC_COMPLETE; break;
    }

    if (eventTypes.indexOf(eventType) < 0)
      eventTypes.add(eventType);
  }
}

void RaisesEventType(Array eventTypes) :
{
  Any eventType = null;
}
{
  // Hmmm, note not all of these are actually supported at the
  // moment, nor will they necessarily be. Use only create, delete
  // and update at the moment
  ( "create"
  | "delete"
  | "add"
  | "expire"
  | "cataloged"
  | "update"
  | "replace"
  | "remove"
  | "any"
  )
  {
    switch (token.kind)
    {
      case CREATE:    eventType = EventConstants.BOT_CREATE;    break;
      case DELETE:    eventType = EventConstants.BOT_DELETE;    break;
      case ADD:       eventType = EventConstants.NODE_ADDED;    break;
      case EXPIRE:    eventType = EventConstants.BOT_EXPIRE;    break;
      case CATALOGED: eventType = EventConstants.BOT_CATALOGED; break;
      case REPLACE:   eventType = EventConstants.NODE_REPLACED; break;
      case REMOVE:    eventType = EventConstants.NODE_REMOVED;  break;
      case UPDATE:    eventType = EventConstants.BOT_UPDATE;    break;
      case ANY:       eventType = EventConstants.ANY_TYPE;      break;
    }

    if (eventType.equals(EventConstants.ANY_TYPE) && eventTypes.entries() != 0)
      throw new AnyRuntimeException("Cannot mix \"any\" with specific event types");

    if (eventTypes.indexOf(eventType) < 0)
      eventTypes.add(eventType);
  }
}

void FieldList(Set fieldList) :
{}
{
  "(" EventField(fieldList) ("," EventField(fieldList) )* ")"
}

void EventField(Set fieldList) :
{ Any field; }
{
  <IDENTIFIER>
  {
    field = AbstractValue.flyweightString(token.image);
    if (!fieldList.contains(field))
      fieldList.add(field);
  }
}

Any Xfunc() :
{
  Any    a;
  Map    args = AbstractComposite.simpleMap();
  int    line;
}
{
  "xfunc" { line = token.beginLine; }
  "(" a = Expression()
  ("," CallArg(args))*
  ")"
  {
    ExecFuncHolder x  = new ExecFuncHolder(a, args);
    x.setLineNumber(line);
    return x;
  }
}

Any SetExceptionHandler() :
{
  Any f;
  int line;
}
{
  "setexceptionhandler" { line = token.beginLine; }
  "("
  f = Expression()
  ")"
  {
    SetExceptionHandler s = new SetExceptionHandler(f);
    s.setLineNumber(line);
    return s;
  }
}

void CallArg(Map args) :
{
  String argName;
  Any    argVal = null;
  Locate larg   = null;
}
{
  ( larg = NodeRef() {} )
  [ "="
    argVal = Expression()
  ]
  {
    if (argVal == null)
    {
      // Only an node ref was provided. Synthesise the arg name from the last path
      // component of the node ref, which must be a plain string (not an
      // indirection) and not a special token
      Any last = larg.getLast();
      if (NodeSpecification.isSpecial(last) || (!(last instanceof StringI)))
        throw new AnyRuntimeException("Illegal parameter syntax " +
                                      last +
                                      " at line " + token.beginLine +
                                      " column " + token.beginColumn);
      argName = last.toString();
      larg.setLineNumber(token.beginLine);
      argVal = larg;
      //Locate l;
      //argVal = l = new LocateNode("$stack." + argName);
      //l.setLineNumber(token.beginLine);
    }
    else
    {
      // the larg = argVal syntax
      Any last = larg.getLast();
      if (NodeSpecification.isSpecial(last) || (!(last instanceof StringI)))
        throw new AnyRuntimeException("Illegal parameter syntax " +
                                      last +
                                      " at line " + token.beginLine +
                                      " column " + token.beginColumn);
      argName = last.toString();
    }

    args.add(new ConstString(argName), argVal);
  }
}


Any Break() :
{ Any a = null; int line; }
{
  "break" { line = token.beginLine; }
  "(" [a = Expression()] ")"
  {
    Break b = new Break(a);
    b.setLineNumber(line);
    return b;
  }
}

Any Return() :
{ Any a = null; int line; }
{
  "return" { line = token.beginLine; }
  "(" [a = Expression()] ")"
  {
    Return r = new Return(a);
    r.setLineNumber(line);
    return r;
  }
}

Any FocusTo() :
{ Any a; Any tableColumn = null; int line; }
{
  "setfocus" { line = token.beginLine; }
  "("
  a = Expression()
  [ "," tableColumn = Expression() ]
  ")"
  {
    SetFocus s = new SetFocus(a, tableColumn);
    s.setLineNumber(line);
    return s;
  }
}

Any GetProcess() :
{
  Any id;
  int line;
}
{
  "getprocess" { line = token.beginLine; }
  "("
  id = Expression()
  ")"
  {
    GetProcess g = new GetProcess(id);
    g.setLineNumber(line);
    return g;
  }
}

Any GetObject() :
{
  Any obj;
  int line;
}
{
  "getobject" { line = token.beginLine; }
  "("
  obj = Expression()
  ")"
  {
    GetObject g = new GetObject(obj);
    g.setLineNumber(line);
    return g;
  }
}

Any GetProperty() :
{
  Any obj;
  int line;
}
{
  "getproperty" { line = token.beginLine; }
  "("
  obj = Expression()
  ")"
  {
    GetProperty g = new GetProperty(obj);
    g.setLineNumber(line);
    return g;
  }
}

// SendRequest

Any SendRequest() :
{
  String svc;
  String packageOverride = _package;
  Map    args            = AbstractComposite.simpleMap();
  int    line;
}
{
  "send" { line = token.beginLine; }
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { svc = token.image; }
  "("
  //[ SRCallArg(args) ("," SRCallArg(args))* ]
  [ CallArg(args) ("," CallArg(args))* ]
  ")"
  {
    Any channel;
    Any context = null;

    if (args.contains(channel__))
      channel = args.remove(channel__);
    else if (args.contains(NodeSpecification.atChannel__))
      channel = args.remove(NodeSpecification.atChannel__);
    else
      channel = new LocateNode("$root.ochannel");

    if (channel instanceof Func)
      ((Func)channel).setLineNumber(line);

    if (args.contains(context__))
      context = args.remove(context__);

    if (args.contains(acontext__))
      context = args.remove(acontext__);

    SendRequest sr = new SendRequest(new ConstString(packageOverride + ".services." + svc),
                                     context,
                                     args,
                                     channel);
    sr.setLineNumber(line);
    return sr;
  }
}

void SRCallArg(Map args) :
{ String argName; Any argVal = null; int line; }
{
  ( <IDENTIFIER> | "target" | "file"  | "package" | "data" | "syncgui")
  { line = token.beginLine; argName = token.image; }
  [ "="
    argVal = Expression()
  ]
  {
    if (argVal == null)
    {
      Locate l;
      argVal = l = new LocateNode("$stack." + argName);
      l.setLineNumber(line);
    }

    args.add(new ConstString(argName), argVal);
  }
}

// Start NodeRef
// We cannot do recursion in the token manager, and since the syntax
// for a node ref is recursively defined we have to handle those aspects
// in the parser.

Locate NodeRef() :
{StringBuffer s = new StringBuffer(); int line; }
{
  s = StartNodeRef(s) { line = token.beginLine; }
  {
    NodeSpecification n = new NodeSpecification(s.toString());
    n = setPrefices(n);
    Locate l = new LocateNode(n);
    l.setLineNumber(line);
    return l;
  }
}

StringBuffer StartNodeRef(StringBuffer s) :
{}
{
  (
    NodePathIdentifier(s) ( MatchedNodeBraces(s) | MatchedNodeBrackets(s) /*| MatchedNodeParenthesis(s)*/ )?
  | MatchedNodeBraces(s)
  | MatchedNodeBrackets(s)
  //| MatchedNodeParenthesis(s)
  )
  {
    return s;
  }
}

StringBuffer RecurseNodeRef(StringBuffer s) :
{}
{
  ( NodePathIdentifier(s) ( MatchedNodeBraces(s) | MatchedNodeBrackets(s) /*| MatchedNodeParenthesis(s)*/ )?
  | MatchedNodeBraces(s)
  | MatchedNodeBrackets(s)
  //| MatchedNodeParenthesis(s)
  )?
  {
    return s;
  }
}

void NodePathIdentifier(StringBuffer s) :
{}
{
  ( <IDENTIFIER> { s.append(token.image); }
  | <NAME>       { s.append(token.image); }
  | <NODE_REF>   { s.append(token.image); }
  //| <KEY>        { s.append(token.image); } // otherwise reserved words
  //| <TARGET>     { s.append(token.image); }
  )
}

void MatchedNodeBraces(StringBuffer s) :
{ StringBuffer s1 = new StringBuffer(); }
{
  <LBRACE> {s.append(token.image);}
  StartNodeRef(s1) {s.append(setPrefices(s1));}
  <RBRACE> {s.append(token.image);}
  RecurseNodeRef(s)
}

void MatchedNodeBrackets(StringBuffer s) :
{ StringBuffer s1 = new StringBuffer(); }
{
  "[" {s.append(token.image);}
  (
    StartNodeRef(s1) {s.append(setPrefices(s1));}
    | <INTEGER_LITERAL> {s.append(token.image);}
  )
  "]" {s.append(token.image);}
  RecurseNodeRef(s)
}

/*
void MatchedNodeParenthesis(StringBuffer s) :
{ StringBuffer s1 = new StringBuffer(); }
{
  "(" {s.append(token.image);}
  StartNodeRef(s1) {s.append(setPrefices(s1));}
  ")" {s.append(token.image);}
  RecurseNodeRef(s)
}
*/

// End NodeRef

// Literals - can be returned as a String or as an Any
// depending on earlier grammar context

Any LiteralAsAny() :
{ Any a; }
{
  a = IntegerLiteralAsAny()
  {
    return AbstractValue.flyweightConst(a);
  }
  |
  a = FloatingLiteralAsAny()
  {
    return a;
  }
  | <STRING_LITERAL>
  {
    a = AbstractValue.flyweightString(processStringEscapes(token.image.substring(1, token.image.length()-1)));
    return a;
  }
  | <CHARACTER_LITERAL>
  {
    a = new ConstChar(processCharEscapes(token.image));
    return AbstractValue.flyweightConst(a);
  }
  | a = BooleanLiteralAsAny()
  {
    return a;
  }
  | a = LiteralMap()
  {
    return a;
  }
  | "boolean.class"
  {
    return AnyBoolean.class__;
  }
  | "byte.class"
  {
    return AnyByte.class__;
  }
  | "char.class"
  {
    return AnyChar.class__;
  }
  | "date.class"
  {
    return AnyDate.class__;
  }
  | "double.class"
  {
    return AnyDouble.class__;
  }
  | "decimal.class"
  {
    return Decimal.class__;
  }
  | "float.class"
  {
    return AnyFloat.class__;
  }
  | "int.class"
  {
    return AnyInt.class__;
  }
  | "long.class"
  {
    return AnyLong.class__;
  }
  | "short.class"
  {
    return AnyShort.class__;
  }
  | "string.class"
  {
    return AnyString.class__;
  }
}

Any IntegerLiteralAsAny() :
{}
{
  <INTEGER_LITERAL>
  {
    String s = token.image;
    Any ret;

    if (s.endsWith("L") || s.endsWith("l"))
    {
      s = s.substring(0, s.length()-1);
      Long l = Long.decode(s);
      ret = new ConstLong(l.longValue());
    }
    else
    {
      Integer i = Integer.decode(s);
      ret = new ConstInt(i.intValue());
    }
    return ret;
  }
}

BooleanI BooleanLiteralAsAny() :
{}
{
  <BOOLEAN_LITERAL>
  {
    if (token.image.equals(AnyString.TRUE.getValue()))
      return AnyBoolean.TRUE;
    else
      return AnyBoolean.FALSE;
  }
}

Any FloatingLiteralAsAny() :
{
  Any a;
}
{
  <FLOATING_POINT_LITERAL>
  {
    if (token.image.endsWith("D") || token.image.endsWith("d"))
      a = new ConstDouble(token.image);
    else
      a = new ConstFloat(token.image);

    return AbstractValue.flyweightConst(a);
  }
}

Map LiteralMap() :
{ Map m = AbstractComposite.simpleMap(); Any k, v; }
{
  "map" "("
  [ ( k = EvaluatedExpression() "," v = EvaluatedExpression() { m.add(k, v); } )
    ( "," k = EvaluatedExpression() "," v = EvaluatedExpression() { m.add(k, v); } )* ]
  ")"
  {
    return m;
  }
}

String LiteralAsString() :
{}
{
  ( <INTEGER_LITERAL>
  | <FLOATING_POINT_LITERAL>
  | <BOOLEAN_LITERAL>
  ) { return token.image; }
  | <STRING_LITERAL> { return processStringEscapes(token.image.substring(1, token.image.length()-1)); }
}

// End Literals

// An expression that we evaluate during parsing.
Any EvaluatedExpression() :
{ Any a; }
{
  a = Expression()
  {
    try
    {
      a = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), a);
    }
    catch (AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    return a;
  }
}

// Declarations - there are two types, untyped and typed

// A typed declaration always creates a new Any and optionally
// copies the initialiser literal into it.
Any TypedDeclaration() :
{ Any     a                = null;
  Locate  l                = null;
  String  str              = null;
  boolean preserveContext  = true;
  boolean set              = false;
  boolean bytearray        = false;
  Any     byteinit         = null;
  Any     s                = null;
  Array   compositeMembers = null;
  int     line;
  int     startLine        = token.endLine;
}
{
  ( ( ( "func"
      | "cfunc" { preserveContext = false; }
      ) { line = token.beginLine; }
      l = NodeRef()
      [ LOOKAHEAD(2) "="  // because of Ternary
        s = Expression()
      ]
      {
        if (s != null && !(s instanceof Func))
          throw new AnyRuntimeException("func variables can only hold functions");
        AnyFuncHolder af;
        a = af = new AnyFuncHolder((Func)s,
                                   preserveContext,
                                   new ConstString(l.toString()),
                                   documentAnyURL_);
        af.setLineNumber(line);
      }
    )
  | ( a = MakeAnyNotSet()

      ( LOOKAHEAD("(" <STRING_LITERAL>) a = AnonymousDeclaration(a)  { return a; }
      | a = ReferencedDeclaration(a) { return a; }
      )
    )
  | ( ( a = MakeStyle() | a = MakeRegex() | a = MakeServerSocket() | a = MakeLogFilter() )
      a = ReferencedDeclaration(a) { return a; }
    )
  | ( ( "set"   { a = AbstractComposite.set();  set = true; }
      | "oset"  { a = AbstractComposite.orderedSet(); set = true; }
      | "iset"  { a = AbstractComposite.fieldSet(); set = true; }
      | "array" { a = AbstractComposite.array(); }
      | ( "bytearray"
          { a = new AnyByteArray(); bytearray = true; }
          [ "(" byteinit = Expression() ")" ]
        )
      )

      l = NodeRef()

      [ LOOKAHEAD(2) "=" compositeMembers = SetMembers() ]
    )
  )
  {
    Declare d;
    
    if (byteinit != null)
    {
      d = new DeclareAnyByteArray(l, a, byteinit, compositeMembers);
    }
    else if (compositeMembers != null)
    {
      if (set)
        d = new DeclareSet(l, a, compositeMembers);
      else if (bytearray)
        d = new DeclareAnyByteArray(l, a, byteinit, compositeMembers);
      else
        d = new DeclareArray(l, a, compositeMembers);
    }
    else
      d = new Declare(l, a);

    d.setLineNumber(startLine);
    return d;
  }
}

Any ReferencedDeclaration(Any a) :
{ Locate l; Any value; }
{
  l = NodeRef()

  [ LOOKAHEAD(2) "="
    (
     value = Expression()
     {
       //if (a instanceof AnyIcon)
       //{
       //  AnyIcon i = (AnyIcon)a;
       //  i.processImageSource(documentURL_, value.toString());
       //}
       //else
       //{
         a = new EvalExpr(a, value, new Assign());
       //}
     }
    )
  ]
  {
    return new Declare(l, a);
  }
}

Any AnonymousDeclaration(Any a) :
{ String s; }
{
  "("
  <STRING_LITERAL> { s = processStringEscapes(token.image.substring(1, token.image.length()-1)); }
  ")"
  {
    if (a instanceof AnyIcon)
    {
      AnyIcon i = (AnyIcon)a;
      i.processImageSource(documentURL_, s);
    }
    else
    {
      a.copyFrom(new ConstString(s));
    }
    return a;
  }
}

// An untyped declaration must be initialised and the expression result
// will be stored at the given location, so it is possible to alias existing
// anys when this is legal at runtime.  If the initialiser is a literal then
// the result type is inferred by the literal value.
Any UnTypedDeclaration() :
{ Any a = null; Locate l = null; }
{
  "any" l = NodeRef() "=" a = Expression()
  {
    Declare d = new DeclareAnonymous(l, a);
    d.setLineNumber(l.getLineNumber());
    return d;
  }
}

Any IODeclaration() :
{ AbstractStream a; Locate l; }
{
  a = MakeStream()
  l = NodeRef()
  {
    return new Declare(l, a);
  }
}

AbstractStream MakeStream() :
{ AbstractStream a; }
{
  ( "ioNative" { a = new NativeStream(); }
  | "ioPrint"  { a = new PrintStream();  }
  | "ioXML"    { a = new XMLStream();  }
  | "ioXMLX"   { a = new XMLXStream();  }
  | "ioFixed"  { a = new FixedFieldStream();  }
  | "ioByte"   { a = new ByteStream();  }
  | "ioCSV"    { a = new CSVStream();  }
  | "ioProps"  { a = new PropertiesStream();  }
  | "ioMq"     { a = new MessageStream();  }
  )
  {
    return a;
  }
}

Array SetMembers() :
{
  Array compositeMembers = AbstractComposite.array();
  Any   member;
}
{
  "("
  ( member = Expression() { compositeMembers.add(member); } )
  ( "," member = Expression() { compositeMembers.add(member); } )*
  ")"
  {
    return compositeMembers;
  }
}

Any MakeAny() :
{ Any a; }
{
  ( a = MakeAnyNotSet()
  | "set" { a = AbstractComposite.set(); }
  )
  {
    return a;
  }
}

Any MakeAnyNotSet() :
{ Any a = null; }
{
  (
    a = MakeDecimal()
    |
    a = MakeBlob()
    |
    (
      ( "byte"
      | "char"
      | "short"
      | "int"
      | "long"
      | "boolean"
      | "float"
      | "double"
      | "date"
      | "string"
      | <HMAP>
      | <SMAP>
      | "omap"
      | "wmap"
      | "object"
      | "image"
      | <COLOUR>
      | "font"
      | "collator"
      | "filefilter"
      | "document"
      | "file"
      | "timer"
      | "timezone"
      | "currency"
      | "calendar"
      )
      {
        switch(token.kind)
        {
          case BYTE:
            a = new AnyByte();
            break;
          case CHAR:
            a = new AnyChar();
            break;
          case SHORT:
            a = new AnyShort();
            break;
          case INT:
            a = new AnyInt();
            break;
          case LONG:
            a = new AnyLong();
            break;
          case BOOLEAN:
            a = new AnyBoolean();
            break;
          case FLOAT:
            a = new AnyFloat();
            break;
          case DOUBLE:
            a = new AnyDouble();
            break;
          case DATE:
            a = new AnyDate();
            break;
          case STRING:
            a = new AnyString();
            break;
          case HMAP:
            a = AbstractComposite.managedMap();
            break;
          case OMAP:
            a = AbstractComposite.orderedMap();
            break;
          case WMAP:
            a = AbstractComposite.weakMap();
            break;
          case SMAP:
            a = AbstractComposite.simpleMap();
            break;
          case OBJECT:
            a = new AnyObject();
            break;
          case ICON:
            a = new AnyIcon();
            break;
          case COLOUR:
            a = new AnyColor();
            break;
          case FONT:
            a = new AnyFont();
            break;
          case COLLATOR:
            a = new AnyCollator();
            break;
          case FILEFILTER:
            a = new AnyFileFilter();
            break;
          case DOCUMENT:
            a = new AnyDocument();
            break;
          case FILE:
            a = new AnyFile();
            break;
          case TIMER:
            a = new AnyTimerTask();
            break;
          case TIMEZONE:
            a = new AnyTimeZone();
            break;
          case CURRENCY:
            a = new AnyCurrency();
            break;
          case CALENDAR:
            a = new AnyCalendar(Calendar.getInstance(Locale.getDefault()));
            break;
        }
      }
    )
  )
  {
    return a;
  }
}

Any MakeDecimal() :
{ int scale = -1; int roundingMode = BigDecimal.ROUND_HALF_UP; }
{
  // Note that AnyBigDecimal.default__ has a scale of 0. This must be maintained
  // in line with the parser's default scale
  "decimal" [ ":" <INTEGER_LITERAL> { scale = Integer.parseInt(token.image); } ]
  {
    Decimal a = new AnyBigDecimal();
    if (scale >= 0)
      a.setScale(scale);

    return a;
  }
}

Any MakeBlob() :
{ AbstractStream stream; }
{
  "blob"
  ":"
  stream = MakeStream()
  {
    AnyBlob b = new AnyBlob(stream);
    return b;
  }
}

Any MakeStyle() :
{}
{
  "style" { return new AnyAttributeSet(); }
}

Any MakeRegex() :
{}
{
  "regex" { return new AnyMatcher(); }
}

Any MakeLogFilter() :
{}
{
  "logfilter" { return new AnyLogFilter(); }
}

Any MakeServerSocket() :
{}
{
  "serversocket" { return new AnyServerSocket(); }
}

// Function/Service declaration

Any FunctionDeclaration() :
{
  String            packageOverride = _package; // just the function, not any params
  String            funcName;
  AbstractInputFunc func = null;
  Any               expr;
  Token             declType;
  int               lineNumber   = -1;
  int               columnNumber = -1;
  AnyShort          privLevel    = new AnyShort(Process.DEFAULT_PRIVILEGE);
  Any               privRef      = null;
  boolean           local        = false;
  boolean           syncGui      = false;
  Array             baseEventTypes = null;
}
{
  ( "local" { local = true; }
    |
    "syncgui" { syncGui = true; }
  )*
  (declType = "function" | declType = "service")
  {
    ensureTopLevel(token.image);
    lineNumber = token.beginLine;
    columnNumber = token.beginColumn;
  }
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { funcName = token.image; _entity = funcName; }
  "("
  {
    switch (declType.kind)
    {
      case FUNCTION:
        if (syncGui)
          throw new AnyRuntimeException("Functions cannot be syncgui");
        func = new Exec();
        break;
      case SERVICE:
        if (local)
          throw new AnyRuntimeException("Services cannot be local");
        if (syncGui)
          func = new SyncGraphicsService();
        else
          func = new Service();
        break;
    }
  }
  [ FormalParameter(func) ("," FormalParameter(func))* ]
  ")"
  [ "raises" { baseEventTypes = AbstractComposite.array(); }
    RaisesEventTypeList(baseEventTypes)
    {
      Array eventTypes;

      if (baseEventTypes.equals(EventConstants.ALL_TYPES))
      {
        eventTypes = EventConstants.ALL_TYPES;
      }
      else
      {
        // Make the event types
        eventTypes = AbstractComposite.array();
        for (int i = 0; i < baseEventTypes.entries(); i++)
        {
          Any eventType = baseEventTypes.get(i);

          if (complexEvents__.contains(eventType))
            eventType = complexEventType(eventType, null, null, null, null, null);

          eventTypes.add(eventType);
        }
      }

      func.setRaisesEvents(eventTypes);
    }
  ]
  //[ "raises" { func.setRaisesEvents(true); } ]
  [
    "privilege"
    "("
    ( privRef = NodeRef() | privRef = IntegerLiteralAsAny() )
    ")"
  ]
  expr = Statement()
  {
    func.setExpr(expr);
    func.setBaseURL(documentAnyURL_);
    func.setLineNumber(lineNumber);
    func.setColumn(columnNumber);
    if (expr instanceof Func)
    {
      Func f = (Func)expr;
      f.setLineNumber(lineNumber);
      f.setColumn(columnNumber);
    }
    try
    {
      AnyShort sPriv = new AnyShort(privLevel);
      if (privRef != null)
      {
        // if privRef evaluates to null then sPriv will remain unchanged
        EvalExpr e = new EvalExpr(sPriv, privRef, new Assign());
        e.setTransaction(userTxn_);
        e.exec(userTxn_.getContext());
      }
      if (sPriv.getValue() < userTxn_.getProcess().getEffectivePrivilegeLevel())
        throw new AnyRuntimeException
          ("Cannot define the service or function " +
           funcName +
           " at level " +
           sPriv.getValue() +
           " which is more privileged than current level of " +
           userTxn_.getProcess().getEffectivePrivilegeLevel() +
           " at line " +
           lineNumber);

      if (sPriv.getValue() < Process.MAXIMUM_PRIVILEGE || sPriv.getValue() > Process.MINIMUM_PRIVILEGE)
        throw new AnyRuntimeException
          ("Illegal privilege value when declaring " +
           funcName +
           " - must lie in the range " +
           Process.MAXIMUM_PRIVILEGE +
           " and " +
           Process.MINIMUM_PRIVILEGE +
           " at line " +
           lineNumber);

      func.setEffectivePrivilegeLevel(sPriv.getValue());
      String nameSpace = null;
      switch (declType.kind)
      {
        case FUNCTION: nameSpace = ".exprs.";    break;
        case SERVICE:  nameSpace = ".services."; break;
      }
      func.setPackage(AbstractValue.flyweightString(packageOverride));
      func.setName(AbstractValue.flyweightString(_entity));
      func.setFQName(AbstractValue.flyweightString(packageOverride + ":" + _entity));
      _entity = "";
      NodeSpecification path = new NodeSpecification(packageOverride + nameSpace + funcName);
      if (local)
        path.add(path.entries()-1, documentAnyURL_);

      AbstractInputFunc.catalog(func, path, userTxn_);
    }
    catch (AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    return nonExec__;
  }
}

void FormalParameter(AbstractInputFunc f) :
{
  Any        a                  = null;
  String     typPackageOverride = _package;
  String     typ                = null;
  String     field              = null;
  String     pname              = null;
  Locate     l;
}
{
  ( a = TypedDeclaration()
    {
      Declare d = (Declare)a;
      try
      {
        // Declarations use the stack so protect the current stack frame
        // in case there is a name clash
        userTxn_.pushStackFrame();

        // Evaluate the parameter
        Any p = EvalExpr.evalFunc(userTxn_,
                                  userTxn_.getContext(),
                                  d);

        // For func parameters, make sure that the parameter will take on
        // whatever the calling argument's (c)func nature is (and eliminate
        // dangling context nodes if the user uses func as the parameter
        // type. Note that it doesn't matter whether the parameter was
        // declared as func or cfunc.
        if (p instanceof AnyFuncHolder.FuncHolder)
          ((AnyFuncHolder.FuncHolder)p).setFuncParam();

        f.addParam(d.getVariableName(), p);
      }
      catch(Exception e)
      {
        throw new RuntimeContainedException(e);
      }
      finally
      {
        userTxn_.popStackFrame();
      }
    }
    |
    ( "any"
      l = NodeRef()
      {
        NodeSpecification n = l.getNodePath();
        a = n.getLast();
        if (NodeSpecification.isSpecial(a))
          throw new AnyRuntimeException("Illegal parameter name " + a);
      }
    )
    {
      //f.addParam(pname, AnyNull.instance());
      f.addParam(a, null);
    }
    |
    ( [LOOKAHEAD(Name() ":") (Name() { typPackageOverride = mapImport(token.image); } ":" )]
      typ = FieldImport() { field = token.image; } [ <IDENTIFIER> { pname = token.image; } ]
      [ "=" a = Expression() ]
    )
    {
      try
      {
        // PRIVILEGE
        Locate typeRef = new LocateNode("$catalog." + typPackageOverride + ".types." + typ);
        typeRef.setTransaction(userTxn_);
        Any ds = typeRef.exec(Catalog.instance().getCatalog());
        if (ds == null)
        {
          String s = typPackageOverride + ":" + typ;
          throw new AnyRuntimeException("Can't resolve formal parameter " + s + " at line " + token.beginLine);
        }
        Descriptor des = (Descriptor)ds;
        Any param = des.getDataField(AbstractValue.flyweightString(field), true);
        // If there is an initialiser then evaluate it now and copy to clone.
        if (a != null)
        {
          param = param.cloneAny().copyFrom(EvalExpr.evalFunc(userTxn_,
                                                              Catalog.instance().getCatalog(),
                                                              a));
        }
        f.addParam((pname == null) ? field : pname, param);
      }
      catch(AnyException x)
      {
        throw new RuntimeContainedException(x);
      }
    }
  )
}

Any MediaSize() :
{ Any a; String ms; }
{
  "gMediaSize"
  "("
  <IDENTIFIER> { ms = token.image; }
  ")"
  {
    Class c = javax.print.attribute.standard.MediaSizeName.class;
    try
    {
      Field f = c.getField(ms);
      return new AnyEnumSyntax(f.get(null));
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

Any ParaAlignment() :
{ Any a; String pa; }
{
  "gParaAlign"
  "("
  <IDENTIFIER> { pa = token.image; }
  ")"
  {
    Class c = javax.swing.text.StyleConstants.class;
    try
    {
      Field f = c.getField(pa);
      return new ConstInt(f.getInt(null));
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

Any GuiConstant() :
{ Any a; String gc; }
{
  "gGuiConstant"
  "("
  <IDENTIFIER> { gc = token.image; }
  ")"
  {
    Class c = javax.swing.SwingConstants.class;
    try
    {
      Field f = c.getField(gc);
      return new ConstInt(f.getInt(null));
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

// Resource Declaration
Any ResourceDeclaration() :
{
  String            packageOverride = _package;
  String            resName;
  int               resType;
  String            resLimit;
  Any               spec;
}
{
  "resource"
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { resName = token.image; }
  "("
  (<SQLSERVER>)   { resType = token.kind; }   ","
  <INTEGER_LITERAL> { resLimit = token.image; } ","
  spec = LiteralAsAny()
  ")"
  {
    ConstInt    limit = new ConstInt(resLimit);
    StringI id    = new ConstString(packageOverride + "." + resName);

    switch(resType)
    {
      case SQLSERVER: SqlManager.addSqlServer(id, spec, limit); break;
    }

    return nonExec__;
  }
}

// Type Declaration

Any TypeDeclaration() :
{
  Any t;
  Any nativeType = null;
}
{
  "typedef" { ensureTopLevel(token.image); }
  ( nativeType = MakeAny() { if (nativeType instanceof Value) ((Value)nativeType).setNull(); }
    t = NativeTypeDeclaration(nativeType)
  | t = ObjectTypeDeclaration()
  )
  {
    return t;
  }
}

Any NativeTypeDeclaration(Any nativeType) :
{
  String typeName;
}
{
  <IDENTIFIER>
  {
    typeName   = token.image;
    Any name   = new ConstString(typeName);
    Any fQName = new ConstString(_package + ".types." + typeName);
    Any inqPackage = new ConstString(_package);
    NativeDescriptor d = new NativeDescriptor(name, fQName, inqPackage);
    d.setProto(AbstractComposite.simpleMap());
  }
  [ FieldInit(nativeType) ]
  FieldAttribs(d, nativeType, name)
  {
    try
    {
      BOTDescriptor.catalogDescriptor(d, fQName.toString(), userTxn_);
    }
    catch(AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    return nonExec__;
  }
}

Any ObjectTypeDeclaration() :
{
  String             typeName;
  AbstractDescriptor typedef;
  boolean            cached          = true;
  String             alias;
  String             fQName;
}
{
  //[LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  <IDENTIFIER> { typeName = token.image; alias = typeName; _entity = typeName;}
  [ "nocache" { cached = false; } ]
  "{"
  [ "alias" <IDENTIFIER> { alias = token.image; } ";" ]
  typedef = TypedefBody(typeName, alias, (fQName = _package + ".types." + typeName), cached)
  "}"
  {
    _entity = "";
    try
    {
      BOTDescriptor.catalogDescriptor(typedef, fQName, userTxn_);
    }
    catch(AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    return nonExec__;
  }
}

AbstractDescriptor TypedefBody(String typeName, String alias, String fQName, boolean cached) :
{
  BOTDescriptor d;
  KeyDef        primary;
  PhysicalIO    io = new NullIO();
}
{
  {
    d = new BOTDescriptor(typeName, alias, fQName, _package);
    d.setProto(new ManagedObject());
    d.setBaseURL(documentAnyURL_);
  }
  Fields(d)
  ( Construct(d)
  | Join(d)
  | Mutate(d)
  | Destroy(d)
  | Expirer(d)
  )*
  primary = PrimaryKey(d, cached)
  ( OtherKey(d, primary, cached) )*
  [ ListenMap(d) ]
  [ io = IOBinding(d) ]
  {
    if (isInteractive_)
      d.setIO(new NullIO());
    else
      d.setIO(io);
    return d;
  }
}

void Fields(Descriptor d) :
{}
{
  "fields" "("
  Field(d) ( Field(d) )*
  ")"
}

void Field(Descriptor d) :
{
}
{
  FieldAny(d) | FieldReference(d, BOTDescriptor.botTarget__, null) ";"
}

void FieldAny(Descriptor d) :
{
  Any     fieldAny = null;
  Any     fieldName;
  boolean negate     = false;
}
{
  ( ( fieldAny = MakeAny() { if (fieldAny instanceof Value) ((Value)fieldAny).setNull(); }
      <IDENTIFIER> { fieldName = AbstractValue.flyweightString(token.image); }
      [ FieldInit(fieldAny) ]
      FieldAttribs(d, fieldAny, fieldName)
    )
  | ( "any"   // anonymous place holder
      <IDENTIFIER>
      {
        fieldName = AbstractValue.flyweightString(token.image);
        fieldAny  = new AnyObject();
      }
      FieldAttribs(d, fieldAny, fieldName)
    )
  | ( "func"
      <IDENTIFIER> { fieldName = AbstractValue.flyweightString(token.image); }
      [ "="
        fieldAny = Expression()
      ]
      ";"
      {
        if (fieldAny != null && !(fieldAny instanceof Func))
          throw new AnyRuntimeException("func fields can only hold functions");

        AnyFuncHolder.FuncHolder fh;
        fieldAny = fh = new AnyFuncHolder.FuncHolder((Func)fieldAny);
        fh.setUrl(documentAnyURL_);
        fh.setName(fieldName);
        d.addDataField(fieldName, fieldAny);
      }
    )
  )
}

Any FieldInit(Any fieldAny) :
{
  Any  fieldExpr  = null;
  Any  fieldInit  = null;
}
{
  "=" fieldExpr = Expression()
  {
    try
    {
      fieldInit = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), fieldExpr);
    }
    catch (Exception e)
    {
      throw new RuntimeContainedException(e);
    }
    if (fieldInit == null)
      throw new AnyRuntimeException("Could not resolve initialiser expression " + fieldExpr);

    Any ret = fieldInit;

    if (fieldAny != null)
    {
      fieldAny.copyFrom(fieldInit);
      ret = fieldAny;
    }
    return ret;
  }
}

void FieldAttribs(Descriptor d, Any fieldAny, Any fieldName) :
{
  int    attribKind;
  String attribInit = null;
  Any    label      = null;
  Any    width      = null;
  Any    format     = null;
  Map    privs      = null;
  Any    temp;
}
{
  (
    ( "label"  "=" label  = Expression() )
    |
    ( "width"  "=" width  = Expression() )
    |
    ( "format" "=" format = Expression() )
    |
    (
      privs = Privilege(true)
      {
        if (privs != null)
          d.setPrivilege(fieldName, privs);
      }
    )
  )*
  (
    ";"
    |
    ( 
      "("
      FieldEnums(fieldName, fieldAny, d)
      ")"
      {
        // When the descriptor is a NativeDescriptor
        // then ensure the prototype carries the
        // descriptor
        if (d instanceof NativeDescriptor)
        {
          fieldAny = NativeDescriptor.convertWithDescriptor(fieldAny, d);
        }
      }
    )
  )
  {
    //if (fieldAny instanceof Value)
      //((Value)fieldAny).setNull();

    d.addDataField(fieldName, fieldAny);

    if (label != null)
    {
      try
      {
        temp  = label;
        label = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), label, StringI.class);
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
      if (label == null)
        throw new AnyRuntimeException("Specified label " + temp + " could not be resolved");
      d.setTitle(fieldName, (StringI)label);
    }

    if (width != null)
    {
      try
      {
        temp  = width;
        width = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), width, IntI.class);
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
      if (width == null)
        throw new AnyRuntimeException("Specified width " + temp + " could not be resolved");
      d.setWidth(fieldName, (IntI)width);
    }

    if (format != null)
    {
      try
      {
        temp   = format;
        format = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), format, StringI.class);
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
      if (format == null)
        throw new AnyRuntimeException("Specified format " + temp + " could not be resolved");
      d.setFormat(fieldName, (StringI)format);
    }
  }
}

Any FieldLabel() :
{
  Any label = null;
  Any temp;
}
{
  "label" "=" label = Expression()
  {
    try
    {
      temp  = label;
      label = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), label, StringI.class);
    }
    catch (AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    if (label == null)
      throw new AnyRuntimeException("Specified label " + temp + " could not be resolved");
    return label;
  }
}

void FieldReference(Descriptor d, Any target, KeyDef k) :
{
  String packageOverride = _package;
  String typeName;
  String fieldName;
  String fieldAlias      = null;
  Any    initOverride    = null;
  Any    labelOverride   = null;
}
{
  [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
  typeName = FieldImport() { fieldName = token.image; } [ <IDENTIFIER> { fieldAlias = token.image; } ]
  /*
  <IDENTIFIER> { typeName = token.image; fieldName = token.image; }
  ( ( "." <IDENTIFIER> { fieldName = token.image; } [ <IDENTIFIER> { fieldAlias = token.image; } ] )
    |
      <IDENTIFIER> { fieldAlias = token.image; }
  )?
  */
  [ initOverride  = FieldInit(null) ]
  [ labelOverride = FieldLabel() ]
  {
    StringI fQName = new ConstString(packageOverride + ".types." + typeName);
    StringI alias = null;
    if (fieldAlias != null)
      alias = new ConstString(fieldAlias);
    StringI name = new ConstString(fieldName);
    d.addDataFieldReference(name,
                            fQName,
                            alias,
                            initOverride,
                            labelOverride,
                            target);
    if (k != null)
    {
      k.addKeyFieldName(alias != null ? alias : name);
      // Key fields always default to null unless there is an explicit override for them
      if (initOverride != null)
        k.addInitialiser(((alias != null) ? alias : name), initOverride);
      ((AbstractKeyDef)k).setShouldCache(false);
    }
  }
}

void FieldEnums(Any fieldName, Any fieldAny, Descriptor d) :
{}
{
  FieldEnum(fieldName, fieldAny, d) ";" ( FieldEnum(fieldName, fieldAny, d) ";" )*
}

void FieldEnum(Any fieldName, Any fieldAny, Descriptor d) :
{ String symbol; Any intValue; Any extValue; }
{
  <IDENTIFIER> { symbol = token.image; }
  ":"
  intValue = LiteralAsAny()
  ":"
  extValue = LiteralAsAny()
  {
    // Make sure internal value is same type as field and make it const
    Any enumValue = fieldAny.buildNew(intValue).bestowConstness();
    //enumValue.copyFrom(intValue);
    d.addEnumValue(fieldName, AbstractValue.flyweightString(symbol), enumValue, extValue);
  }
}

void Construct(BOTDescriptor d) :
{
  Any ctor;
}
{
  "construct" "(" ctor = Expression() ")"
  {
    if (!(ctor instanceof Func))
      throw new AnyRuntimeException("typedef constructor must be a function");

    d.setConstructor((Func)ctor);
  }
}

void Join(BOTDescriptor d) :
{
  Any join;
}
{
  "join" "(" join = Expression() ")"
  {
    if (!(join instanceof Func))
      throw new AnyRuntimeException("typedef join expression must be a function");

    d.setJoin((Func)join);
  }
}

void Mutate(BOTDescriptor d) :
{
  Any mtor;
}
{
  "mutate" "(" mtor = Expression() ")"
  {
    if (!(mtor instanceof Func))
      throw new AnyRuntimeException("typedef mutator must be a function");

    d.setMutator((Func)mtor);
  }
}

void Destroy(BOTDescriptor d) :
{
  Any dtor;
}
{
  "destroy" "(" dtor = Expression() ")"
  {
    if (!(dtor instanceof Func))
      throw new AnyRuntimeException("typedef destroy must be a function");

    d.setDestroyer((Func)dtor);
  }
}

void Expirer(BOTDescriptor d) :
{
  Any expirer;
}
{
  "expire" "(" expirer = Expression() ")"
  {
    if (!(expirer instanceof Func))
      throw new AnyRuntimeException("typedef expire must be a function");

    d.setExpirer((Func)expirer);
  }
}

KeyDef PrimaryKey(BOTDescriptor d, boolean cached) :
{
  String     keyName   = "unique";
  KeyDef     key;
  BooleanI   isForeign = AnyBoolean.FALSE;
}
{
  "pkey"
  //[ <IDENTIFIER> { keyName = token.image; } ]
  //[ "foreign" "=" isForeign = BooleanLiteralAsAny() ]
  "("
  key = KeyFields(d, keyName, cached, null, true, true, isForeign.getValue(), false, true, null)
  ( KeyExists(key) | KeyCfg(key) )*
  ")"
  {
    d.setPrimaryKey(key);
    return key;
  }
}

void OtherKey(BOTDescriptor d, KeyDef primary, boolean cached) :
{
  String keyName;
  KeyDef key;
  BooleanI isUnique    = new AnyBoolean(false);
  BooleanI isNative    = AnyBoolean.TRUE;
  BooleanI isForeign   = AnyBoolean.FALSE;
  BooleanI isVolatile  = AnyBoolean.FALSE;
  BooleanI isKeyCached = null; //new AnyBoolean(true);
  Any      eligible    = null;
  Any      maxCount    = null;
}
{
  "key"
  <IDENTIFIER> { keyName = token.image; }
  ( "unique"  { isUnique.setValue(true); }
  | ( "native"   "=" isNative    = BooleanLiteralAsAny() )
  | ( "foreign"  "=" isForeign   = BooleanLiteralAsAny() )
  | ( "volatile" "=" isVolatile  = BooleanLiteralAsAny() )
  | ( "cached"   "=" isKeyCached = BooleanLiteralAsAny() )
  | ( "max"      "=" maxCount    = IntegerLiteralAsAny() )
  )*
  "("
  key = KeyFields(d,
                  keyName,
                  cached,
                  primary,
                  isUnique.getValue(),
                  isNative.getValue(),
                  isForeign.getValue(),
                  isVolatile.getValue(),
                  (isKeyCached == null) ? true : isKeyCached.getValue(),
                  maxCount)
  ( KeyEligible(key) | KeyCfg(key) )*
  ")"
  {
    if (isKeyCached != null)
    {
      // If caching status was explicitly specified then apply it
      // even if field references meant it was not cached.  Allow
      // scripts to have ultimate control when a reference doesn't mean
      // cache can be invalid
      ((AbstractKeyDef)key).setShouldCache(isKeyCached.getValue());
    }
    if (isKeyCached == null && isUnique.getValue())
    {
      // If the caching status was NOT explicitly specified and the
      // key is unique then turn caching on irrespective of any
      // field references that would have disabled it.
      ((AbstractKeyDef)key).setShouldCache(true);
    }
    
    // Ignore special test keys if not in test mode
    if (keyName.startsWith("Test"))
    {
      Map argsMap = (Map)Catalog.instance().getCatalog().get(CommandArgs.commandLine__);
      if (argsMap.contains(new ConstString("test")))
        d.addKey(key);
    }
    else
      d.addKey(key);
  }
}

KeyDef KeyFields(BOTDescriptor d,
                 String  keyName,
                 boolean cached,   // whether whole typedef is cached
                 KeyDef  primary,
                 boolean isUnique,
                 boolean isNative,
                 boolean isForeign,
                 boolean isVolatile,
                 boolean isKeyCached,
                 Any     maxCount) :
{
  KeyDef k        = null;
  Array  fields   = AbstractComposite.array();
  Any    kNameAny = AbstractValue.flyweightString(keyName);
}
{
  {
    if (cached)
    {
      if (primary != null)
      {
        //System.out.println("making key " + keyName + isUnique);
        k = new CachingKey(keyName, primary, isUnique, isKeyCached);
      }
      else
        k = new CachingKey(keyName);
    }
    else
    {
      k = new SimpleKey(keyName, null, isUnique);
    }
    AbstractKeyDef ak = (AbstractKeyDef)k;
    if (primary != null)
    {
      ak.setNative(isNative);
      ak.setVolatile(isVolatile);
    }
    else
    {
      ak.setNative(true);
      ak.setVolatile(false);
    }

    ak.setForeign(isForeign);

    if (maxCount != null && isUnique)
       throw new AnyRuntimeException("Unique keys cannot specify a maximum count at line " +
                                     token.beginLine +
                                     " column " + token.beginColumn);
  }
  "fields" "(" [ KeyField(d, primary, kNameAny, fields, k) ( "," KeyField(d, primary, kNameAny, fields, k) )* ] ")"
  {
    ((AbstractKeyDef)k).setFields(fields);

    if (maxCount != null && ((AbstractKeyDef)k).shouldCache())
       throw new AnyRuntimeException("Cached keys cannot specify a maximum count at line " +
                                     token.beginLine +
                                     " column " + token.beginColumn);

    ak.setMaxCount(maxCount);
    return k;
  }
}

void KeyField(BOTDescriptor d, KeyDef primary, Any keyName, Array fields, KeyDef k) :
{
  Any     keyInit   = null;
  String  fieldName = null;
}
{
  ( LOOKAHEAD(<IDENTIFIER>) <IDENTIFIER> { fieldName = token.image; }
                            [ keyInit = FieldInit(null) ]
                            {
                              Any name = AbstractValue.flyweightString(fieldName);
                              fields.add(name);
                              k.addKeyFieldName(name);
                              if (keyInit != null)
                                k.addInitialiser(name, keyInit);
                            }
  // in fact, primary cannot have references but that is trapped in AbstractKeyDef.java somewhat later
  | LOOKAHEAD(Name() ":") FieldReference(d, keyName, k)
  | LOOKAHEAD(Name()) FieldReference(d, keyName, k)
  | LOOKAHEAD("typedef") "typedef" FieldReference(d, keyName, k)
  )
}

void KeyEligible(KeyDef key) :
{ Any eligible; }
{
  "eligible" "(" eligible = Expression() ")"
  {
    if (key instanceof CachingKey)
    {
      CachingKey ck = (CachingKey)key;
      try
      {
        ck.setEligibilityExpr(eligible);
      }
      catch(AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
    }
  }
}

void KeyExists(KeyDef key) :
{ Any exists; }
{
  "exists" "(" exists = Expression() ")"
  {
    if (key instanceof CachingKey)
    {
      CachingKey ck = (CachingKey)key;
      try
      {
        ck.setExistsWhenExpr(exists);
      }
      catch(AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
    }
  }
}

void KeyCfg(KeyDef key) :
{ Any a; }
{
  "auxcfg"
  "("
  a = Expression()
  ")"
  {
    // Expression must be evaluated now
    try
    {
      a = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), a);
    }
    catch (AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    if (a != null)
      key.setAuxInfo(a);
  }
}

void ListenMap(BOTDescriptor d) :
{
}
{
  "listen"
  "("
  ListenFields(d)
  ")"
}

void ListenFields(BOTDescriptor d) :
{
  Map l;
}
{
  {
    l = AbstractComposite.simpleMap();
  }
  "fields"
  "("
  ( <IDENTIFIER>
    {
      l.add(AbstractValue.flyweightString(token.image), AnyAlwaysEquals.instance());
    }
    ( ","
      <IDENTIFIER>
      {
        l.add(AbstractValue.flyweightString(token.image), AnyAlwaysEquals.instance());
      }
    )*
  )
  ")"
  {
    d.setListenerData(l);
  }
}

PhysicalIO IOBinding(Descriptor d) :
{
  int        ioclass;
  String     packageOverride = _package;
  String     iocfg = null;
  Any        expr  = null;
  PhysicalIO p;
}
{
  "iobind"
  "("
  (
    ( "SimpleSqlIO" { ioclass = token.kind; }
      ","
      [LOOKAHEAD(Name() ":") (Name() { packageOverride = mapImport(token.image); } ":" )]
      <IDENTIFIER> { iocfg = token.image; }
    )
    |
    ( "CsvIO" { ioclass = token.kind; }
      ","
      expr = Expression()
    )
  )
  // add other cases as they are developed
  ")"
  {
    try
    {
      switch(ioclass)
      {
        case SIMPLESQLIO:
          SimpleSqlIO s  = new SimpleSqlIO();
          s.useSqlServer(new ConstString(packageOverride + "." + iocfg));
          p = s;
          break;

        case CSVIO:
          CsvIO c  = new CsvIO();
          Map m = AbstractComposite.simpleMap();
          m.add(CsvIO.FILE, expr);
          c.setAuxInfo(m, null);
          c.setDescriptor(d);
          p = c;
          break;

        default:
          p = new NullIO();
          break;
      }
    }
    catch(AnyException e)
    {
      throw new RuntimeContainedException(e);
    }
    return p;
  }
}

// End Declarations

// Privilege Handling
/*
Any SetPrivilege() :
{
  Any node;
  Map priv;
  Any key   = null; // optional args
  Any merge = null;
  int line;
}
{
  "setprivilege" { line = token.beginLine; }
  "("
  node = Expression()
  ","
  priv = Privilege(false)
  [ ","
    merge = Expression()
    [ ","
      key = BooleanLiteralAsAny()
    ]
  ]
  ")"
  {
    SetPrivilege s = new SetPrivilege(node, priv, merge, key);
    s.setLineNumber(line);
    return s;
  }
}
*/

// parse out a privilege specification which takes the form
//   privilege(<prigilege> : <level> [, <privilege> : <level>] ... )
// where <level> is one of r (read)
//                         w (write - meaning assign to)
//                         a (add - a new child node)
//                         v (remove - a child node)
// Generate a map containing the parsed results against their well-known
// keys.
Map Privilege(boolean resolveNow) :
{
  Map ret = null;
}
{
  "privilege"
  "("
  ( ( ret = PrivilegeItem(ret, resolveNow) )
    ( "," ret = PrivilegeItem(ret, resolveNow) )?
  )
  ")"
  {
    return ret;
  }
}

Map PrivilegeItem(Map ret, boolean resolveNow) :
{
  String priv;
  Any    key;
  Any    expr;
}
{
  <IDENTIFIER> { priv = token.image; }
  {
    if (priv.length() != 1 || "rwav".indexOf(priv) < 0) // consider making allowed set a parameter
      throw new AnyRuntimeException
        ("Illegal privilege syntax '" +
         priv +
         "' expected r|w|a|v:<expr> at line " +
         token.beginLine +
         ", column " + token.beginColumn);

    if (priv.equals("r"))
      key = P_READ;
    else if (priv.equals("w"))
      key = P_WRITE;
    else if (priv.equals("a"))
      key = P_ADD;
    else
      key = P_REMOVE;
  }
  ":"
  expr = Expression()
  {
    if (ret == null)
      ret = AbstractComposite.simpleMap();

    if (resolveNow)
    {
      try
      {
        expr = EvalExpr.evalFunc(userTxn_, userTxn_.getContext(), expr);
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }
    }

    if (expr != null)
      ret.add(key, expr);

    return ret;
  }
}

// Block Statement.  Don't add empty statements

Any Block() :
{ Array a   = AbstractComposite.array();
  Any   any = null;
  int   line;
}
{
  "{" { blockLevel_++; line = token.beginLine;}
  (any = Statement() { if (a != null && a != nonExec__) a.add(any); } )*
  "}" { blockLevel_--; }
  {
    /*
    int e = a.entries();

    if (e == 0)
      return nonExec__;

    if (e == 1)
      return a.get(0);
    */

    Sequence s = new Sequence(a);
    s.setLineNumber(line);
    return s;
  }
}

// Names that could consist of . separated elements
void Name() :
{ String str;}
{
  ( <IDENTIFIER>
  | <NAME>
  )
}

// A bit like Name() but constrains the token to the form x.y (i.e.
// only two elements.  Used for field imports.  Returns the type and
// sets token.image to the field name.  Croaks if the expression
// is x.y.z or longer.  Bit hacky but also allows IDENTIFIER to
// copy with enums, which are implemented as typedefs with only one
// field
String FieldImport() :
{ int dotIdx; }
{
  <NAME>
  {
    if ((dotIdx = token.image.indexOf('.')) != token.image.lastIndexOf('.'))
      throw new AnyRuntimeException("Illegal parameter syntax " +
                                    token.image +
                                    " at line " + token.beginLine +
                                    " column " + token.beginColumn);

    String typ = token.image.substring(0, dotIdx);
    token.image = token.image.substring(dotIdx + 1);

    return typ;
  }
  |
  <IDENTIFIER>
  {
    return token.image;
  }
}

/*
void Name() :
{ String str;}
{
  <IDENTIFIER> { str = token.image; }
  ( LOOKAHEAD( { getToken(1).kind == DOT && getToken(2).kind == IDENTIFIER } )
    "." { str += token.image; } <IDENTIFIER> { str += token.image; }
  )*
  { token.image = str; }
}
*/
// -------------------------- GUI --------------------------

Any GuiDeclaration() :
{
  Any    a;
  Locate l;
}
{
  ( "gWindow"      { a = new GuiInstantiator ("com.inqwell.any.client.swing.JFrame",  "com.inqwell.any.client.AnyFrame"); }
  | a = DialogInstantiation()
  | "gIWindow"     { a = new GuiInstantiator ("com.inqwell.any.client.swing.JInternalFrame", "com.inqwell.any.client.AnyInternalFrame"); }
  | "gBox"         { a = new GuiInstantiator ("com.inqwell.any.client.swing.JPanel", "com.inqwell.any.client.AnyBox"); }
  | "gHBox"        { a = new BoxInstantiator ("com.inqwell.any.client.swing.JPanel", "com.inqwell.any.client.AnyBox", JPanel.X_AXIS); }
  | "gVBox"        { a = new BoxInstantiator ("com.inqwell.any.client.swing.JPanel", "com.inqwell.any.client.AnyBox", JPanel.Y_AXIS); }
  | "gCard"        { a = new GuiInstantiator ("com.inqwell.any.client.swing.JPanel", "com.inqwell.any.client.AnyCard"); }
  | "gButton"      { a = new GuiInstantiator ("javax.swing.JButton", "com.inqwell.any.client.AnyButton"); }
  | "gArrow"       { a = new ArrowInstantiator ("javax.swing.plaf.basic.BasicArrowButton", "com.inqwell.any.client.AnyArrowButton"); }
  | "gToggle"      { a = new GuiInstantiator ("javax.swing.JToggleButton", "com.inqwell.any.client.AnyCheck"); }
  | "gCheck"       { a = new GuiInstantiator ("javax.swing.JCheckBox", "com.inqwell.any.client.AnyCheck"); }
  | "gRadio"       { a = new GuiInstantiator ("javax.swing.JRadioButton", "com.inqwell.any.client.AnyRadio"); }
  | "gTable"       { a = new GuiInstantiator ("com.inqwell.any.client.swing.JTable", "com.inqwell.any.client.AnyTable"); }
  | "gList"        { a = new GuiInstantiator ("com.inqwell.any.client.swing.JList", "com.inqwell.any.client.AnyList"); }
  | "gTree"        { a = new GuiInstantiator ("com.inqwell.any.client.swing.JTree", "com.inqwell.any.client.AnyTree"); }
  | "gToolBar"     { a = new GuiInstantiator ("javax.swing.JToolBar", "com.inqwell.any.client.AnyToolBar"); }
  | "gMenuBar"     { a = new GuiInstantiator ("com.inqwell.any.client.swing.JMenuBar", "com.inqwell.any.client.AnyMenuBar"); }
  | "gMenu"        { a = new GuiInstantiator ("com.inqwell.any.client.swing.JMenu", "com.inqwell.any.client.AnyMenu"); }
  | "gLabel"       { a = new GuiInstantiator ("javax.swing.JLabel", "com.inqwell.any.client.AnyLabel"); }
  | "gMenuButton"  { a = new GuiInstantiator ("com.inqwell.any.client.swing.JMenuItem", "com.inqwell.any.client.AnyButton"); }
  | "gMenuCheck"   { a = new GuiInstantiator ("com.inqwell.any.client.swing.JCheckBoxMenuItem", "com.inqwell.any.client.AnyCheck"); }
  | "gMenuRadio"   { a = new GuiInstantiator ("com.inqwell.any.client.swing.JRadioButtonMenuItem", "com.inqwell.any.client.AnyRadio"); }
  | "gPopupMenu"   { a = new GuiInstantiator ("com.inqwell.any.client.swing.JPopupMenu", "com.inqwell.any.client.AnyPopupMenu"); }
  | "gButtonGroup" { a = new GuiInstantiator ("javax.swing.ButtonGroup", "com.inqwell.any.client.AnyButtonGroup"); }
  | "gTextField"   { a = new GuiInstantiator ("com.inqwell.any.client.swing.JTextField", "com.inqwell.any.client.AnyText"); }
  | "gPasswdField" { a = new GuiInstantiator ("javax.swing.JPasswordField", "com.inqwell.any.client.AnyText"); }
  | "gTextArea"    { a = new GuiInstantiator ("com.inqwell.any.client.swing.JTextArea", "com.inqwell.any.client.AnyText"); }
  | "gTextPane"    { a = new GuiInstantiator ("com.inqwell.any.client.swing.JTextPane", "com.inqwell.any.client.AnyText"); }
  | "gTab"         { a = new GuiInstantiator ("javax.swing.JTabbedPane", "com.inqwell.any.client.AnyTabbedPane"); }
  | "gSplit"       { a = new GuiInstantiator ("com.inqwell.any.client.swing.JSplitPane", "com.inqwell.any.client.AnySplit"); }
  | "gComboBox"    { a = new GuiInstantiator ("com.inqwell.any.client.swing.JComboBox", "com.inqwell.any.client.AnyComboBox"); }
  | "gFileChooser" { a = new GuiInstantiator ("com.inqwell.any.client.swing.JFileChooser", "com.inqwell.any.client.AnyFileChooser"); }
  | "gSpinner"     { a = new GuiInstantiator ("javax.swing.JSpinner", "com.inqwell.any.client.AnySpinner"); }
  | "gDateChooser" { a = new GuiInstantiator ("com.inqwell.any.client.swing.JDateChooser", "com.inqwell.any.client.AnyDateChooser"); }
  | "gProgressBar" { a = new GuiInstantiator ("javax.swing.JProgressBar", "com.inqwell.any.client.AnyProgressBar"); }
  | "gSlider"      { a = new GuiInstantiator ("javax.swing.JSlider", "com.inqwell.any.client.AnySlider"); }
  | "gDesktop"     { a = new GuiInstantiator ("com.inqwell.any.client.swing.JDesktopPane",  "com.inqwell.any.client.AnyDesktopPane"); }
  | "gMDI"         { a = new MDIInstantiator ("com.inqwell.any.client.swing.JFrame",  "com.inqwell.any.client.AnyFrame"); }
  | a = DockInstantiation()
//  | "gDockActions" { a = new GuiInstantiator ("com.inqwell.any.client.dock.RootActionContainer", "com.inqwell.any.client.dock.AnyRootActionContainer"); }
  | "gDockButton"  { a = new GuiInstantiator ("bibliothek.gui.dock.common.action.CButton", "com.inqwell.any.client.dock.AnyCAction"); }
  | "gDockRadio"  { a = new GuiInstantiator ("com.inqwell.any.client.dock.CRadioButton", "com.inqwell.any.client.dock.AnyCRadio"); }
  | "gDockCheck"  { a = new GuiInstantiator ("com.inqwell.any.client.dock.CCheckBox", "com.inqwell.any.client.dock.AnyCCheck"); }
  | "gDockMenu"    { a = new GuiInstantiator ("com.inqwell.any.client.dock.CMenu", "com.inqwell.any.client.dock.AnyCAction"); }
  | "gDockDropDown" { a = new GuiInstantiator ("com.inqwell.any.client.dock.CDropDownButton", "com.inqwell.any.client.dock.AnyCAction"); }
  | "gDockPopup"   { a = new GuiInstantiator ("com.inqwell.any.client.dock.CPanelPopup", "com.inqwell.any.client.dock.AnyCPanelPopup"); }
  | "gDockButtonGroup" { a = new GuiInstantiator ("bibliothek.gui.dock.common.action.CRadioGroup", "com.inqwell.any.client.dock.AnyCButtonGroup"); }
  )
  l = NodeRef()

  {
    Declare d = new Declare(l, a);
    d.setLineNumber(l.getLineNumber());
    return d;
  }
}

Any DialogInstantiation() :
{
  Any parent = null;
}
{
  "gDialog"
  "("
  [ parent = Expression() ]
  ")"
  {
    return new DialogInstantiator("com.inqwell.any.client.swing.JDialog", "com.inqwell.any.client.AnyDialog", parent);
  }
}

Any DockInstantiation() :
{
  Call call = null;
}
{
  "gDock"
  ( "(" call = Call() ")" )?
  {
    return new DockInstantiator(call);
  }
}

JAVACODE
Any StartGui(Any context, Map components, Map mInqRoot, AnyView awtRoot, Any rootName, Transaction t)
{
  return GuiLayout(context, components, mInqRoot, awtRoot, rootName, t);
}

Any GuiLayout(Any context, Map components, Map mInqRoot, AnyView awtRoot, Any rootName, Transaction t) :
{
  AnyView inqRoot = null;
  Object  addTo   = null;
}
{
  {
    if (awtRoot == null)
    {
      inqRoot = (AnyView)mInqRoot;
      addTo = inqRoot.getAddIn();
    }
    else
    {
      inqRoot = awtRoot;
      addTo   = awtRoot.getAddIn();
    }
  }
  //"GUI:"
  (Container(context, components, mInqRoot, addTo, rootName, t, JPanel.Y_AXIS))+
  {
    inqRoot.validate();
    // If we are a menu then adjust separators etc in case any
    // absent layout members spoil the result
    if (addTo instanceof JMenu)
    {
      JMenu menu = (JMenu)addTo;
      JMenu.adjustSeparators(menu);
    }
    else if (addTo instanceof com.inqwell.any.client.dock.RootActionContainer)
    {
      ((AnyCAction.ActionContainer)addTo).afterLayout();
    }
    return mInqRoot;
  }
  | <EOF>
  {
    inqRoot.validate();
    return mInqRoot;
  }
}

void Container(Any context, Map components, Map inqRoot, Object addTo, Any rootName, Transaction t, int axis) :
{
  Container    cAddTo          = null;
  AnyCAction.ActionContainer aAddTo = null;
  JSplitPane   jsp             = null;
  int          borderType      = -1; // no border
  AnyInt       borderStyle     = new AnyInt(GUI_LOWERED);
  AnyComponent borderComponent = null;
  Any          caption         = null;
  AnyInt       captionPos      = new AnyInt();
  AnyInt       captionJust     = new AnyInt();
  AnyInt       xMargin         = new AnyInt();
  AnyInt       yMargin         = new AnyInt();
  AnyInt       xSize           = new AnyInt(-1);
  AnyInt       ySize           = new AnyInt(-1);
  AnyFloat     align           = new AnyFloat(0.5f);
  AnyString    xGeom           = new AnyString();
  AnyString    yGeom           = new AnyString();
  int          nextAxis;
  int          splitAxis;
  Any          splitWeight     = null;
  String       wrapName        = null;
  AnyLabel     label           = null;
  JScrollPane  scrollPane      = null;
  int          fixedSpace      = 0;
  boolean      focusable       = true;
}
{
  {
    if (addTo instanceof AnyCAction.ActionContainer)
      aAddTo = (AnyCAction.ActionContainer)addTo;
    else
      cAddTo = (Container)addTo;

    xGeom.setValue("v");
    yGeom.setValue("v");
    if (addTo instanceof JToolBar)
    {
      // default to fixed geometry for tool bar children.
      xGeom.setValue("f");
      yGeom.setValue("f");
    }
    xMargin.setValue(0);
    yMargin.setValue(0);
  }

  ( borderType = BorderType(borderStyle, t)
  | borderComponent = BorderComponent(inqRoot, components, t)
  | caption    = BorderCaption(captionPos, captionJust, t)
  | Margin(xMargin, yMargin, t)
  | Geometry(xGeom, yGeom, t)
  | Alignment(align, t)
  | Size(xSize, ySize, t)
  | scrollPane = Scroll()
  | focusable = Nofocus(t)
  )*
  //{ t.setLineNumber(lineOffset_ + token.endLine); }
  ( ( <IDENTIFIER>
      {
        //t.setLineNumber(lineOffset_ + token.endLine);

        // Named component in the given set.  Extract it,
        // do geometry etc and add to current container

        Any componentName = AbstractValue.flyweightString(token.image);
        if (!components.contains(componentName))
          return;
        AnyView      v = (AnyView)components.get(componentName);
        AnyComponent c = null;
        // Explicit null check
        if (v == null)
          throw new AnyRuntimeException("Component " + componentName + " is null");
        Object o = v.getAddee();
        if (v instanceof AnyComponent)
        {
          // border, geom
          c = (AnyComponent)v;
          if (doBorder(c))
            setBorder (c,
                       borderType,
                       borderStyle,
                       borderComponent,
                       caption,
                       captionPos,
                       captionJust,
                       xMargin,
                       yMargin,
                       context,
                       t);

          if (doGeometry(c))
          {
            setGeometry(c, xGeom, yGeom);
            setAlignment(c, axis, align);
          }

          if (doSize(c))
            setSize(c, xSize, ySize);

          if (!focusable)
            c.getComponent().setFocusable(false);

        }

        //if (!(o instanceof ButtonGroup)) // no awt hierarchy for button groups
        if (o != null) // no native hierarchy when null
        {
          if (cAddTo != null)
          {
            if (!(cAddTo instanceof JTabbedPane)) // inq does awt for tabs dependent on initial visibility
            {
              // Card has mandatory constraints
              if (inqRoot instanceof AnyCard)
                cAddTo.add((Component)o, componentName.toString());
              else
              {
                cAddTo.add((Component)o);
                // Check if we are adding to a toolbar. In this case, set button margin
                // to zero (doesn't work)
                /**
                if (cAddTo instanceof JToolBar && v instanceof AnyButton)
                {
                  AbstractButton b = (AbstractButton)v.getComponent();
                  b.setMargin(AnyComponent.noMargin__);
                  //b.setBorder(null);
                }
                */
              }
            }
          }
          else
          {
            // Its a docking action. The addee must be a CAction
            if (o instanceof CAction)
            {
              aAddTo.add((CAction)o);
            }
          }
        }

        // Check if the name already exists in the Inq root and is the
        // same object as we are adding.  If so, script has already done
        // this bit.  Sometimes happens just so the context can be propagated
        // before layout.  If the component is not the same object as
        // already there then its a genuine duplication and we allow to throw.
        Any addAs = (rootName == null) ? componentName : rootName;
        if (!inqRoot.contains(addAs) || !inqRoot.get(addAs).equals(v))
          inqRoot.add(addAs, v); // always an inq hierarchy even if button group

          /*
        if (c != null)
        {
          if (doGeometry(c))
            setGeometry(c, xGeom, yGeom);

          if (doSize(c))
            setSize(c, xSize, ySize);
        }
          */
      }
      [ "{"
        //{ t.setLineNumber(lineOffset_ + token.endLine); }
        // Drop down a level in the awt hierarchy - for menus.
        // Also drop down a level in inq hierarchy if its a tabbed pane or a card
        (Container(context,
                   components,
                   ((v instanceof AnyTabbedPane) ||
                    (inqRoot instanceof AnyTabbedPane) ||
                    (v instanceof AnyCard) ||
                    (inqRoot instanceof AnyCard)) ? v : inqRoot,
                   v.getAddIn(),
                   null,
                   t,
                   axis))+
        "}"
        //{ t.setLineNumber(lineOffset_ + token.endLine); }
        {
          // If we are an explicit nested box then do geometry now content is in
          if (o instanceof JPanel)
          {
            setGeometry(c, xGeom, yGeom);
            setAlignment(c, axis, align);
            c.validate();
          }
          
          // If we are a menu then adjust separators etc in case any
          // absent layout members spoil the result
          if (o instanceof JMenu)
          {
            JMenu menu = (JMenu)o;
            JMenu.adjustSeparators(menu);
          }
        }
      ]
    )
  | ( ( ( <GUI_ROW> { nextAxis = JPanel.X_AXIS; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
        | <GUI_COLUMN> { nextAxis = JPanel.Y_AXIS; /*t.setLineNumber(lineOffset_ + token.endLine);*/ } )
        [ <IDENTIFIER> { wrapName = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ } ] )
        GuiBox(context, components, inqRoot, cAddTo, wrapName, nextAxis, axis, borderType, borderStyle, borderComponent, caption, captionPos, captionJust, xMargin, yMargin, xSize, ySize, xGeom, yGeom, align, scrollPane, t)
    )
  | ( <GUI_TABLE>
      [ <IDENTIFIER> { wrapName = token.image; } ]
      Grid(context, components, inqRoot, cAddTo, null, wrapName, axis, axis, borderType, borderStyle, borderComponent, caption, captionPos, captionJust, xMargin, yMargin, xSize, ySize, xGeom, yGeom, align, scrollPane, t)
    )
  | ( <TILDE> { fixedSpace = 5; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
      ( LOOKAHEAD(1) <TILDE> { fixedSpace += 5; /*t.setLineNumber(lineOffset_ + token.endLine);*/ } )*
      {
        if (fixedSpace != 0)
        {
          Component space = (axis == JPanel.X_AXIS) ? Box.createHorizontalStrut(fixedSpace)
                                                    : Box.createVerticalStrut(fixedSpace);
          if (cAddTo != null)
            cAddTo.add(space);
        }
        fixedSpace = 0;
      }
    )
  | ( <GUI_GLUE>
      {
        //t.setLineNumber(lineOffset_ + token.endLine);
        Component glue = (axis == JPanel.X_AXIS) ? Box.createHorizontalGlue()
                                                 : Box.createVerticalGlue();
        if (cAddTo != null)
          cAddTo.add(glue);
      }
    )
  | ( <GUI_LABEL> //{ t.setLineNumber(lineOffset_ + token.endLine); }
      <IDENTIFIER> { wrapName = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
      Label(context,
            components,
            inqRoot,
            cAddTo,
            null,   // TableLayoutConstraints
            wrapName,
            axis,
            borderType,
            borderStyle,
            borderComponent,
            caption,
            captionPos,
            captionJust,
            xMargin,
            yMargin,
            xSize,
            ySize,
            xGeom,
            yGeom,
            align,
            t)
    )
  | ( ( <GUI_SPLIT> { splitAxis = axis; } //{ t.setLineNumber(lineOffset_ + token.endLine); }
      | <GUI_SPLITX> { splitAxis = JPanel.X_AXIS; }
      | <GUI_SPLITY> { splitAxis = JPanel.Y_AXIS; }
      )
      [ ":" splitWeight = FloatingLiteralAsAny() ]
      [ <IDENTIFIER> { wrapName = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ } ]
      "{"
      {
        //t.setLineNumber(lineOffset_ + token.endLine);
        jsp = new JSplitPane();
        jsp.parserAxis(splitAxis);

        if (splitWeight != null)
        {
          DoubleI d = new ConstDouble(splitWeight);
          jsp.setResizeWeight(d.getValue());
        }

        cAddTo.add(jsp);

        if (wrapName != null)
        {
          AnyComponent cJsp = new AnySimpleComponent();
          cJsp.setObject(jsp);
          inqRoot.add(AbstractValue.flyweightString(wrapName), cJsp);
        }
      }
      (Container(context, components, inqRoot, jsp, null, t, axis))+
      "}"
      //{ t.setLineNumber(lineOffset_ + token.endLine); }
    )
  | ( <GUI_CARD> //{ t.setLineNumber(lineOffset_ + token.endLine); }
      <IDENTIFIER> { wrapName = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
      "{"
      {
        // Note - a card must be wrapped to be of any use.  Creation during
        // layout is only provided as a convenience (and we're not doing it
        // for tab at the moment, so this is inconsistent).
        //t.setLineNumber(lineOffset_ + token.endLine);
        JPanel jp = new JPanel();
        jp.setLayout(new CardLayout());

        cAddTo.add(jp, wrapName);
        AnyCard card = new AnyCard();

        card.setObject(jp);
        inqRoot.add(AbstractValue.flyweightString(wrapName), card);

      }
      // Drop down a level in the inq hierarchy to enable card properties on child
      (Container(context, components, card, jp, null, t, axis))+
      "}"
      //{ t.setLineNumber(lineOffset_ + token.endLine); }
    )
  | ( <GUI_SEPARATOR>
      {
        //t.setLineNumber(lineOffset_ + token.endLine);
        if (cAddTo != null)
        {
          if (cAddTo instanceof JToolBar)
          {
            JToolBar tb = (JToolBar)cAddTo;
            tb.addSeparator();
          }
          else if (cAddTo instanceof JMenu)
          {
            JMenu jm = (JMenu)cAddTo;
            jm.addSeparator();
          }
          else
          {
            Component separator = (axis == JPanel.Y_AXIS) ? new JSeparator(SwingConstants.HORIZONTAL)
                                                          : new JSeparator(SwingConstants.VERTICAL);
            cAddTo.add(separator);
          }
        }
        else if (aAddTo != null)
        {
          aAddTo.addSeparator();
        }
      }
    )
  | ( <GUI_NOTHING>  // Just so we can escape grammar traps like Label id id
    )
    // Add more child options here
  )
}

void GuiBox(Any          context,
            Map          components,
            Map          inqRoot,
            Container    cAddTo,
            String       wrapName,
            int          axis,
            int          outerAxis,
            int          borderType,
            AnyInt       borderStyle,
            AnyComponent borderComponent,
            Any          caption,
            AnyInt       captionPos,
            AnyInt       captionJust,
            AnyInt       xMargin,
            AnyInt       yMargin,
            AnyInt       xSize,
            AnyInt       ySize,
            StringI      xGeom,
            StringI      yGeom,
            FloatI       align,
            JScrollPane  scrollPane,
            Transaction  t) :
{
  JPanel       box;
  JComponent   jc;
  AnyComponent c = null;
  Map          newInqRoot = inqRoot;
}
{
  "{"
  {
    //t.setLineNumber(lineOffset_ + token.endLine);
    box = new JPanel(axis);
    jc  = box;

    if (scrollPane != null)
    {
      jc = scrollPane;
      scrollPane.setViewportView(box);
      box.setMaxUnitIncrement(10);
    }

    if (wrapName != null)
    {
      c = new AnyBox();
      c.setObject(box);
    }

    // border, margin, size
    if (c == null)
    {
      setBorder (jc,
                 borderType,
                 borderStyle,
                 borderComponent,
                 caption,
                 captionPos,
                 captionJust,
                 xMargin,
                 yMargin,
                 context,
                 t);
      setAlignment(jc, outerAxis, align);
      setSize(box, xSize, ySize);
    }
    else
    {
      // When wrapped then scroll stuff tbd!!
      setBorder (c,
                 borderType,
                 borderStyle,
                 borderComponent,
                 caption,
                 captionPos,
                 captionJust,
                 xMargin,
                 yMargin,
                 context,
                 t);
      setAlignment(c, outerAxis, align);
      setSize(c, xSize, ySize);
      inqRoot.add(AbstractValue.flyweightString(wrapName), c);
      if ((inqRoot instanceof AnyTabbedPane) ||
          (inqRoot instanceof AnyCard))
        newInqRoot = c;
    }
  }
  (Container(context, components, newInqRoot, box, null, t, axis))+
  "}"
  {
    //t.setLineNumber(lineOffset_ + token.endLine);

    if (cAddTo != null)
    {
      if (!(cAddTo instanceof JTabbedPane) &&
          jc.getComponentCount() != 0)
        cAddTo.add(jc);
    }
    // For a box geometry happens after components are added
    if (c == null)
    {
      setGeometry(box, xGeom, yGeom);
      box.validate();
    }
    else
    {
      setGeometry(c, xGeom, yGeom);
      c.validate();
    }
  }
}

void Grid(Any          context,
          Map          components,
          Map          inqRoot,
          Container    cAddTo,
          TableLayoutConstraints tlc,
          String       wrapName,
          int          axis,
          int          outerAxis,
          int          borderType,
          AnyInt       borderStyle,
          AnyComponent borderComponent,
          Any          caption,
          AnyInt       captionPos,
          AnyInt       captionJust,
          AnyInt       xMargin,
          AnyInt       yMargin,
          AnyInt       xSize,
          AnyInt       ySize,
          StringI      xGeom,
          StringI      yGeom,
          FloatI       align,
          JScrollPane  scrollPane,
          Transaction  t) :
{
  Array     defs = AbstractComposite.array();
  Map       colNames;
  Map       rowNames;
  int       count;
  double    cols[];
  double    rows[];
  AnyInt    ii = new AnyInt();
  JPanel    grid;
  AnyGrid   aGrid = null;
  AnyDouble d = new AnyDouble();
  int       hGap = -1;
  int       vGap = -1;
}
{
  [ hGap = GridGap(context, t) ]
  <GUI_COLUMNS> { count = 0; colNames = AbstractComposite.simpleMap(); }
  ( CellDef(defs, count++, colNames, context, t)  ("," CellDef(defs, count++, colNames, context, t))* )
  {
    cols = new double[defs.entries()];
    for (int i = 0; i < cols.length; i++)
    {
      d.copyFrom(defs.get(i));
      if (d.isNull())
        throw new AnyRuntimeException("Column definition cannot be null");
      cols[i] = d.getValue();
    }

    defs.empty();
  }

  [ vGap = GridGap(context, t) ]
  <GUI_ROWS> { count = 0; rowNames = AbstractComposite.simpleMap(); }
  ( CellDef(defs, count++, rowNames, context, t)  ("," CellDef(defs, count++, rowNames, context, t))* )
  {
    rows = new double[defs.entries()];
    for (int i = 0; i < rows.length; i++)
    {
      d.copyFrom(defs.get(i));
      if (d.isNull())
        throw new AnyRuntimeException("Row definition cannot be null");
      rows[i] = ((DoubleI)defs.get(i)).getValue();
    }

    grid = new JPanel(new TableLayout(cols, rows));

    if (hGap >= 0)
      grid.setHGap(hGap);

    if (vGap >= 0)
      grid.setVGap(vGap);

    setBorder (grid,
               borderType,
               borderStyle,
               borderComponent,
               caption,
               captionPos,
               captionJust,
               xMargin,
               yMargin,
               context,
               t);

    if (wrapName != null)
    {
      aGrid = new AnyGrid(grid);

      if (colNames.entries() != 0)
        aGrid.setColumnNames(colNames);

      if (rowNames.entries() != 0)
        aGrid.setRowNames(rowNames);
      
      inqRoot.add(AbstractValue.flyweightString(wrapName), aGrid);
    }
  }

  ";"   // End of cell definitions. Required to resolve expression/{ ... } grammar

  "{"
  GridContents(grid, colNames, rowNames, components, inqRoot, context, t)
  "}"
  {
    if (!(cAddTo instanceof JTabbedPane))
    {
      // Note: there is a bug here in that when we *are* adding to a JTabbedPane
      // and the awt hierarchy is handled by AnyTabbedPane, any scroll pane
      // is not taken into account.
      if (scrollPane == null)
        cAddTo.add(grid, tlc);
      else
      {
        scrollPane.setViewportView(grid);
        grid.setMaxUnitIncrement(10);
        cAddTo.add(scrollPane, tlc);
      }
    }

    if (axis != -1)
    {
      setGeometry(grid, xGeom, yGeom);
      setAlignment(grid, axis, align);
      setSize(grid, xSize, ySize);
    }
  }
}

void GridContents(JPanel      grid,
                  Map         colNames,
                  Map         rowNames,
                  Map         components,
                  Map         inqRoot,
                  Any         context,
                  Transaction t) :
{
  int     row = 0;
  int     col = 0;
  int     ref = -1;
  int     tableAxis = -1;
  int     numRow = grid.getNumRow();
  int     numCol = grid.getNumColumn();

  TableLayoutConstraints tlc;
}
{
  (
    (
      <GUI_ROW>
      {
        // If switching from column to row reset the row count,
        // otherwise increment row count or take any reference value.
        if (tableAxis != JPanel.X_AXIS)
        {
          tableAxis = JPanel.X_AXIS;
          row = -1;
        }

        // When entering a new Row initialise the column to zero
        col = 0;

        ref = -1;
      }

      // If an explicit Row number has been given use it, otherwise use next row
      [ LOOKAHEAD(RowColRef()) ref = RowColRef(rowNames, context, t, "row") ]
      {
        if (ref >= 0)
          row = ref;
        else
          row++;
      }

      "{"
       (
         tlc = GridChild(grid, null, row, col, tableAxis, colNames, rowNames, components, inqRoot, context, t)
         {
           // In a row, set the next column to use according to however many were
           // consumed by the current grid child
           if (tlc != null)
             col = tlc.col2 + 1;
         }
       )+
      "}"
    )
    |
    (
      <GUI_COLUMN>
      {
        // If switching from row to column reset the column count,
        // otherwise increment column count or take any reference value.
        if (tableAxis !=  JPanel.Y_AXIS)
        {
          tableAxis = JPanel.Y_AXIS;
          col = -1;
        }

        // When entering a new Column initialise the row to zero
        row = 0;

        ref = -1;
      }

      // If an explicit Column number has been given use it, otherwise use next column
      [ LOOKAHEAD(RowColRef()) ref = RowColRef(colNames, context, t, "column") ]
      {
        if (ref >= 0)
          col = ref;
        else
          col++;
      }

      "{"
       (
         tlc = GridChild(grid, null, row, col, tableAxis, colNames, rowNames, components, inqRoot, context, t)
         {
           // In a column, set the next row to use according to however many were
           // consumed by the current grid child
           if (tlc != null)
             row = tlc.row2 + 1;
         }
      )+
      "}"
    )
    |
    (
      // Can define individual cells outside of row/col. No auto-increment of
      // either axis in this case.
      tlc = TableCellSpec(new TableLayoutConstraints(), colNames, rowNames, context, t)
      GridChild(grid, tlc, row, col, -1, colNames, rowNames, components, inqRoot, context, t)
    )
  )+  // or at least one ?
}

TableLayoutConstraints GridChild(JPanel                 grid,
                                 TableLayoutConstraints gTlc,
                                 int                    row,
                                 int                    col,
                                 int                    tableAxis,
                                 Map                    colNames,
                                 Map                    rowNames,
                                 Map                    components,
                                 Map                    inqRoot,
                                 Any                    context,
                                 Transaction            t) :
{
  int          borderType      = -1; // no border
  AnyInt       borderStyle     = new AnyInt(GUI_LOWERED);
  AnyComponent borderComponent = null;
  Any          caption         = null;
  AnyInt       captionPos      = new AnyInt();
  AnyInt       captionJust     = new AnyInt();
  AnyInt       xMargin         = new AnyInt();
  AnyInt       yMargin         = new AnyInt();
  boolean      focusable       = true;
  JScrollPane  scrollPane      = null;
  String       wrapName        = null;
  int          axis            = -1;
  int          splitAxis;
  Any          splitWeight     = null;
  JSplitPane   jsp             = null;

  TableLayoutConstraints tlc   = (gTlc == null) ? new TableLayoutConstraints(col, row)
                                                : gTlc;
}
{
  ( borderType = BorderType(borderStyle, t)
  | borderComponent = BorderComponent(inqRoot, components, t)
  | caption    = BorderCaption(captionPos, captionJust, t)
  | Margin(xMargin, yMargin, t)
  | TableCellAlignment(tlc, t)
  //| TableCellSpec(tlc, colNames, rowNames, context, t)
  | TableCellSpan(grid, tlc, colNames, rowNames, context, t)
  | scrollPane = Scroll()
  | focusable = Nofocus(t)
  )*
  (
    (
      <IDENTIFIER>
      {
        // Named component in the given set.  Extract it,
        // do border etc and add to current container

        Any componentName = AbstractValue.flyweightString(token.image);
        if (!components.contains(componentName))
          return null;
        AnyView      v = (AnyView)components.get(componentName);
        AnyComponent c = null;
        // Explicit null check
        if (v == null)
          throw new AnyRuntimeException("Component " + componentName + " is null");

        Object o = v.getAddee();
        if (v instanceof AnyComponent)
        {
          c = (AnyComponent)v;
          if (doBorder(c))
            setBorder (c,
                       borderType,
                       borderStyle,
                       borderComponent,
                       caption,
                       captionPos,
                       captionJust,
                       xMargin,
                       yMargin,
                       context,
                       t);

          if (!focusable)
            c.getComponent().setFocusable(false);

        }

        //if (o instanceof ButtonGroup) // no awt hierarchy for button group
        if (o == null) // no native hierarchy for this view
        {
          tlc = null;
        }
        else
        {
          if (scrollPane == null)
            grid.add((Component)o, tlc);
          else
          {
            if (o instanceof JPanel)
            {
              scrollPane.setViewportView((Component)o);
              ((JPanel)o).setMaxUnitIncrement(10);
              grid.add(scrollPane, tlc);
            }
            else
              grid.add((Component)o, tlc);
          }
        }


        // Check if the name already exists in the Inq root and is the
        // same object as we are adding.  If so, script has already done
        // this bit.  Sometimes happens just so the context can be propagated
        // before layout.  If the component is not the same object as
        // already there then its a genuine duplication and we allow to throw.
        if (!inqRoot.contains(componentName) || !inqRoot.get(componentName).equals(v))
          inqRoot.add(componentName, v); // always an inq hierarchy even if button group

      }
      [ "{"
        {
          if (o instanceof JPanel)
            axis = ((JPanel)o).getAxis();

          // axis could be -1 if the panel is not a Box but then
          // we go to the Grid grammar anyway
        }
        // Drop down a level in the awt hierarchy
        // Also drop down a level in inq hierarchy if we are
        // adding a tab pane or a card as these have Inq
        // hierarchy requirements.
        ( LOOKAHEAD( { isGrid(v) } )
          GridContents((JPanel)o, colNames, rowNames, components, inqRoot, context, t)
          |
          (Container(context,
                     components,
                     ((v instanceof AnyTabbedPane) ||
                      (v instanceof AnyCard)) ? v : inqRoot,
                     o,
                     null,
                     t,
                     axis))+
        )

        "}"
      ]
    )
    |
    ( <GUI_LABEL> //{ t.setLineNumber(lineOffset_ + token.endLine); }
      <IDENTIFIER> { wrapName = token.image; }
      Label(context,
            components,
            inqRoot,
            grid,
            tlc,
            wrapName,
            -1,                 // axis Not used when in a grid
            borderType,
            borderStyle,
            borderComponent,
            caption,
            captionPos,
            captionJust,
            xMargin,
            yMargin,
            null,               // xSize Not used when in a grid
            null,               // ySize Not used when in a grid
            null,               // xGeom Not used when in a grid
            null,               // yGeom Not used when in a grid
            null,               // align Not used when in a grid
            t)
    )
    |
    (
      <GUI_TABLE>
      [ <IDENTIFIER> { wrapName = token.image; } ]
      Grid(context,
           components,
           inqRoot,
           grid,
           tlc,
           wrapName,
           -1,                 // axis Not used when in a grid
           -1,                 // ourerAxis Not used when in a grid
           borderType,
           borderStyle,
           borderComponent,
           caption,
           captionPos,
           captionJust,
           xMargin,
           yMargin,
           null,               // xSize Not used when in a grid
           null,               // ySize Not used when in a grid
           null,               // xGeom Not used when in a grid
           null,               // yGeom Not used when in a grid
           null,               // align Not used when in a grid
           scrollPane,
           t)
    )
    |
    (
      ( <GUI_SPLITX> { splitAxis = JPanel.X_AXIS; }
      | <GUI_SPLITY> { splitAxis = JPanel.Y_AXIS; }
      )
      [ ":" splitWeight = FloatingLiteralAsAny() ]
      [ <IDENTIFIER> { wrapName = token.image; } ]
      "{"
      {
        jsp = new JSplitPane();
        jsp.parserAxis(splitAxis);

        if (splitWeight != null)
        {
          DoubleI d = new ConstDouble(splitWeight);
          jsp.setResizeWeight(d.getValue());
        }

        grid.add(jsp, tlc);

        if (wrapName != null)
        {
          AnyComponent cJsp = new AnySimpleComponent();
          cJsp.setObject(jsp);
          inqRoot.add(AbstractValue.flyweightString(wrapName), cJsp);
        }
      }
      (Container(context, components, inqRoot, jsp, null, t, splitAxis))+
      "}"
    )
    |
    ( <GUI_CARD>
      <IDENTIFIER> { wrapName = token.image; }
      "{"
      {
        // Note - a card must be wrapped to be of any use.  Creation during
        // layout is only provided as a convenience (and we're not doing it
        // for tab at the moment, so this is inconsistent).
        //t.setLineNumber(lineOffset_ + token.endLine);
        JPanel jp = new JPanel();
        jp.setLayout(new CardLayout());

        grid.add(jp, tlc);
        AnyCard card = new AnyCard();

        card.setObject(jp);
        inqRoot.add(AbstractValue.flyweightString(wrapName), card);
      }
      // Drop down a level in the inq hierarchy to enable card properties on child
      (Container(context, components, card, jp, null, t, JPanel.Y_AXIS))+
      "}"
    )
    |
    ( <GUI_SEPARATOR>
      {
        // When not in a row or column inspect cell occupancy
        if (tableAxis < 0)
        {
          Component separator = null;
          
          // If not in a row or column then check the cell constraints.
          // When the start/end columns are the same create a vertical
          // separator; when the start/end rows are the same create a
          // horizontal separator
          if (tlc.col1 == tlc.col2)
            separator = new JSeparator(SwingConstants.VERTICAL);
          else if (tlc.row1 == tlc.row2)
            separator = new JSeparator(SwingConstants.HORIZONTAL);
          
          if (separator != null)
            grid.add(separator, tlc);
          else
            return null;
        }
        else
        {
          Component separator = (tableAxis == JPanel.Y_AXIS) ? new JSeparator(SwingConstants.HORIZONTAL)
                                                             : new JSeparator(SwingConstants.VERTICAL);
          grid.add(separator, tlc);
        }
      }
    )
    |
    (
      <GUI_NOTHING>  // Just so we can escape grammar traps like Label id id
      {
        // Do not skip over cells when in row/col construct
        tlc = null;
      }
    )
    |
    (
      <TILDE>    // Step over current cell when in row/col
    )
  )
  {
    return tlc;
  }
}

TableLayoutConstraints TableCellSpec(TableLayoutConstraints tlc,
                                     Map                    colNames,
                                     Map                    rowNames,
                                     Any                    context,
                                     Transaction            t) :
{
  int col1;
  int row1;
  int col2 = -1;
  int row2 = -1;
}
{
  // "Cell" followed by mandatory col/row and then optional col/row pair
  <GUI_CELL>

  col1 = RowColRef(colNames, context, t, "column")
  row1 = RowColRef(rowNames, context, t, "row")

  ( LOOKAHEAD(RowColRef() RowColRef())
    col2 = RowColRef(colNames, context, t, "column")
    row2 = RowColRef(rowNames, context, t, "row")
  )?

  {
    tlc.col1 = col1;
    tlc.row1 = row1;

    if (col2 != -1)
    {
      tlc.col2 = col2;
      tlc.row2 = row2;
    }
    else
    {
      tlc.col2 = col1;
      tlc.row2 = row1;
    }
    return tlc;
  }
}

void TableCellAlignment(TableLayoutConstraints tlc, Transaction t) :
{
  int hAlign;
  int vAlign;
}
{
  <GUI_ALIGN>
  <IDENTIFIER>
  {
    // Set default justifications in the constraint to FULL
    hAlign = vAlign = TableLayoutConstants.FULL;

    if (token.image.length() > 2)
      throw new AnyRuntimeException("Illegal cell justification " + token.image);

    vAlign = tableCellAlignment(token.image.charAt(0));

    if (token.image.length() == 2)
      hAlign = tableCellAlignment(token.image.charAt(1));
    else if (vAlign == TableLayoutConstants.CENTER)
      hAlign = TableLayoutConstants.CENTER;
    //else
      //throw new AnyRuntimeException("Missing vertical alignment");

    tlc.hAlign = hAlign;
    tlc.vAlign = vAlign;
  }
}

void TableCellSpan(JPanel                 grid,
                   TableLayoutConstraints tlc,
                   Map                    colNames,
                   Map                    rowNames,
                   Any                    context,
                   Transaction            t) :
{
  int span = -1;
}
{
  (
    (
      <GUI_HSPAN>
      span = RowColRef(colNames, context, t, "column")
      {
        tlc.col2 = span;
      }
    )
    |
    (
      <GUI_VSPAN>
      span = RowColRef(rowNames, context, t, "row")
      {
        tlc.row2 = span;
      }
    )
  )
}

int RowColRef(Map names, Any context, Transaction t, String name) :
{
  int    ref = -1;
  Any    a;
  AnyInt ii = new AnyInt();
}
{
  (
    LOOKAHEAD(Expression() ";")
    (
      a = Expression()
      ";"
    )
    {
      Any aa = null;
      try
      {
        aa = EvalExpr.evalFunc(t, context, a);
      }
      catch(AnyException e)
      {
        throw new RuntimeContainedException(e);
      }

      if (aa == null)
        throw new AnyRuntimeException(name + " reference " + a + " could not be resolved");

      ii.copyFrom(aa);

      if (ii.isNull())
        throw new AnyRuntimeException(name + " reference " + a + " cannot be null");
      
      ref = ii.getValue();
    }
    |
    <INTEGER_LITERAL>
    {
      ii.fromString(token.image);

      if (ii.getValue() < 0 || ii.isNull())
        throw new AnyRuntimeException("Illegal " + name + " value " + token.image);

      ref = ii.getValue();
    }
    |
    <IDENTIFIER>
    {
      if (names == null)
        throw new AnyRuntimeException("Cell symbols are not available");

      Any s = AbstractValue.flyweightString(token.image);
      if ((a = names.getIfContains(s)) == null)
        throw new AnyRuntimeException("Undefined " + name + " symbol " + token.image);

      IntI i = (IntI)a;
      ref = i.getValue();
    }
  )
  {
    return ref;
  }
}

void CellDef(Array cellArray, int count, Map names, Any context, Transaction t) :
{
  AnyDouble d       = new AnyDouble();
  Any       cell;
  Any       name = null;
}
{
  [LOOKAHEAD(<IDENTIFIER> "=") ( <IDENTIFIER> { name = AbstractValue.flyweightString(token.image); } "=" ) ]

  cell = Expression()
  {
    Any a = null;
    try
    {
      a = EvalExpr.evalFunc(t, context, cell);
    }
    catch (AnyException e)
    {
      throw new RuntimeContainedException(e);
    }

    if (a == null)
      throw new AnyRuntimeException("Cell specification " + cell + " could not be resolved");

    d.copyFrom(a);

    if (d.isNull())
      throw new AnyRuntimeException("Cell specification " + cell + " cannot be null");


    cellArray.add(d);

    if (name != null)
    {
      IntI i = new AnyInt(count);
      names.add(name, i);
    }
  }
}

int GridGap(Any context, Transaction t) :
{
  AnyInt i = new AnyInt();
  Any    gap;
}
{
  (
    <GUI_GAP>
    gap = Expression()
    {
      Any a = null;
      try
      {
        a = EvalExpr.evalFunc(t, context, gap);
      }
      catch (AnyException e)
      {
        throw new RuntimeContainedException(e);
      }

      if (a == null)
        throw new AnyRuntimeException("Gap specification " + gap + " could not be resolved");

      i.copyFrom(a);

      if (i.isNull())
        throw new AnyRuntimeException("Gap specification " + gap + " cannot be null");

      return i.getValue();
    }
  )
}

void Label(Any          context,
           Map          components,
           Map          inqRoot,
           Container    cAddTo,
           TableLayoutConstraints tlc,
           String       wrapName,
           int          axis,
           int          borderType,
           AnyInt       borderStyle,
           AnyComponent borderComponent,
           Any          caption,
           AnyInt       captionPos,
           AnyInt       captionJust,
           AnyInt       xMargin,
           AnyInt       yMargin,
           AnyInt       xSize,
           AnyInt       ySize,
           StringI      xGeom,
           StringI      yGeom,
           FloatI       align,
           Transaction  t) :
{
  AnyLabel     label       = null;
  AnyComponent labeled     = null;
  JLabel       jLabel      = null;
  String       labeledName = null;
}
{
  [ LOOKAHEAD(1) <IDENTIFIER>
    { labeledName = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  ]
  {
    // If there is a labeledName then that is the name of the
    // component we are a label for and wrapName (passed in) is
    // the name of the label.  If there is no labeledName then
    // the label is anonymous and wrapName is the name of
    // labeled component.
    // If there is a labeledName then we use wrapName to check
    // the components to see if the label has already been created.
    // If so then we use that, otherwise we create on the fly and
    // place in the Inq hierarchy.
    if (labeledName == null)
    {
      labeledName = wrapName;
      wrapName    = null;
    }

    Any labeledKey = AbstractValue.flyweightString(labeledName);
    if (!components.contains(labeledKey) ||
        (!(components.get(labeledKey) instanceof AnyComponent)))
    {
      // nrg - silently ignore
      return;
      //throw new AnyRuntimeException("The specified labeled component:" + labeledKey + " cannot be found");
    }

    labeled = (AnyComponent)components.get(labeledKey);

    if (wrapName != null)
    {
      Any labelKey = AbstractValue.flyweightString(wrapName);
      if (components.contains(labelKey))
      {
        if (!(components.get(labelKey) instanceof AnyLabel))
          throw new AnyRuntimeException("Component referenced as a label is not a gLabel");

        label  = (AnyLabel)components.get(labelKey);
        jLabel = (JLabel)label.getComponent();
      }
      else
      {
        // create label on the fly
        label = new AnyLabel();
        label.setObject(jLabel = new JLabel());
      }
      // Place label in Inq hierarchy
      inqRoot.add(labelKey, label);
      label.setLabelFor(labeled);
    }
    else
    {
      // label is anonymous - don't create Inq wrapper
      jLabel = new JLabel();
      jLabel.setText(labeled.getLabel());
      jLabel.setLabelFor(labeled.getComponent());
      labeled.setLabelledBy(jLabel);
    }

    // Setup geometry etc
    if (label == null)
    {
      setBorder (jLabel,
                 borderType,
                 borderStyle,
                 borderComponent,
                 caption,
                 captionPos,
                 captionJust,
                 xMargin,
                 yMargin,
                 context,
                 t);
      if (tlc == null)
      {
        setGeometry(jLabel, xGeom, yGeom);
        setAlignment(jLabel, axis, align);
        setSize(jLabel, xSize, ySize);
      }
    }
    else
    {
      setBorder (label,
                 borderType,
                 borderStyle,
                 borderComponent,
                 caption,
                 captionPos,
                 captionJust,
                 xMargin,
                 yMargin,
                 context,
                 t);
      if (tlc == null)
      {
        setGeometry(label, xGeom, yGeom);
        setAlignment(label, axis, align);
        setSize(label, xSize, ySize);
      }
    }

    // Put the swing label into the swing hierarchy
    if (cAddTo != null)
    {
      // ok if tlc is null

      if (label != null)
        cAddTo.add((Component)label.getAddee(), tlc);
      else
        cAddTo.add(jLabel, tlc);
    }
  }
}

int BorderType(AnyInt style, Transaction t) :
{ int borderType = -1; }
{
  ( ( ( <GUI_ETCHED> | <GUI_BEVELED> )
      {
        borderType = token.kind;
        //t.setLineNumber(lineOffset_ + token.endLine);
      }
    BorderStyle(style, t) )
  | ( <GUI_LINE>
    | <GUI_NONE>
    )
    {
      borderType = token.kind;
      //t.setLineNumber(lineOffset_ + token.endLine);
    }
  )
  {
    return borderType;
  }
}

void BorderStyle(AnyInt style, Transaction t) :
{}
{
  (<GUI_RAISED> | <GUI_LOWERED>)
  {
    //t.setLineNumber(lineOffset_ + token.endLine);
    style.setValue(token.kind);
  }
}

Any BorderCaption(AnyInt position, AnyInt justification, Transaction t) :
{
  Any    a = null;
  String s = null;
}
{
  <GUI_CAPTION> //{ t.setLineNumber(lineOffset_ + token.endLine); }
  [ LOOKAHEAD(2) BorderCaptionPositioning(position, justification, t) ]
  ( LOOKAHEAD(LiteralAsString()) s = LiteralAsString() ";" { a = new ConstString(s); }
  | a = Expression() ";"
  )
  {
    //t.setLineNumber(lineOffset_ + token.endLine);
    return a;
  }
}

AnyComponent BorderComponent(Map inqRoot, Map components, Transaction t) :
{
}
{
  <GUI_COMPONENT>
  <IDENTIFIER>
  {
    Any componentName = new ConstString(token.image);
    if (!components.contains(componentName))
      return null;
    AnyComponent v = (AnyComponent)components.get(componentName);

    // Add the border component to the inqRoot and return it
    inqRoot.add(componentName, v);

    return v;
  }
}

void BorderCaptionPositioning(AnyInt position, AnyInt justification, Transaction t) :
{ String jpos = null; }
{
  {
    position.setValue(MakeComponent.top__);
    justification.setValue(MakeComponent.left__);
  }
  <IDENTIFIER>
  {
    //t.setLineNumber(lineOffset_ + token.endLine);
    int len = 0;
    String pos;
    String j;
    jpos = token.image;
    // valid strings are [at|t|bt|ab|b|bb][l|c|r]
    if ((len = jpos.length()) != 2 && len != 3)
      throw new AnyRuntimeException(jpos + " not a valid caption position");

    if (len == 2)
    {
      pos = jpos.substring(0, 1);
      j   = jpos.substring(1, 2);
    }
    else
    {
      pos = jpos.substring(0, 2);
      j   = jpos.substring(2, 3);
    }

    if (!captionPos__.containsKey(pos))
      throw new AnyRuntimeException(pos + " not a valid caption position");

    if (!captionJust__.containsKey(j))
      throw new AnyRuntimeException(j + " not a valid caption justification");

    IntI iPos  = (IntI)captionPos__.get(pos);
    IntI iJust = (IntI)captionJust__.get(j);

    position.setValue(iPos.getValue());
    justification.setValue(iJust.getValue());
  }
}

void Margin(AnyInt x, AnyInt y, Transaction t) :
{
  String axis;
  String margin;
}
{
  <GUI_MARGIN> //{ t.setLineNumber(lineOffset_ + token.endLine); }
  <IDENTIFIER> { axis = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  ":"
  <INTEGER_LITERAL> { margin = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  {
    ConstInt i = new ConstInt(margin);
    if (axis.equals("d"))
    {
      x.setValue(i.getValue());
      y.setValue(i.getValue());
    }
    else if (axis.equals("x"))
    {
      x.setValue(i.getValue());
    }
    else if (axis.equals("y"))
    {
      y.setValue(i.getValue());
    }
    else
      throw new AnyRuntimeException(axis + " not a valid margin dimension");
  }
}

void Alignment(FloatI a, Transaction t) :
{
  String just;
}
{
  <GUI_ALIGN> // { t.setLineNumber(lineOffset_ + token.endLine); }
  <IDENTIFIER> { just = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  {
    if (just.equals("t") || just.equals("l"))
    {
      a.setValue(0);
    }
    else if (just.equals("c"))
    {
      a.setValue(0.5f);
    }
    else if (just.equals("b") || just.equals("r"))
    {
      a.setValue(1);
    }
    else
      throw new AnyRuntimeException("Alignment must be [tl] | c | [br]");

    //System.out.println("ALIGN " + a);
  }
}

void Geometry(StringI x, StringI y, Transaction t) :
{
  String axis;
  String geom       = null;
}
{
  <GUI_GEOMETRY> //{ t.setLineNumber(lineOffset_ + token.endLine); }
  <IDENTIFIER> { axis = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  ":"
  <IDENTIFIER> { geom = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  {
    if (axis.equals("d"))
    {
      if (geom.length() != 1 || !geomSpec__.contains(geom))
        illegalGeometry(axis, geom);

      x.setValue(geom);
      y.setValue(geom);
    }
    else if (axis.equals("xy"))
    {
      if (geom.length() != 2)
        illegalGeometry(axis, geom);

      String gX = geom.substring(0, 1);
      if (!geomSpec__.contains(gX))
        illegalGeometry(axis, geom);

      String gY = geom.substring(1, 2);
      if (!geomSpec__.contains(gY))
        illegalGeometry(axis, geom);

      x.setValue(gX);
      y.setValue(gY);
    }
    else
      illegalGeometry(axis, geom);
  }
}

JScrollPane Scroll() :
{
}
{
  <GUI_SCROLL>
  {
    return new JScrollPane();
  }
}

void Size(AnyInt x, AnyInt y, Transaction t) :
{
  String xSize;
  String ySize;
}
{
  <GUI_SIZE> //{ t.setLineNumber(lineOffset_ + token.endLine); }
  <INTEGER_LITERAL> { xSize = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  ":"
  <INTEGER_LITERAL> { ySize = token.image; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  {
    AnyInt i = new AnyInt(xSize);
    x.copyFrom(i);
    i.fromString(ySize);
    y.copyFrom(i);
  }
}

boolean Nofocus(Transaction t) :
{
  boolean focusable = true;
}
{

  <GUI_NOFOCUS> { focusable = false; /*t.setLineNumber(lineOffset_ + token.endLine);*/ }
  {
    return focusable;
  }
}

Any gProperty() :
{
  Any        bindTo;
  String     property;
  Any        r;
  BooleanI   immediate = null;
  int        line;
}
{
  "gProperty" { line = token.beginLine; }
  "("
  bindTo = NodeRef()
  ","
  ( <IDENTIFIER> | "editable" ) { property = token.image; }
  ","
  r = RenderInfo()
  [ ( "," immediate = BooleanLiteralAsAny() ) ]
  ")"
  {
    PropertyBinder pb = new PropertyBinder(bindTo, property, r, (immediate != null) ? immediate.getValue() : true);
    pb.setLineNumber(line);
    return pb;
  }
}

Any gEvent() :
{
  Any        attachTo;
  Func       expr               = null;
  Array      baseEventTypes     = AbstractComposite.array();
  Any        dialogRedirect     = null;
  Any        cellEdit           = null;
  Map        modifiers          = AbstractComposite.simpleMap();
  BooleanI   consume            = AnyBoolean.FALSE;
  boolean    busy               = false;
  BooleanI   aBusy              = AnyBoolean.FALSE;
  Any        modelFires         = null;
  int        line;
}
{
  "gEvent" { line = token.beginLine; }
  "("
  attachTo = Expression()
  [ LOOKAHEAD(2) "," ( expr = Call() | expr = CallMethod() ) ] // optional because of gDialog
  ( "," ( ( "event"     "=" busy = GuiEventTypeList(baseEventTypes) )
        | ( "gModify"   "=" GuiEventModifierList(modifiers) )
        | ( "gDialog"   "=" dialogRedirect = DialogRedirect() )
        | ( "gCellEdit" "=" cellEdit = CellEdit() )
        | ( "consume"   "=" consume = BooleanLiteralAsAny() )
        | ( "firemodel" "=" modelFires = Expression() )
        | ( "wait"      "=" aBusy   = BooleanLiteralAsAny() { busy = aBusy.getValue(); } )
        )
  )*
  ")"
  {
    if ((expr != null && dialogRedirect != null) ||
        (expr != null && cellEdit != null) ||
        (expr == null && dialogRedirect == null && cellEdit == null &&
                          (modelFires == null ||
                           !modelFires.equals(AnyBoolean.TRUE))))
      throw new AnyRuntimeException("Specify either expression, firemodel=true or dialog/edit directive");

    if (cellEdit != null && dialogRedirect != null)
      throw new AnyRuntimeException("Specify only one of dialog or edit directives");

    // There's only one directive allowed so only need one variable
    // to hold it
    if (dialogRedirect == null)
      dialogRedirect = cellEdit;

    Array eventTypes;

    if (baseEventTypes.entries() == 0)
    {
      eventTypes = EventConstants.DEFAULT_TYPE;
      busy = true;
    }
    else
    {
      for (int i = 0; i < baseEventTypes.entries(); i++)
      {
        Any eventType = baseEventTypes.get(i);
        if (complexEvents__.contains(eventType))
          eventType = complexEventType(eventType, null, null, null, null, modifiers);

        baseEventTypes.replaceItem(i, eventType);
      }
      eventTypes = baseEventTypes;
    }

    GuiAttacher ga = new GuiAttacher(attachTo, expr, eventTypes, dialogRedirect, consume.getValue(), busy, modelFires);
    ga.setLineNumber(line);
    return ga;
  }
}

Any gRemoveEvent() :
{ Any eventBinding;
  int line;
}
{
  "gRemoveEvent" { line = token.beginLine; }
  "("
  eventBinding = Expression()
  ")"
  {
    GuiRemover r = new GuiRemover(eventBinding);
    r.setLineNumber(line);
    return r;
  }
}

Any gPopup() :
{
  Any        attachTo;
  Any        menu;
  Array      baseEventTypes     = AbstractComposite.array();
  Map        modifiers          = AbstractComposite.simpleMap();
  BooleanI   consume            = AnyBoolean.FALSE;
  int        line;
}
{
  "gPopup" { line = token.beginLine; }
  "("
  attachTo = Expression()
  ","
  menu     = Expression()
  ( "," ( ( "event"     "=" GuiEventTypeList(baseEventTypes) )
        | ( "gModify"   "=" GuiEventModifierList(modifiers) )
        | ( "consume" "=" consume = BooleanLiteralAsAny() )
        )
  )*
  ")"
  {
    if (baseEventTypes.entries() == 0)
      baseEventTypes.add(EventConstants.M_POPUP);

    for (int i = 0; i < baseEventTypes.entries(); i++)
    {
      Any eventType = baseEventTypes.get(i);
      if (complexEvents__.contains(eventType))
        eventType = complexEventType(eventType, null, null, null, null, modifiers);

      baseEventTypes.replaceItem(i, eventType);
    }
    GuiPopup gp = new GuiPopup(attachTo, menu, baseEventTypes, consume.getValue());
    gp.setLineNumber(line);
    return gp;
  }
}

Any EventList() :
{
  Array      baseEventTypes     = AbstractComposite.array();
  Map        modifiers          = AbstractComposite.simpleMap();
  BooleanI   consume            = AnyBoolean.FALSE;
}
{
  // It might be better to have an event type maker (like MakeRenderInfo) ?
  "gEventTypes"
  "("
  ( ( ( "event"     "=" GuiEventTypeList(baseEventTypes) )
    | ( "gModify"   "=" GuiEventModifierList(modifiers) )
    | ( "consume"   "=" consume = BooleanLiteralAsAny() )
    )
  )*
  ")"
  {
    Array eventTypes;

    if (baseEventTypes.entries() == 0)
    {
      eventTypes = EventConstants.DEFAULT_TYPE;
    }
    else
    {
      for (int i = 0; i < baseEventTypes.entries(); i++)
      {
        Any eventType = baseEventTypes.get(i);
        if (complexEvents__.contains(eventType))
          eventType = complexEventType(eventType, null, null, null, null, modifiers);

        baseEventTypes.replaceItem(i, eventType);
      }
      eventTypes = baseEventTypes;
    }
    return eventTypes;
  }
}


boolean GuiEventTypeList(Array eventTypes) :
{ boolean busy = false; boolean busy1 = false; }
{
  "(" busy = GuiEventType(eventTypes) ("," busy1 = GuiEventType(eventTypes) { busy = busy || busy1; } )* ")"
  {
    return busy;
  }
}

void GuiEventModifierList(Map eventModifiers) :
{
}
{
  "(" GuiEventModifier(eventModifiers) ("," GuiEventModifier(eventModifiers) )* ")"
}

void GuiEventModifier(Map eventModifiers) :
{
}
{
  ( ClickCountModifier(eventModifiers)
  | MouseButtonModifier(eventModifiers)
  | KeycodeModifier(eventModifiers)
  | KeyModifier(eventModifiers)
  )*
}

void ClickCountModifier(Map eventModifiers) :
{}
{
  "count" "=" <INTEGER_LITERAL>
  {
    eventModifiers.add(EventConstants.MOD_CLICKCOUNT, new ConstInt(token.image));
  }
}

void MouseButtonModifier(Map eventModifiers) :
{}
{
  "mbutton" "=" <INTEGER_LITERAL>
  {
    eventModifiers.add(EventConstants.MOD_MBUTTON, new ConstShort(token.image));
  }
}

void KeycodeModifier(Map eventModifiers) :
{}
{
  "keycode" "=" <IDENTIFIER>
  {
    Class c = java.awt.event.KeyEvent.class;
    try
    {
      Field f = c.getField(token.image);
      eventModifiers.add(EventConstants.MOD_KEYCODE, new ConstInt(f.getInt(null)));
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

Any KeycodeAsAny() :
{ Any a; String kc; }
{
  "keycode"
  "("
  <IDENTIFIER> { kc = token.image; }
  ")"
  {
    Class c = java.awt.event.KeyEvent.class;
    try
    {
      Field f = c.getField(kc);
      return new ConstInt(f.getInt(null));
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

Array KeystrokeAsAny() :
{ String kc; Any mod = null; Any onRelease = null; }
{
  "keystroke"
  "("
  <IDENTIFIER> { kc = token.image; }
  [ LOOKAHEAD(2)
    ","
    mod = KeyModifierAsAny()
  ]
  [
    ","
    onRelease = BooleanLiteralAsAny()
  ]
  ")"
  {
    Class c = java.awt.event.KeyEvent.class;
    try
    {
      Field f = c.getField(kc);
      Array a = AbstractComposite.array();
      a.add(new ConstInt(f.getInt(null)));

      if (mod != null)
        a.add(mod);
      else
        a.add(ConstInt.ZERO);

      if (onRelease != null)
        a.add(onRelease);
      else
        a.add(AnyBoolean.FALSE);

      return a;
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
  }
}

void KeyModifier(Map eventModifiers) :
{}
{
  "keymod" "=" <IDENTIFIER>
  {
    Any a = null;
    if ((a = (Any)modifierKeys__.get(token.image)) == null)
      throw new AnyRuntimeException("Invalid modifier key: " + token.image);

    eventModifiers.add(a, AnyBoolean.TRUE);
  }
}

boolean GuiEventType(Array eventTypes) :
{
  Any     eventType = EventConstants.DEFAULT_TYPE;
  boolean busy      = false;
}
{
  ( "gAction" { busy = true; }
  | "gFocusgained"
  | "gFocuslost"
  | "gChange"
  | "gWactivated"
  | "gWclosing"
  | "gWclosed"
  | "gWdeactivated"
  | "gWdeiconified"
  | "gWiconified"
  | "gWopened"
  | "gMclicked"
  | "gMentered"
  | "gMexited"
  | "gMpressed"
  | "gMreleased"
  | "gMpopup"
  | "gMmoved"
  | "gMdragged"
  | "gMenuSelected"
  | "gMenuDeselected"
  | "gMenuCanceled"
  | "gPopupVisible"
  | "gPopupInvisible"
  | "gPopupCanceled"
  | "gKtyped"
  | "gKpressed"
  | "gKreleased"
  | "gFCapprove"
  | "gFCcancel"
  | "gDialogok"
  | "gDialogcancel"
  | "gCellEditDone"
  | "gCellEditCancel"
  | "gDocchange"
  | "gDocinsert"
  | "gDocremove"
  | "gSelection"
  | "gItem"
  | "gTreeselection"
  | "gTreeexpand"
  | "gTreecollapse"
  | "gContext"
  | "gHidden"
  | "gMoved"
  | "gResized"
  | "gShown"
  )
  {
    switch (token.kind)
    {
      case ACTION:            eventType = EventConstants.E_ACTION;            break;
      case FOCUSGAINED:       eventType = EventConstants.E_FOCUSGAINED;       break;
      case FOCUSLOST:         eventType = EventConstants.E_FOCUSLOST;         break;
      case CHANGE:            eventType = EventConstants.E_CHANGE;            break;
      case WACTIVATED:        eventType = EventConstants.W_ACTIVATED;         break;
      case WCLOSING:          eventType = EventConstants.W_CLOSING;           break;
      case WCLOSED:           eventType = EventConstants.W_CLOSED;            break;
      case WDEACTIVATED:      eventType = EventConstants.W_DEACTIVATED;       break;
      case WDEICONIFIED:      eventType = EventConstants.W_DEICONIFIED;       break;
      case WICONIFIED:        eventType = EventConstants.W_ICONIFIED;         break;
      case WOPENED:           eventType = EventConstants.W_OPENED;            break;
      case MCLICKED:          eventType = EventConstants.M_CLICKED;           break;
      case MENTERED:          eventType = EventConstants.M_ENTERED;           break;
      case MEXITED:           eventType = EventConstants.M_EXITED;            break;
      case MPRESSED:          eventType = EventConstants.M_PRESSED;           break;
      case MRELEASED:         eventType = EventConstants.M_RELEASED;          break;
      case MPOPUP:            eventType = EventConstants.M_POPUP;             break;
      case MMOVED:            eventType = EventConstants.M_MOVED;             break;
      case MDRAGGED:          eventType = EventConstants.M_DRAGGED;           break;
      case MENUSELECTED:      eventType = EventConstants.MENU_SELECTED;       break;
      case MENUDESELECTED:    eventType = EventConstants.MENU_DESELECTED;     break;
      case MENUCANCELED:      eventType = EventConstants.MENU_CANCELED;       break;
      case POPUPVISIBLE:      eventType = EventConstants.POPUP_VISIBLE;       break;
      case POPUPINVISIBLE:    eventType = EventConstants.POPUP_INVISIBLE;     break;
      case POPUPCANCELED:     eventType = EventConstants.POPUP_CANCELED;      break;
      case KTYPED:            eventType = EventConstants.K_TYPED;             break;
      case KPRESSED:          eventType = EventConstants.K_PRESSED;           break;
      case KRELEASED:         eventType = EventConstants.K_RELEASED;          break;
      case FCAPPROVE:         eventType = EventConstants.FILECHOOSER_APPROVE; break;
      case FCCANCEL:          eventType = EventConstants.FILECHOOSER_CANCEL;  break;
      case DIALOGOK:          eventType = EventConstants.DIALOG_OK;           break;
      case DIALOGCANCEL:      eventType = EventConstants.DIALOG_CANCEL;       break;
      case ROWEDITDONE:       eventType = EventConstants.TABLEEDIT_DONE;      break;
      case ROWEDITCANCEL:     eventType = EventConstants.TABLEEDIT_CANCEL;    break;
      case DOCCHANGE:         eventType = EventConstants.D_CHANGE;            break;
      case DOCINSERT:         eventType = EventConstants.D_INSERT;            break;
      case DOCREMOVE:         eventType = EventConstants.D_REMOVE;            break;
      case SELECTION:         eventType = EventConstants.E_SELECTIONCHANGED;  break;
      case ITEM:              eventType = EventConstants.E_ITEM;              break;
      case TREESELECTION:     eventType = EventConstants.E_TREESELECTION;     break;
      case TREEEXPAND:        eventType = EventConstants.E_TREEWILLEXPAND;    break;
      case TREECOLLAPSE:      eventType = EventConstants.E_TREEWILLCOLLAPSE;  break;
      case ECONTEXT:          eventType = EventConstants.CONTEXT_ESTABLISHED; break;
      case HIDDEN:            eventType = EventConstants.E_HIDDEN;            break;
      case MOVED:             eventType = EventConstants.E_MOVED;             break;
      case RESIZED:           eventType = EventConstants.E_RESIZED;           break;
      case SHOWN:             eventType = EventConstants.E_SHOWN;             break;
    }
    if (eventTypes.indexOf(eventType) < 0)
      eventTypes.add(eventType);

    return busy;
  }
}

Any DialogRedirect() :
{
  Any   a;
}
{
  ( "gDialogok"     { a = MakeComponent.dialogOk__; }
  | "gDialogcancel" { a = MakeComponent.dialogCancel__; }
  )
  {
    return a;
  }
}

Any CellEdit() :
{
  Any   a;
}
{
  ( "gCellEditStop" { a = EventConstants.CELLEDITOR_STOPPED; }
    // more ?
  )
  {
    return a;
  }
}

// --------------  Document Layout ----------------

JAVACODE
void LayoutDoc(Any context, StyledDocument doc, Transaction t)
{
  DocLayout(context, doc, t);
}

void DocLayout(Any context, StyledDocument doc, Transaction t) :
{}
{
  TopLevelElement(context, doc, t, null, null)
}

void TopLevelElement(Any context, StyledDocument doc, Transaction t, AnyAttributeSet currStyle, ArrayList elements) :
{}
{
  ( LOOKAHEAD([Style()] Table()) Table(context, doc, t, currStyle, elements)
  | LOOKAHEAD([Style()] Paragraph()) Paragraph(context, doc, t, currStyle, elements)
  //| LOOKAHEAD(TableRow()) TableRow(context, doc, t, currStyle, null, elements)
  | Pagebreak(doc)
  )+
}

void Table(Any context, StyledDocument doc, Transaction t, AnyAttributeSet tableStyle, ArrayList elements) :
{
  MutableAttributeSet table;
  boolean             outermost;
  AnyAttributeSet     paraStyle = null;
}
{
  [ tableStyle = Style(context, t) ]
  <GUI_TABLE>
  "{"
  {
    outermost = (elements == null);

    ArrayList tableElementSpecs = (elements != null) ? elements
                                                     : new ArrayList(); // consider approximating size - tbd

    // If a style was referenced, don't corrupt it with the "table" element name
    if (tableStyle == null)
      tableStyle = new AnyAttributeSet();
    else
    {
      AnyAttributeSet s = new AnyAttributeSet();
      s.getAttributeSet().setResolveParent(tableStyle.getAttributeSet());
      tableStyle = s;
    }

    // Make sure the table style has the name attribute
    tableStyle.add(NodeSpecification.name__,
                   AnyDocument.ANYTABLE);

    // Open the table element spec.  If its a top level element put it in a paragraph to satisfy
    // the document structure requirements
    if (outermost)
    {
      paraStyle = new AnyAttributeSet();
      paraStyle.add(NodeSpecification.name__,
                     AnyDocument.ANYPARA);
      paraStyle.getAttributeSet().setResolveParent(tableStyle.getAttributeSet());

      DefaultStyledDocument.ElementSpec esParaStart =
        new DefaultStyledDocument.ElementSpec(paraStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.StartTagType);
      tableElementSpecs.add(esParaStart);
    }

    DefaultStyledDocument.ElementSpec esTableStart =
      new DefaultStyledDocument.ElementSpec(tableStyle.getAttributeSet(),
                                            DefaultStyledDocument.ElementSpec.StartTagType);

    tableElementSpecs.add(esTableStart);
  }
  ( TableRows(context, doc, t, tableStyle, tableElementSpecs)
  // | StartTable(context, doc, t, tableStyle, elements)
  )
  "}"
  {
    // Tidy the attribute set of the "table" tag
    // table.removeAttribute(AbstractDocument.ElementNameAttribute);
    // Actually, can't do this as it is used below...

    // close the table tag
    DefaultStyledDocument.ElementSpec esTableEnd =
      new DefaultStyledDocument.ElementSpec(tableStyle.getAttributeSet(),
                                            DefaultStyledDocument.ElementSpec.EndTagType);
    tableElementSpecs.add(esTableEnd);

    if (AnyDocument.endPara__ == null)
      AnyDocument.endPara__ = new DefaultStyledDocument.ElementSpec(null,
                                                                    DefaultStyledDocument.ElementSpec.ContentType,
                                                                    "\n".toCharArray(), 0, 1);
    tableElementSpecs.add(AnyDocument.endPara__);

    // append the table to the document if we are at the outermost level
    if (outermost)
    {
      DefaultStyledDocument.ElementSpec esParaEnd =
        new DefaultStyledDocument.ElementSpec(paraStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.EndTagType);
      tableElementSpecs.add(esParaEnd);
      insertDocument(doc, doc.getLength(), tableElementSpecs);
      tableElementSpecs.clear();
    }
  }
}

void TableRows(Any context, StyledDocument doc, Transaction t, AnyAttributeSet tableStyle, ArrayList elements) :
{ Any rows; Any columns = null; AnyAttributeSet anyRowStyle = null; }
{
  ( [ anyRowStyle = Style(context, t) ]
    (
      (
        <GUI_ROWS> rows = Expression() ";"
        [ <GUI_COLUMNS> columns = Expression() ";" ]
      )
      {
        // We've always got rows, so evaluate
        try
        {
          rows = EvalExpr.evalFunc(t,
                                   context,
                                   rows);
        }
        catch(Exception e)
        {
          throw new RuntimeContainedException(e);
        }

        if (rows == null && columns == null)
          return; // rows did not resolve and cols not specified - ignore

        // if columns wasn't given then rows must be an AnyTable
        if (columns == null && !(rows instanceof AnyTable))
          throw new AnyRuntimeException("Rows without Columns and Rows not an AnyTable " +
                                        token.image +
                                        " at line " + token.beginLine +
                                        " column " + token.beginColumn);

        // Establish the row start and end tags.  Rows (StyledEditorKit.TableView.TableRow) have no
        // style requirements at present but we create a child of the table style given to pass these
        // on just in case.
        if (anyRowStyle == null)
        {
          anyRowStyle = new AnyAttributeSet();
          anyRowStyle.getAttributeSet().setResolveParent(tableStyle.getAttributeSet());
        }
        else
        {
          AnyAttributeSet s = new AnyAttributeSet();
          s.getAttributeSet().setResolveParent(anyRowStyle.getAttributeSet());
          anyRowStyle = s;
        }

        anyRowStyle.add(NodeSpecification.name__,
                        AnyDocument.ANYROW);

        MutableAttributeSet rowStyle = anyRowStyle.getAttributeSet();

        DefaultStyledDocument.ElementSpec esRowStart =
          new DefaultStyledDocument.ElementSpec(rowStyle,
                                                DefaultStyledDocument.ElementSpec.StartTagType);
        DefaultStyledDocument.ElementSpec esRowEnd =
          new DefaultStyledDocument.ElementSpec(rowStyle,
                                                DefaultStyledDocument.ElementSpec.EndTagType);

        // ...and, when auto-generating, the style for cells can come from the table model.
        // Create a default one for when none is provided and pass on table style.
        // Note that the cells themselves are paragraphs, so their style would specify
        // indents, spacing etc.  The content would have the style of font, size colour etc.
        SimpleAttributeSet defCellStyle = new SimpleAttributeSet();
        defCellStyle.addAttribute(AbstractDocument.ElementNameAttribute, "cell");
        defCellStyle.setResolveParent(rowStyle);

        DefaultStyledDocument.ElementSpec esCellStart =
          new DefaultStyledDocument.ElementSpec(defCellStyle,
                                                DefaultStyledDocument.ElementSpec.StartTagType);
        DefaultStyledDocument.ElementSpec esCellEnd =
          new DefaultStyledDocument.ElementSpec(defCellStyle,
                                                DefaultStyledDocument.ElementSpec.EndTagType);

        try
        {
          if (columns == null)
          {
            AnyTable      table = (AnyTable)rows;
            TableModel    model = table.getModel();

            // process model values into rows/cols
            int numRows = model.getRealRowCount();
            int numCols = model.getColumnCount();

            // (consider table headers sometime)

            for (int row = 0; row < numRows; row++)
            {
              elements.add(esRowStart);
              for (int col = 0; col < numCols; col++)
              {
                elements.add(esCellStart);
                Any val = (Any)model.getValueAt(row, col);
                // There are a number of possibilities from the table model:
                //   1) Just an Any ( icon or toString() )
                //   2) Map containing text and well-known Inq style attrs
                //   3) Map containing text and AnyAttributeSet for style
                String str = AnyDocument.getString(val);
                char[] chars = str.toCharArray();

                // This return null if a simple value is passed in or an empty
                // style to which we should add
                // the "cell" name, and parent on the row style, which we are not
                // currently doing.  Thus, this method of table generation is
                // not working at the moment.
                MutableAttributeSet cellContentStyle = AnyDocument.getStyle(val);  // may be null

                DefaultStyledDocument.ElementSpec content =
                  new DefaultStyledDocument.ElementSpec(cellContentStyle,
                                                        DefaultStyledDocument.ElementSpec.ContentType,
                                                        chars, 0, chars.length);
                elements.add(content);

                elements.add(esCellEnd);
              }
              elements.add(esRowEnd);
            }
          }
          else
          {
            // evaluate columns
            try
            {
              columns = EvalExpr.evalFunc(t,
                                          context,
                                          columns);
            }
            catch(Exception e)
            {
              throw new RuntimeContainedException(e);
            }

            if (columns == null)
              return; // columns did not resolve - silently ignore

            // rows must be a Vectored referring to the data root and
            // columns must be a Vectored containing RenderInfo objects that
            // will be resolved against the given context

            if ((!(rows instanceof Vectored)) || (!(columns instanceof Vectored)))
              throw new AnyRuntimeException("Table rows or columns not a Vectored " +
                                            token.image +
                                            " at line " + token.beginLine +
                                            " column " + token.beginColumn);

            Vectored vColumns = (Vectored)columns;
            Vectored vRows    = (Vectored)rows;

            // If no rows or colinfo then silently ignore
            if (vColumns.entries() == 0 || vRows.entries() == 0)
              return;

            // process vector values into rows/cols
            int numRows = vRows.entries();
            int numCols = vColumns.entries();

            // (consider table headers sometime)

      // Create the cells as paragraphs. The TableCell view is just a BoxView
      // so we need to wrap in a paragraph to get the results from paragraph
      // attributes that may have been specified
      AnyAttributeSet paraStyle = new AnyAttributeSet();
      paraStyle.add(NodeSpecification.name__,
                     AnyDocument.ANYPARA);
      paraStyle.getAttributeSet().setResolveParent(defCellStyle);

      DefaultStyledDocument.ElementSpec esParaStart =
        new DefaultStyledDocument.ElementSpec(paraStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.StartTagType);
      DefaultStyledDocument.ElementSpec esParaEnd =
        new DefaultStyledDocument.ElementSpec(paraStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.EndTagType);

            for (int row = 0; row < numRows; row++)
            {
              Any rowRoot = vRows.getByVector(row);
              elements.add(esRowStart);

              for (int col = 0; col < numCols; col++)
              {
                elements.add(esCellStart);
                elements.add(esParaStart);

                // Process the column
                Any cellItem = vColumns.getByVector(col);

                // If the item is a FuncHolder then it is assumed that calling
                // it will return the text only (no content style specified)
                // or a map containing @txt and @style. Otherwise the value must
                // be an instance of AnyTable.ColumnProperty. In that case we
                // use the contained renderinfo and style function to generate the
                // cell content and content style.

                char[] chars                         = null;
                MutableAttributeSet cellContentStyle = null;

                if (cellItem instanceof AnyFuncHolder.FuncHolder)
                {
                  AnyFuncHolder.FuncHolder fh = (AnyFuncHolder.FuncHolder)cellItem;
                  Func f = fh.getFunc();
                  Any cellValue = EvalExpr.evalFunc(t,
                                                    rowRoot,
                                                    f);

                  // cellValue must be a Map containing
                  //   @txt->cell text
                  //   @style->cell style
                  // or just a string if no content style is in effect
                  //System.out.println("cell value is " + cellValue);
                  //String str = AnyDocument.getString(cellValue);
                  String str = AnyDocument.getString(cellValue) + "\n";
                  chars = str.toCharArray();
                  cellContentStyle = AnyDocument.getStyle(cellValue); // may be null
                  //DefaultStyledDocument.ElementSpec content =
                    //new DefaultStyledDocument.ElementSpec(cellContentStyle,
                      //                                    DefaultStyledDocument.ElementSpec.ContentType,
                        //                                  chars, 0, chars.length);
                  //elements.add(content);
                }
                else if (cellItem instanceof AnyTable.ColumnProperty)
                {
                  // Get the renderinfo and apply the current row root to
                  // retrieve the value

                  // If there is a style function in the ColumnProperty then
                  // call it to obtain the style

                  // TODO
                }
                else
                  throw new AnyRuntimeException("Invalid class for cell value: " + cellItem.getClass());

                breakContent(chars,
                             elements,
                             cellContentStyle,
                             esParaStart,
                             esParaEnd);

                elements.add(esParaEnd);
                elements.add(esCellEnd);
              }
              elements.add(esRowEnd);
            }
          }
        }
        catch (Exception e)
        {
          throw new RuntimeContainedException(e);
        }
        /*
        finally
        {
          defCellStyle.setResolveParent(null);
          rowStyle.setResolveParent(null);
        }
        */
      }
    | AnyTableRows(context, doc, t, tableStyle, anyRowStyle, elements)
    | TableRow(context, doc, t, tableStyle, anyRowStyle, elements)
    )
  )+
}

void AnyTableRows(Any context, StyledDocument doc, Transaction t, AnyAttributeSet tableStyle, AnyAttributeSet anyRowStyle, ArrayList elements) :
{
  Any      table;
  AnyTable anyTable;
  Array    columns    = AbstractComposite.array();
  Array    styles     = AbstractComposite.array();
  Array    paraStyles = AbstractComposite.array();
  Map      tableCols;
}
{
  // Rows as defined by an AnyTable. The referenced AnyTable defines (via its
  // modelRoot property) the root node of the row data. Individual columns are
  // specified either using a column name (literal identifier) or an expression
  // resolved with respect to the model root child. Respectively these are
  //   TableColumn <identifier> ;
  //   Column      <expression> ;
  <DOC_TABLEROWS>
  table = Expression() ";"
  {
    // Establish a row style based on any specified for the table or protect the
    // one specified
    if (anyRowStyle == null)
    {
      anyRowStyle = new AnyAttributeSet();

      // Make sure the row style has the name attribute.
      anyRowStyle.add(NodeSpecification.name__,
                      AnyDocument.ANYROW);
      anyRowStyle.getAttributeSet().setResolveParent(tableStyle.getAttributeSet());
    }
    else
    {
      AnyAttributeSet s = new AnyAttributeSet();
      s.getAttributeSet().setResolveParent(anyRowStyle.getAttributeSet());
      anyRowStyle = s;
    }

    anyRowStyle.add(NodeSpecification.name__,
                    AnyDocument.ANYROW);

    // Evaluate the table expression
    try
    {
      anyTable = (AnyTable)EvalExpr.evalFunc(t,
                                             context,
                                             table,
                                             AnyTable.class);
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }

    if (anyTable == null)
      throw new AnyRuntimeException("Could not resolve table expression " +
                                    table +
                                    " at line " + token.beginLine +
                                    " column " + token.beginColumn);

    // Get the columns from the table, in anticipation that at least some
    // of the report columns will be named table columns.
    tableCols = (Map)anyTable.getColumns();
  }
  "{"
  AnyTableColumns(context, t, tableCols, anyRowStyle, columns, styles, paraStyles)
  "}"
  {
    // Evaluate the model root from the table
    // (Presumably the table context is the same as the given context, but
    // we use the table's anyway)
    Any tableContext = anyTable.getContextNode();
    Any modelRoot    = anyTable.getModelRoot();

    Vectored root = null;
    try
    {
      root = (Vectored)EvalExpr.evalFunc(t,
                                         tableContext,
                                         modelRoot,
                                         Vectored.class);
    }
    catch(AnyException e)
    {
      throw new RuntimeContainedException(e);
    }

    // Silently ignore if there's nothing
    if (root == null || root.entries() == 0 || columns.entries() == 0)
      return;

    // Create the row start/end tags
    MutableAttributeSet rowStyle = anyRowStyle.getAttributeSet();

    DefaultStyledDocument.ElementSpec esRowStart =
      new DefaultStyledDocument.ElementSpec(rowStyle,
                                            DefaultStyledDocument.ElementSpec.StartTagType);
    DefaultStyledDocument.ElementSpec esRowEnd =
      new DefaultStyledDocument.ElementSpec(rowStyle,
                                            DefaultStyledDocument.ElementSpec.EndTagType);


    int numRows = root.entries();
    int numCols = columns.entries();

    // Get the columns from the table, in anticipation that at least some
    // of the report columns will be named table columns. If the table model
    // was not initialised with named columns ignore.
    //Map tableCols = (Map)anyTable.getColumns();
    //if (tableCols == null)
      //return;

    // Process the rows
    for (int row = 0; row < numRows; row++)
    {
      Any rowRoot = root.getByVector(row);
      elements.add(esRowStart);

      for (int col = 0; col < numCols; col++)
      {
        // Create the cell start/end tags for the style previously parsed/created
        AnyAttributeSet anyCellStyle = (AnyAttributeSet)styles.get(col);
        DefaultStyledDocument.ElementSpec esCellStart =
          new DefaultStyledDocument.ElementSpec(anyCellStyle.getAttributeSet(),
                                                DefaultStyledDocument.ElementSpec.StartTagType);
        DefaultStyledDocument.ElementSpec esCellEnd =
          new DefaultStyledDocument.ElementSpec(anyCellStyle.getAttributeSet(),
                                                DefaultStyledDocument.ElementSpec.EndTagType);

        // We also need to use the same style to create paragraphs. Unlike
        // paragraph views, cell views do not respect paragraph attributes. We have
        // no syntactic way of expressing them so we assume they are in/resolved in
        // the cell style, along with cell attributes
        AnyAttributeSet anyParaStyle = (AnyAttributeSet)paraStyles.get(col);
        DefaultStyledDocument.ElementSpec esParaStart =
          new DefaultStyledDocument.ElementSpec(anyParaStyle.getAttributeSet(),
                                                DefaultStyledDocument.ElementSpec.StartTagType);
        DefaultStyledDocument.ElementSpec esParaEnd =
          new DefaultStyledDocument.ElementSpec(anyParaStyle.getAttributeSet(),
                                                DefaultStyledDocument.ElementSpec.EndTagType);

        elements.add(esCellStart);
        elements.add(esParaStart);

        char[] chars = null;

        Any currColl = columns.get(col);

        if (currColl instanceof AnyTable.ColumnProperty)
        {
          // For a ColumnProperty, fetch the value from the model, then ask the
          // underlying renderer for the column to render the value to text
          AnyTable.ColumnProperty columnProperty = (AnyTable.ColumnProperty)currColl;
          int colIndex = columnProperty.getColumnIndex();
          TableModel tableModel = anyTable.getModel();
          Any tableVal = (Any)tableModel.getValueAt(row, colIndex);
          RenderInfo renderInfo = (RenderInfo)columnProperty.get(AnyTable.renderinfo__);
          if (renderInfo != null)
          {
            Format f = renderInfo.getFormat(tableVal);
            chars = (f.format(tableVal) + "\n").toCharArray();
          }
          else
          {
            if (tableVal != null)
              chars = tableVal.toString().toCharArray();
          }
        }
        else
        {
          // It's an expression - evaluate it with respect to the current row root
          try
          {
            Any tableVal = EvalExpr.evalFunc(t,
                                             rowRoot,
                                             currColl);
            if (tableVal != null)
              chars = tableVal.toString().toCharArray();
          }
          catch(AnyException e)
          {
            throw new RuntimeContainedException(e);
          }

        }

        if (chars != null)
          breakContent(chars,
                       elements,
                       null, // TODOcellContentStyle,
                       esParaStart,
                       esParaEnd);

        elements.add(esParaEnd);
        elements.add(esCellEnd);
      }
      elements.add(esRowEnd);
    }
  }
}

void AnyTableColumns(Any context, Transaction t, Map tableCols, AnyAttributeSet anyRowStyle, Array columns, Array styles, Array paraStyles) :
{
  Any             c;
  AnyAttributeSet colStyle = null;
  Map             tableColumns;
  String          colName;
}
{
  // Gather all the columns with optional styles. If a column does not
  // specify a style then an empty one is created and resolves to the row style.
  // Note - the style will create a "cell" view. This is not a paragraph view
  // so paragraph attributes need to be passed on to a "paragraph" view
  (
    [ colStyle = Style(context, t) ]
    {
      AnyAttributeSet anyCellStyle;

      if (colStyle == null)
      {
        // There's no cell style for this column. Create an empty one and resolve
        // against any given row style.
        anyCellStyle = new AnyAttributeSet();
        anyCellStyle.getAttributeSet().setResolveParent(anyRowStyle.getAttributeSet());
      }
      else
      {
        // There is a specified style. Create an empty one and resolve against
        // that parsed, so that we don't put "cell" into a scripted style.
        anyCellStyle = new AnyAttributeSet();
        anyCellStyle.getAttributeSet().setResolveParent(colStyle.getAttributeSet());
        colStyle = null;
      }

      // Make sure the cell style has the name attribute to create cell views
      anyCellStyle.add(NodeSpecification.name__,
                       AnyDocument.ANYCELL);

      // Create a paragraph style as well, processing of rows/cols above
      AnyAttributeSet anyParaStyle = new AnyAttributeSet();
      anyParaStyle.getAttributeSet().setResolveParent(anyCellStyle.getAttributeSet());
      anyCellStyle.add(NodeSpecification.name__,
                       AnyDocument.ANYPARA);

      styles.add(anyCellStyle);
      paraStyles.add(anyParaStyle);
    }
    (
      <DOC_TABLECOLUMN> <IDENTIFIER> { colName = token.image; } ";"
      {
        Any s = AbstractValue.flyweightString(colName);

        if (tableCols == null)
          throw new AnyRuntimeException("No named columns in table");

        // Fetch the column property and place it in the columns array.
        columns.add(tableCols.get(s));
      }
    | <GUI_COLUMN> c = Expression() ";"
      {
        // Just put the expression in the array. We'll evaluate it when processing
        // each row/col
        columns.add(c);
      }
    )
  )+
}

void TableRow(Any context, StyledDocument doc, Transaction t, AnyAttributeSet tableStyle, AnyAttributeSet anyRowStyle, ArrayList elements) :
{
  DefaultStyledDocument.ElementSpec esRowStart = null;
  DefaultStyledDocument.ElementSpec esRowEnd   = null;
}
{
  // An additional single Row. Comprises optional styles followed by expressions
  // representing the cell content.  The cell style, if specified, can be used
  // to control things like the span.  The content style can be specified in the
  // cell value returned.
  // NOTE: for rows and cells it is necessary to set the attribute name to "row"
  // and "cell" to drive the view factory.  If explicit styles are specified in
  // the source layout and these are the same objects for table and row then the
  // view factory will likely croak. This would be incorrect layout anyway, as
  // the styles cascade from the table (or higher) specification.
  <GUI_ROW> "{"
  {
    if (anyRowStyle == null)
    {
      anyRowStyle = new AnyAttributeSet();

      anyRowStyle.getAttributeSet().setResolveParent(tableStyle.getAttributeSet());
    }
    else
    {
      AnyAttributeSet s = new AnyAttributeSet();
      s.getAttributeSet().setResolveParent(anyRowStyle.getAttributeSet());
      anyRowStyle = s;
    }

    // Make sure the row style has the name attribute.
    anyRowStyle.add(NodeSpecification.name__,
                    AnyDocument.ANYROW);

    // Hmmm, do we really want to alter the style hierarchy in this way
    // when we've already set one up in script according to our requirements?
    //
    //anyRowStyle.getAttributeSet().setResolveParent(tableStyle.getAttributeSet());

    // A row then comprises (optional) style and expression pairs. If a style is specified
    // then it only applies to the following cell expression and not thereafter until the
    // row ends.

    if(esRowStart == null)
    {
      esRowStart =
        new DefaultStyledDocument.ElementSpec(anyRowStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.StartTagType);
      esRowEnd =
        new DefaultStyledDocument.ElementSpec(anyRowStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.EndTagType);
    }

    // open the row tag
    elements.add(esRowStart);
  }
  ( TableCell(context, doc, t, anyRowStyle, elements)
  )*
  "}"
  {
    // close the row tag
    elements.add(esRowEnd);
  }
}

void TableCell(Any context, StyledDocument doc, Transaction t, AnyAttributeSet rowStyle, ArrayList elements) :
{
  AnyAttributeSet anyCellStyle = null;
  DefaultStyledDocument.ElementSpec esCellStart = null;
  DefaultStyledDocument.ElementSpec esCellEnd   = null;
}
{
  //[ LOOKAHEAD(Style() <DOC_CELL>) anyCellStyle = Style(context, t) <DOC_CELL> ]
  [ LOOKAHEAD(Style()) anyCellStyle = Style(context, t) ]
  {
    System.out.println(anyCellStyle);
    System.out.println("Line "  + token.beginLine);

    if (anyCellStyle == null)
    {
      // There's no cell style.  Create an empty one and resolve against
      // any given row style.
      anyCellStyle = new AnyAttributeSet();
      anyCellStyle.getAttributeSet().setResolveParent(rowStyle.getAttributeSet());
    }
    else
    {
      AnyAttributeSet s = new AnyAttributeSet();
      s.getAttributeSet().setResolveParent(anyCellStyle.getAttributeSet());
      anyCellStyle = s;
    }

    // Make sure the cell style has the name attribute
    anyCellStyle.add(NodeSpecification.name__,
                     AnyDocument.ANYCELL);


    if (esCellStart == null)
    {
      esCellStart =
        new DefaultStyledDocument.ElementSpec(anyCellStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.StartTagType);
      esCellEnd =
        new DefaultStyledDocument.ElementSpec(anyCellStyle.getAttributeSet(),
                                              DefaultStyledDocument.ElementSpec.EndTagType);
    }

    // open cell tag
    elements.add(esCellStart);
  }
  ( LOOKAHEAD([Style()] Paragraph()) Paragraph(context, doc, t, anyCellStyle, elements)
  | LOOKAHEAD([Style()] Table())  Table(context, doc, t, anyCellStyle, elements)
  | Content(context, doc, t, anyCellStyle, elements, null, null)
  // | ( "{" (Content(context, doc, t, anyCellStyle, elements))+ "}" )
  )
  {
    // close cell tag
    elements.add(esCellEnd);
  }
}

void Paragraph(Any context, StyledDocument doc, Transaction t, AnyAttributeSet currStyle, ArrayList elements) :
{
  ArrayList                         contentElementSpecs;
  boolean                           outermost = true;
  AnyAttributeSet                   paraStyle;
  DefaultStyledDocument.ElementSpec esParaStart;
  DefaultStyledDocument.ElementSpec esParaEnd;
}
{
  [ currStyle = Style(context, t) ]
  <DOC_PARAGRAPH>
  "{"
  {
    outermost = (elements == null);

    contentElementSpecs = (elements != null) ? elements
                                             : new ArrayList(); // consider approximating size - tbd

    // Always create a child style to provide the paragraph tag.
    // We can then ensure the style has the name attribute for
    // the paragraph without mutating any original we were given.
    paraStyle = new AnyAttributeSet();
    paraStyle.add(NodeSpecification.name__,
                   AnyDocument.ANYPARA);

    if (currStyle != null)
      paraStyle.getAttributeSet().setResolveParent(currStyle.getAttributeSet());

    // Open the paragraph element spec
    esParaStart =
      new DefaultStyledDocument.ElementSpec(paraStyle.getAttributeSet(),
                                            DefaultStyledDocument.ElementSpec.StartTagType);
    esParaEnd =
      new DefaultStyledDocument.ElementSpec(paraStyle.getAttributeSet(),
                                            DefaultStyledDocument.ElementSpec.EndTagType);

    contentElementSpecs.add(esParaStart);

    if (AnyDocument.endPara__ == null)
      AnyDocument.endPara__ = new DefaultStyledDocument.ElementSpec(null,
                                                                    DefaultStyledDocument.ElementSpec.ContentType,
                                                                    "\n".toCharArray(), 0, 1);
  }
  ( LOOKAHEAD([Style()] Paragraph()) Paragraph(context, doc, t, currStyle, contentElementSpecs)
  | LOOKAHEAD([Style()] Table()) Table(context, doc, t, currStyle, contentElementSpecs)
  | Content(context, doc, t, currStyle, contentElementSpecs, esParaStart, esParaEnd)
  )+
  "}"
  {
    // End the paragraph in the styled document
    //contentElementSpecs.add(esParaEnd);
    //contentElementSpecs.add(esParaStart);
    contentElementSpecs.add(AnyDocument.endPara__);
    contentElementSpecs.add(esParaEnd);
    if (outermost)
    {
      insertDocument(doc, doc.getLength(), contentElementSpecs);
      contentElementSpecs.clear();
      //contentElementSpecs.add(AnyDocument.endPara__);
      //insertDocument(doc, doc.getLength(), contentElementSpecs);
      /*
      try
      {
        doc.insertString(doc.getLength(), "\n\n", (currStyle != null) ? currStyle.getAttributeSet()
                                                                      : null);
      }
      catch (BadLocationException e)
      {
        throw new RuntimeContainedException(e);
      }
      */
    }
      /*
      try
      {
        doc.insertString(doc.getLength(), "\n", (currStyle != null) ? currStyle.getAttributeSet()
                                                                      : null);
      }
      catch (BadLocationException e)
      {
        throw new RuntimeContainedException(e);
      }
      */

    /*
    contentElementSpecs.add(AnyDocument.endPara__);

    if (outermost)
    {
      insertDocument(doc, doc.getLength(), contentElementSpecs);
      contentElementSpecs.clear();
    }
    */
  }
}

void Content(Any                               context,
             StyledDocument                    doc,
             Transaction                       t,
             AnyAttributeSet                   currStyle,
             ArrayList                         elements,
             DefaultStyledDocument.ElementSpec esParaStart,
             DefaultStyledDocument.ElementSpec esParaEnd) :
{ Any a; }
{
  [ currStyle = Style(context, t) ]
  ( a = Expression() ";"
    {
      // Evaluate the expression specifying the content
      String str = "";
      try
      {
        a = EvalExpr.evalFunc(t,
                              context,
                              a);
        str = AnyDocument.getString(a);
      }
      catch(Exception e)
      {
        throw new RuntimeContainedException(e);
      }
// *** TBD check if contentStyle can be null and prefer that passed in or parsed if so.
      MutableAttributeSet contentStyle = AnyDocument.getStyle(a); // may be null
      if (contentStyle == null)
      {
        if (currStyle != null)
          contentStyle = currStyle.getAttributeSet();
      }

      char[] chars = str.toCharArray();

      if (esParaStart != null)// && esParaStart == null)
      {
        breakContent(chars,
                     elements,
                     contentStyle,
                     esParaStart,
                     esParaEnd);
                     /*
        int contentLen = chars.length;
        int paraStart  = 0;
        int paraBreak  = charIndexOf(chars, '\n', 0);

        if (paraBreak == 0)
          return;

        // Add the first or only section of content.  We want to use newlines within
        // the content as paragraph breaks.
        DefaultStyledDocument.ElementSpec content =
          new DefaultStyledDocument.ElementSpec(contentStyle,
                                                DefaultStyledDocument.ElementSpec.ContentType,
                                                chars,
                                                paraStart,
                                                paraBreak);

        elements.add(content);
        paraStart = paraBreak;
        while ((paraBreak = charIndexOf(chars, '\n', paraStart)) > 0)
        {
          elements.add(AnyDocument.endPara__);
          elements.add(esParaEnd);
          elements.add(esParaStart);
          content =
            new DefaultStyledDocument.ElementSpec(contentStyle,
                                                  DefaultStyledDocument.ElementSpec.ContentType,
                                                  chars,
                                                  paraStart,
                                                  paraBreak);
          elements.add(content);
          paraStart += paraBreak;
        }
        */
      }
      else
      {
        DefaultStyledDocument.ElementSpec content =
          new DefaultStyledDocument.ElementSpec(contentStyle,
                                                DefaultStyledDocument.ElementSpec.ContentType,
                                                chars,
                                                0,
                                                chars.length);
        elements.add(content);
      }
    }
  )
}

AnyAttributeSet Style(Any context, Transaction t) :
{ AnyAttributeSet as; Any a; }
{
  <DOC_STYLE> a = Expression() ";"
  {
    try
    {
      as = (AnyAttributeSet)EvalExpr.evalFunc(t,
                                              context,
                                              a,
                                              AnyAttributeSet.class);
    }
    catch(Exception e)
    {
      throw new RuntimeContainedException(e);
    }
    return as;
  }
}

void Pagebreak(StyledDocument doc) :
{}
{
  <PAGE_BREAK>
  {
    insertDocument(doc, doc.getLength(), AnyDocument.pageBreak__);
  }
}

