/**
 * Copyright (C) 2011 Inqwell Ltd
 *
 * You may distribute under the terms of the Artistic License, as specified in
 * the README file.
 */

/*
 * $Archive: /src/com/inqwell/any/ListenTo.java $
 * $Author: sanderst $
 * $Revision: 1.6 $
 * $Date: 2011-04-07 22:18:20 $
 */
package com.inqwell.any;

import com.inqwell.any.ref.AnyWeakReference;

/**
 * Place a listener on a node to dispatch the given event type(s).
 * Return value is the listener (an instance of EventDispatcher) that
 * can be used as a token so things can be explicitly removed.
 * <note>This is the "new" style <code>listen</code> construct.</note>
 * <p>
 * @author $Author: sanderst $
 * @version $Revision: 1.6 $
 */
public class ListenTo extends    AbstractFunc
                      implements Cloneable
{
  private static final long serialVersionUID = 1L;
  
  public static Any listen__ = AbstractValue.flyweightString("listen");

  // The node we'll listen to events from
  private Any   listenTo_;
  
  // The event types we are interested in dispatching
  private Array eventTypes_;
  
  // The function to handle the event
  private Any   dispatchFunc_;

  // Optional function arguments
  private Map   args_;
  
  // Optional filtering data for instance create events 
  private Any   createData_;
  
  // Whether this event, when dispatched by this listener, will be
  // consumed also so that any further dispatch does not occur. 
  //private Any   consume_;
  private boolean consume_;
  
  // Whether this listener responds to events generated by the process
  // that established it (that is one's "own" events).
  private boolean ignoreOwn_;

  public ListenTo(Any   listenTo,
                  Array eventTypes,
                  Any   dispatchFunc,
                  Map   args,
                  Any   createData)
  {
    listenTo_     = listenTo;
    eventTypes_   = eventTypes;
    dispatchFunc_ = dispatchFunc;
    args_         = args;
    createData_   = createData;
  }
  
  public Any exec(Any a) throws AnyException
  {
    EventGenerator listenTo    = (EventGenerator)EvalExpr.evalFunc
                                          (getTransaction(),
                                           a,
                                           listenTo_,
                                           EventGenerator.class);

    if (listenTo == null)
      nullOperand(listenTo_);
    
    AnyFuncHolder.FuncHolder func = (AnyFuncHolder.FuncHolder)EvalExpr.evalFunc
                                        (getTransaction(),
                                         a,
                                         dispatchFunc_,
                                         AnyFuncHolder.FuncHolder.class);

    if (func == null)
      nullOperand(dispatchFunc_);
    
    // If there are args_ then reoslve them now, not when the event
    // goes off, as this could be from another thread. Croaks if any
    // args don't resolve, as its happening so far ahead of time.
    Map args = resolveArgs(a, getTransaction());
    
    // Resolve optional create data.
    Any createData    = EvalExpr.evalFunc(getTransaction(),
                                          a,
                                          createData_);
    
    Array eventTypes = resolvePaths(eventTypes_, a);
    
    // If there is any then it needs to be added to the creation event
    // types to achieve the filtering.
    if (createData != null)
    {
      // The event types are read only unless already unless there's
      // createData, so clone them in this case.
      eventTypes = (Array)eventTypes.cloneAny();
      addCreateData(createData, eventTypes);
    }
    
    /*
    boolean consume = false;
    Any aConsume = EvalExpr.evalFunc(getTransaction(),
                                     a,
                                     consume_);
    if (aConsume == null && consume_ != null)
      nullOperand(consume_);
    if (aConsume != null)
    {
      AnyBoolean b = new AnyBoolean(aConsume);
      consume = b.getValue();
    }
    */

    EventDispatcher ed = new EventDispatcher();
    
    if (Globals.isServer())
      ed.setConcurrentSafe(true);
    
    ed.addEventListener(new NodeListener(eventTypes,
                                         func,
                                         args,
                                         getTransaction().getProcess(),
                                         consume_,
                                         ignoreOwn_));
    listenTo.addEventListener(ed);
    
    return ed;
  }
  
  public void setConsume(boolean consume)
  {
    consume_ = consume;
  }

  public void setIgnoreOwn(boolean ignoreOwn)
  {
    ignoreOwn_ = ignoreOwn;
  }

  public Object clone () throws CloneNotSupportedException
  {
    ListenTo l = (ListenTo)super.clone();
    
    l.listenTo_       = listenTo_.cloneAny();
    // eventTypes_ is read-only or lazily cloned
    l.dispatchFunc_   = dispatchFunc_.cloneAny();
    l.createData_     = AbstractAny.cloneOrNull(createData_);
    l.args_           = (Map)AbstractAny.cloneOrNull(args_);
    //l.consume_        = (Map)AbstractAny.cloneOrNull(consume_);
    
    return l;
  }
  
  /**
   * Resolve the arguments held within this event to their values.
   * If arguments are supplied by scripted statements then they are
   * typically node references (or other operands that require evaluation).
   * These must be resolved and  
   * @param root
   * @param t
   * @return
   * @throws AnyException
   */
  private Map resolveArgs(Any root, Transaction t) throws AnyException
  {
    Map ret = null;
    if (args_ != null)
    {
      ret = AbstractComposite.simpleMap();
      
      Iter i = args_.createKeysIterator();
      while (i.hasNext())
      {
        Any argkey = i.next();
        Any argval = args_.get(argkey);
        Any newArgval = EvalExpr.evalFunc (t,
                                           root,
                                           argval);
        if (newArgval == null)
          nullOperand(argval);
        
        ret.add(argkey, newArgval);
      }
    }
    return ret;
  }
  
  private void addCreateData(Any createData, Array eventTypes)
  {
    // Generally there will only be one event type that we are
    // listening for but hunt down any creation types and add
    // in the given data
    for (int i = 0; i < eventTypes.entries(); i++)
    {
      Any et = eventTypes.get(i);
      if (et instanceof Map)
      {
        Any basicType = AbstractEvent.getBasicType(et);
        if (basicType.equals(EventConstants.BOT_CREATE))
        {
          Map m = (Map)et;
          m.replaceItem(EventConstants.EVENT_CREATE, createData);
        }
      }
    }
  }
  
  // Scan the event types. If any complex event type contains a path
  // element then ensure it is resolved and replaced in the event type.
  // On first such occurrance, the array is shallow-copied.
  private Array resolvePaths(Array eventTypes, Any context)
  {
    for (int i = 0; i < eventTypes.entries(); i++)
    {
      Any et = eventTypes.get(i);
      if (et instanceof Map)
      {
        Map m = (Map)et;
        Any p = m.getIfContains(EventConstants.EVENT_PATH);
        if (p != null && (p instanceof NodeSpecification))
        {
          NodeSpecification ns = (NodeSpecification)p;
          NodeSpecification nsRes = ns.resolveStart(context,
                                                    getTransaction());
          
          if (eventTypes == eventTypes_ && ns != nsRes)
            eventTypes = eventTypes.shallowCopy();
          
          if (ns != nsRes)
          {
            m = m.shallowCopy();
            m.replaceItem(EventConstants.EVENT_PATH, nsRes);
            eventTypes.replaceItem(i, m);
          }
        }
      }
    }
    return eventTypes;
  }
  
  // Ho ho - we *really* want static here so there are no references
  // from the long-lived listener to the outer ListenTo function!
  private static class NodeListener extends    AbstractAny
                                    implements EventListener,
                                               Cloneable
  {
    private static final long serialVersionUID = 1L;

    private Array eventTypes_;
    
    // Everything we need to create and send the event
    private AnyFuncHolder.FuncHolder  dispatchFunc_;
    private Map                       args_;
    private AnyWeakReference          p_;              // Process
    private boolean                   consume_;
    private boolean                   ignoreOwn_;

    
    private NodeListener(Array                    eventTypes,
                         AnyFuncHolder.FuncHolder func,
                         Map                      args,
                         Process                  p,
                         boolean                  consume,
                         boolean                  ignoreOwn)
    {
      eventTypes_   = eventTypes;
      dispatchFunc_ = func;
      args_         = args;
      p_            = new AnyWeakReference(p);
      consume_      = consume;
      ignoreOwn_    = ignoreOwn;
    }

    public boolean processEvent(Event e) throws AnyException
    {
      Process p = (Process)p_.getAny();
      if (p == null)
      {
        //System.out.println("***** Process was GC'd *****");
        return false;
      }
      
      if (ignoreOwn_ && p == Globals.getProcessForCurrentThread())
        return true;
      
      // In a client we never expect the Process to terminate. Check
      // if the dispatch function says it is still viable.
      
      if (!dispatchFunc_.isViable())
        return false;
      
      Event dispatchEvent = new DispatchedEvent(EventConstants.DISPATCHED,
                                                dispatchFunc_,
                                                args_,
                                                e);
      if (consume_)
        e.consume();
      
      p.send(dispatchEvent);

      return true;
    }

    public Array getDesiredEventTypes()
    {
      return eventTypes_;
    }
  }
}

