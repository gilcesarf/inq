/**
 * Copyright (C) 2011 Inqwell Ltd
 *
 * You may distribute under the terms of the Artistic License, as specified in
 * the README file.
 */

/*
 * $Archive: /src/com/inqwell/any/client/NodeFunction.java $
 * $Author: sanderst $
 * $Revision: 1.2 $
 * $Date: 2011-04-07 22:18:21 $
 */

package com.inqwell.any.client;

import com.inqwell.any.AbstractAny;
import com.inqwell.any.AbstractComposite;
import com.inqwell.any.Any;
import com.inqwell.any.Array;
import com.inqwell.any.BooleanI;
import com.inqwell.any.BreadthFirstIter;
import com.inqwell.any.ByteI;
import com.inqwell.any.CharI;
import com.inqwell.any.DateI;
import com.inqwell.any.Decimal;
import com.inqwell.any.DoubleI;
import com.inqwell.any.EventGenerator;
import com.inqwell.any.FieldSet;
import com.inqwell.any.FloatI;
import com.inqwell.any.Func;
import com.inqwell.any.Globals;
import com.inqwell.any.IntI;
import com.inqwell.any.Iter;
import com.inqwell.any.Locate;
import com.inqwell.any.LocateNode;
import com.inqwell.any.LongI;
import com.inqwell.any.Map;
import com.inqwell.any.NodeSpecification;
import com.inqwell.any.ObjectI;
import com.inqwell.any.Set;
import com.inqwell.any.ShortI;
import com.inqwell.any.StringI;
import com.inqwell.any.Transaction;
import com.inqwell.any.Visitor;

/**
 * Holds a function together with supporting information as to whether a
 * node event would require execution of that function.
 * 
 * @author tom
 *
 */
public class NodeFunction extends AbstractAny
{
  // We collect the various node specifications that would occur
  // in events generated by nodes related to what we are rendering.
  // In the simplest case where we are rendering a single leaf
  // this set will only contain one entry.  Map to the field
  // list we reference in the node specs.
  protected Map        nodeSpecs_ = AbstractComposite.simpleMap();;

  // This is an expression which may result in the node we
  // will render.  For simple components
  // it would be a leaf.
  protected Any        dataNode_;

  private static FieldSet isDispatching__ = new FieldSet();
  
  public NodeFunction()
  {
    this(null);
  }

  public NodeFunction(Any dataNode)
  {
    setDataNode(dataNode);
  }

  public Any getDataNode()
  {
    return dataNode_;
  }

  public Map getNodeSpecs()
  {
    return nodeSpecs_;
  }

  public boolean isDispatching(Any field)
  {
    //System.out.println("AnyRenderInfo.isDispatching " + field);
    //System.out.println("AnyRenderInfo.isDispatching " + nodeSpecs_);
    // Synchronisation not a problem here as in the client only one
    // thread (GUI or server) can be active at a time.
    boolean ret = false;
    if (nodeSpecs_ != null)
    {
      isDispatching__.add(field);
      ret = nodeSpecs_.containsValue(isDispatching__);
      isDispatching__.empty();
    }
    //System.out.println("DISPATCHING " + ret);
    return ret;
  }
  
  public void setDataNode(Any dataNode)
  {
    dataNode_ = dataNode;
  }

  // Note: we must be able to iterate over an expression!
  public boolean resolveNodeRefs(Any contextNode)
  {
    return resolveNodeRefs(nodeSpecs_, contextNode);
  }

  public boolean resolveNodeRefs(Map nodeSpecs, Any contextNode)
  {
    nodeSpecs.empty();
    boolean ret = false;
    
    if (nodeSpecs != nodeSpecs_)
      nodeSpecs_ = nodeSpecs;
    
    if (dataNode_ != null)
    {
      FindNodeSpecs f = new FindNodeSpecs(nodeSpecs, contextNode);
      
      if (dataNode_ instanceof NodeSpecification)
      {
        NodeSpecification n = (NodeSpecification)dataNode_;
        n = n.resolveIndirections(contextNode, Globals.process__.getTransaction());
        dataNode_ = new LocateNode(n);
      }
  
      if (dataNode_ instanceof Locate)
      {
        dataNode_.accept(f);
      }
      else
      {
        // If the rendering is a complex expression then we can't cache
        // the result.
        ret = true;
        
        // Walk the expression finding all the NodeSpecifications
        // held within the LocateNodes it holds.
        BreadthFirstIter i = new BreadthFirstIter(dataNode_);
  
        while (i.hasNext())
        {
          Any a = i.next();
          if (a != null)
            a.accept(f);
        }
      }
    }
    
    return ret;
  }

  public Object clone () throws CloneNotSupportedException
  {
    NodeFunction nf = (NodeFunction)super.clone();
    
    nf.dataNode_        = AbstractAny.cloneOrNull(dataNode_);
    if (nodeSpecs_ != null)
      nf.nodeSpecs_ = nodeSpecs_.shallowCopy();

    return nf;
  }
  
  static private class FindNodeSpecs implements Visitor
  {
    private Map res_;
    private Any contextNode_;

    FindNodeSpecs(Map res, Any contextNode)
    {
      res_         = res;
      contextNode_ = contextNode;
    }

    public void visitMap (Map m)
    {
    }

    public void visitArray (Array a)
    {
    }

    public void visitSet (Set s)
    {
    }

    public void visitUnknown(Any u)
    {
    }

    public void visitAnyBoolean (BooleanI b)
    {
    }

    public void visitAnyByte (ByteI b)
    {
    }

    public void visitAnyChar (CharI c)
    {
    }

    public void visitAnyInt (IntI i)
    {
    }

    public void visitAnyShort (ShortI s)
    {
    }

    public void visitAnyLong (LongI l)
    {
    }

    public void visitAnyFloat (FloatI f)
    {
    }

    public void visitAnyDouble (DoubleI d)
    {
    }

    public void visitDecimal (Decimal d)
    {
    }

    public void visitAnyString (StringI s)
    {
    }

    public void visitAnyDate (DateI d)
    {
    }

    public void visitFunc (Func f)
    {
      // Check if its a LocateNode and if so, fetch its NodeSpecification.
      if (f instanceof LocateNode)
      {
        LocateNode l = (LocateNode)f;
        NodeSpecification ns = l.getNodePath();
        
        // If it is a path that starts with a special prefix
        // then ignore it since we cannot receive events
        // via these routes.
        Any a = ns.getFirst();
        if (NodeSpecification.prefices__.contains(a))
          return;
          
        ns = ns.resolveIndirections(contextNode_, Globals.process__.getTransaction());

        NodeSpecification eventNs = (NodeSpecification)ns.cloneAny();
        
        // The last element is assumed to be the field we are
        // locating.  The event is raised on the Map parent which
        // will be the end of the NS built up by event propagation.
        // [This is, of course, an assumption.  Revisit if it proves
        // to be an invalid one for significant cases.]
        // Knock off the last element and use instead in fields list
        // for this spec.
        Any field = eventNs.getLast();
        eventNs.removeLast();
        if (!res_.contains(eventNs))
        {
          // If contextNode_ was supplied step down eventNs and if successful
          // set the txn flag of the ultimate map.
          if (contextNode_ != null)
          {
            Iter    i = eventNs.createPathItemsIter();
            Map     n = (Map)contextNode_;
            boolean b = true;
            while (i.hasNext())
            {
              if (n == null)
              {
                b = false;
                break;
              }
              
              Any k = i.next();
              if (!n.contains(k))
              {
                b = false;
                break;
              }
              Any c = n.get(k);
              if (!(c instanceof Map))
              {
                b = false;
                break;
              }
              n = (Map)c;
            }
            // If we were successful in navigating all the way down
            // the path then set the txn flag (since we are binding to
            // a variable).  If the parent node is the context node
            // then ignore, because its not allowed to have variables
            // in the context node.  This might happen when code
            // references $this.TypeDef (i.e.the whole object) and the
            // assumption above about fields is invalid
            if (b &&
                (n != contextNode_) &&
                (n instanceof EventGenerator))
            {
              n.setTransactional(true);
            }
          }
          
          Set fs = AbstractComposite.fieldSet();
          fs.add(field);
          res_.add(eventNs, fs);
        }
        else
        {
          FieldSet fs = (FieldSet)res_.get(eventNs);
          if (!fs.contains(field))
            fs.add(field);
        }
      }
    }

    public void visitAnyObject (ObjectI o)
    {
    }

    public void setTransaction(Transaction t)
    {
    }

    public Transaction getTransaction()
    {
      return Transaction.NULL_TRANSACTION;
    }
  }
}
