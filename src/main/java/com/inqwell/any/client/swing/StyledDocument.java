/**
 * Copyright (C) 2011 Inqwell Ltd
 *
 * You may distribute under the terms of the Artistic License, as specified in
 * the README file.
 */

/*
 * $Archive: /src/com/inqwell/any/client/swing/StyledDocument.java $
 * $Author: sanderst $
 * $Revision: 1.2 $
 * $Date: 2011-04-07 22:18:22 $
 */
package com.inqwell.any.client.swing;

import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.Element;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.event.DocumentEvent;
import javax.swing.undo.UndoableEdit;
import javax.swing.event.UndoableEditEvent;
import java.util.Stack;

/**
 * 
 * @author $Author: sanderst $
 * @version $Revision: 1.2 $
 */
public class StyledDocument extends DefaultStyledDocument
{
  /**
   * Expose protected method.
   */
  public void create(DefaultStyledDocument.ElementSpec[] data)
  {
    super.create(data);
  }

  public void insert(int offset,
                     DefaultStyledDocument.ElementSpec[] data) throws BadLocationException
  {
    // Check for multiple top-level elements as can be
    // generated by the document layout parser.
    
    int elems = data.length;
    if (elems == 0)
      return;
    
    ElementSpec es = data[0];
    if (es.getType() != ElementSpec.StartTagType)
    {
      this.insertMarkup(offset, data);
      return;
    }
    
    int count = 0;
    int start = 0;
    int level = 0;
    
    while (count < elems)
    {
      es = data[count];
      count++;
      if (es.getType() == ElementSpec.StartTagType)
        level++;
      else if (es.getType() == ElementSpec.EndTagType)
      {
        if (--level == 0)
        {
          // Check if there's only one segment
          if (count == elems && start == 0)
          {
            // No multiple top level elements so don't copy
            this.insertMarkup(offset, data);
            return;
          }
          else
          {
            // Copy the elements representing this segment
            int len = count - start;
            ElementSpec segment[] = new ElementSpec[len];
            System.arraycopy(data, start, segment, 0, len);
            this.insertMarkup(offset, segment);
            // Bump the offset for the next segment
            for (int i = 0; i < len; i++)
              offset += segment[i].getLength();
            
            start = count;
          }
        }
      }
    }
  }
  
  /**
   * Provide special handling when appending paragraph structure.
   * The default behaviour of DefaultStyledDocument is to insert
   * new structure by fracturing the deepest content at the
   * insertion position. When appending paragraphs to the end
   * of the document this has the effect of repeatedly nesting
   * the structure.  Handle this special case here or defer.
   */
  public void insertMarkup(int offset,
                           DefaultStyledDocument.ElementSpec[] data) throws BadLocationException
  {
    if (data.length == 0)
      return;
    
    ElementSpec es = data[0];
    
    // Check if we are inserting a Row.  If so, possibly
    // modify the offset to assume appending a row to the
    // table nearest to the offset
    if (es.getType() == ElementSpec.StartTagType &&
        es.getAttributes().getAttribute(ElementNameAttribute).equals(StyledEditorKit.ROW))
    {
      int newOffset = findTable(offset, getDefaultRootElement());
      if (newOffset < 0)
        throw new IllegalStateException("No table found");
        
      super.insert(newOffset, data);
      return;
    }
    
    // If inserting content or not appending a paragraph defer to Swing
    if(es.getType() == ElementSpec.ContentType ||
       offset != getLength())
    {
      super.insert(offset, data);
      return;
    }
    
    if (es.getType() != ElementSpec.StartTagType ||
        es.getAttributes().getAttribute(ElementNameAttribute) != ParagraphElementName)
    {
      super.insert(offset, data);
      return;
    }
    
    try
    {
      writeLock();
      Element root = getDefaultRootElement();

      // remember the original content length for computing the offsets
      // of the new content elements we will add.
      int orgDocLen = getLength();
      int docLen = orgDocLen;  // keep track as we go through the content
      
      Content c = getContent();
      int n = data.length;
      StringBuffer sb = new StringBuffer();
      for (int i = 0; i < n; i++)
      {
        ElementSpec esc = data[i];
        if (esc.getLength() > 0)
        {
          sb.append(esc.getArray(), esc.getOffset(),  esc.getLength());
        }
      }

      if (sb.length() == 0)
      {
        // Nothing to insert, bail.
        return;
      }

      int addedLen = sb.length();
//System.out.println("1: doclen is " + orgDocLen);
//System.out.println("1: doclen adding " + addedLen);

      Element adding[] = new Element[1];
      
      // The ultimate content element has its offsets adjusted
      // by the content insertion, so fetch it now and remember
      // what they are.
      Element      lastContent     = null;
      Element      newLastContent  = null;
      Element      lastContentPara = null;
      UndoableEdit cEdit           = null;
      
      if (root.getElementCount() > 1)
      {
        lastContentPara = root.getElement(root.getElementCount()-2);
        lastContent     = lastContentPara.getElement(lastContentPara.getElementCount()-1);
        AttributeSet attrs       = lastContent.getAttributes();
        int          startOffset = lastContent.getStartOffset();
        int          endOffset   = lastContent.getEndOffset();

        //newLastContent = cloneElement(lastContentPara, lastContent);
        cEdit = c.insertString(offset, sb.toString());
        newLastContent = createLeafElement(lastContentPara,
                                           attrs,
                                           startOffset,
                                           endOffset);
        adding[0] = newLastContent;
    //System.out.println("After insert " + newLastContent);
        ((BranchElement)lastContentPara).replace(lastContentPara.getElementCount()-1, 1, adding);
      }
      else
        cEdit = c.insertString(offset, sb.toString());
        
      DefaultDocumentEvent evnt = 
        new DefaultDocumentEvent(offset, addedLen, DocumentEvent.EventType.INSERT);
      
      if (cEdit != null)
        evnt.addEdit(cEdit);

      Stack   stack       = new Stack();
      Element parent      = root;
      int     editOffset  = root.getElementCount() - 1;

      Element current = null;
      Element top     = null;
      for (int i = 0; i < data.length; i++)
      {
//System.out.println("2: iter is " + i);
        es = data[i];
        switch (es.getType())
        {
          case ElementSpec.StartTagType:
            current = createBranchElement(parent, es.getAttributes());
            adding[0] = current;
            // DefaultStyledDocument has a dummy paragraph to signal end
            // of document - insert our new one prior to this when at the
            // top level.
            int eod = (parent == root) ? 1 : 0;
            ((BranchElement)parent).replace(parent.getElementCount() - eod, 0, adding);
            stack.push(parent);
            parent = current;
            if (top == null)
              top = current; // for the edit event
            break;

          case ElementSpec.EndTagType:
            parent  = (Element)stack.pop();
            current = null;
            break;

          case ElementSpec.ContentType:
            current = createLeafElement(parent,
                                        es.getAttributes(),
                                        docLen, //docLen + es.getOffset(),
                                        docLen + es.getLength());//docLen + es.getOffset() + es.getLength());
            adding[0] = current;
            ((BranchElement)parent).replace(parent.getElementCount(), 0, adding);
            docLen += es.getLength();
            break;
        }
      }

      Element docBreakPara = root.getElement(root.getElementCount()-1);
      Element oldDocBreak  = docBreakPara.getElement(0);      
      Element docBreak     = createLeafElement(docBreakPara,
                                            oldDocBreak.getAttributes(),
                                            docLen,
                                            docLen + 1);
      adding[0] = docBreak;
      ((BranchElement)docBreakPara).replace(0, 1, adding);
      
      //adding[0] = docBreak;
      //((BranchElement)root).replace(root.getElementCount()-1, 1, adding);
      //adding[0] = root.getElement(root.getElementCount()-1);
      
      // Set up the edit records for the changes we have made.
      // These are, in document order,
      // 1) [when adding second and subsequent paragraphs] maintain
      //    the offsets of the last content item that are otherwise
      //    changed to track the content we have just added.
      // 2) the paragraph we have just added
      // 3) the new document break
      // Note that these edits each have a different parent, respectively
      // the last content paragraph, the root and the document break
      // paragraph. Thus we create 2 or possibly 3 edit records.
      // Note: inspection shows that the view hierarchy only responds
      // correctly to changes signaled under the root. This means
      // that we signal a single edit that spans the last two or three
      // paragraphs.
      
      if (lastContent != null)
      {
        Element removed[] = new Element[2];
        Element added[]   = new Element[3];
        removed[0] = lastContentPara;
        added[0]   = lastContentPara;
        added[1]   = top;
        removed[1] = docBreakPara;
        added[2]   = docBreakPara;
        evnt.addEdit(new ElementEdit((BranchElement)root, 
                                       root.getElementCount()-3,
                                       removed,
                                       added));
      }
      else
      {
        Element removed[] = new Element[1];
        Element added[]   = new Element[2];
        added[0]   = top;
        removed[0] = docBreakPara;
        added[1]   = docBreakPara;
        evnt.addEdit(new ElementEdit((BranchElement)root, 
                                       0,
                                       removed,
                                       added));
      }

//      if (lastContent != null)
//      {
//        Element removed[] = new Element[1];
//        Element added[]   = new Element[1];
//        removed[0] = lastContent;
//        added[0]   = newLastContent;
//        evnt.addEdit(new ElementEdit((BranchElement)lastContentPara, 
//                                       0,
//                                       removed,
//                                       added));
//      }
//      
//      Element added[]   = new Element[1];
//      added[0] = top;
//      evnt.addEdit(new ElementEdit((BranchElement)root,
//                                    editOffset,
//                                    new Element[0],
//                                    added));
//
//      Element dbAdded[]   = new Element[1];
//      Element dbRemoved[] = new Element[1];
//      dbAdded[0]   = docBreak;
//      dbRemoved[0] = oldDocBreak;
//      evnt.addEdit(new ElementEdit((BranchElement)docBreakPara, 
//                                    0,
//                                    dbRemoved,
//                                    dbAdded));
      
//      ee = new ElementEdit((BranchElement)root, 
//                                       editOffset,
//                                       new Element[0], // nothing removed
//                                       adding);
//      evnt.addEdit(ee);

      // update bidi (possibly)
      //super.insertUpdate(evnt, null);

      // notify the listeners
      evnt.end();
      fireInsertUpdate(evnt);
      fireUndoableEditUpdate(new UndoableEditEvent(this, evnt));

//      DefaultDocumentEvent changes = new DefaultDocumentEvent(0, 
//                                                              docLen,
//                                                              DocumentEvent.EventType.CHANGE);
//      Element[] removed1 = new Element[0];
//      Element[] added1 = new Element[0];
//      changes.addEdit(new ElementEdit(root, 0, removed1, added1));
//      changes.end();
//      fireChangedUpdate(changes);



  	}
  	finally
  	{
	    writeUnlock();
    }
  }
  
  // Traverse the element structure from the given root to find
  // the innermost table element that spans the given offset
  // and return its end position or -1 of no table can be found.
  private int findTable(int offset, Element root)
  {
    int ret = -1;

    int start = root.getStartOffset();
    int end   = root.getEndOffset();
    
    boolean spans = (offset >= start &&
                     offset <= end);

    if (spans &&
        root.getName().equals(StyledEditorKit.TABLE))
    {
      ret = end;
    }
    
    // No point descending the structure at this element if
    // it doesn't span the given offset.
    if (spans)
    {
      int j = root.getElementCount();
      for (int i = 0; i < j; i++)
      {
        Element child = root.getElement(i);
        int next = findTable(offset, child);
        if (next >= 0)
          ret = next;
      }
    }
    return ret;
  }
  
  // Create a new leaf element preserving the attributes and
  // offsets of that given.  Parent on the given argument.
  private Element cloneElement(Element parent, Element child)
  {
    //System.out.println("Cloning " + child);
    Element ret = createLeafElement(parent,
                                    child.getAttributes(),
                                    child.getStartOffset(),
                                    child.getEndOffset());
    return ret;
  }
}
  
